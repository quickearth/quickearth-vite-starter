{"version":3,"file":"createCylinderOutlineGeometry.js","sources":["../../../../Source/Core/CylinderOutlineGeometry.js","../../../../Source/WorkersES6/createCylinderOutlineGeometry.js"],"sourcesContent":["import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CylinderGeometryLibrary from \"./CylinderGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nvar radiusScratch = new Cartesian2();\n\n/**\n * A description of the outline of a cylinder.\n *\n * @alias CylinderOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number} options.length The length of the cylinder.\n * @param {Number} options.topRadius The radius of the top of the cylinder.\n * @param {Number} options.bottomRadius The radius of the bottom of the cylinder.\n * @param {Number} [options.slices=128] The number of edges around the perimeter of the cylinder.\n * @param {Number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surfaces of the cylinder.\n *\n * @exception {DeveloperError} options.length must be greater than 0.\n * @exception {DeveloperError} options.topRadius must be greater than 0.\n * @exception {DeveloperError} options.bottomRadius must be greater than 0.\n * @exception {DeveloperError} bottomRadius and topRadius cannot both equal 0.\n * @exception {DeveloperError} options.slices must be greater than or equal to 3.\n *\n * @see CylinderOutlineGeometry.createGeometry\n *\n * @example\n * // create cylinder geometry\n * var cylinder = new Cesium.CylinderOutlineGeometry({\n *     length: 200000,\n *     topRadius: 80000,\n *     bottomRadius: 200000,\n * });\n * var geometry = Cesium.CylinderOutlineGeometry.createGeometry(cylinder);\n */\nfunction CylinderOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var length = options.length;\n  var topRadius = options.topRadius;\n  var bottomRadius = options.bottomRadius;\n  var slices = defaultValue(options.slices, 128);\n  var numberOfVerticalLines = Math.max(\n    defaultValue(options.numberOfVerticalLines, 16),\n    0\n  );\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"options.positions\", length);\n  Check.typeOf.number(\"options.topRadius\", topRadius);\n  Check.typeOf.number(\"options.bottomRadius\", bottomRadius);\n  Check.typeOf.number.greaterThanOrEquals(\"options.slices\", slices, 3);\n  if (\n    defined(options.offsetAttribute) &&\n    options.offsetAttribute === GeometryOffsetAttribute.TOP\n  ) {\n    throw new DeveloperError(\n      \"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._length = length;\n  this._topRadius = topRadius;\n  this._bottomRadius = bottomRadius;\n  this._slices = slices;\n  this._numberOfVerticalLines = numberOfVerticalLines;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createCylinderOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nCylinderOutlineGeometry.packedLength = 6;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CylinderOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCylinderOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value._length;\n  array[startingIndex++] = value._topRadius;\n  array[startingIndex++] = value._bottomRadius;\n  array[startingIndex++] = value._slices;\n  array[startingIndex++] = value._numberOfVerticalLines;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nvar scratchOptions = {\n  length: undefined,\n  topRadius: undefined,\n  bottomRadius: undefined,\n  slices: undefined,\n  numberOfVerticalLines: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CylinderOutlineGeometry} [result] The object into which to store the result.\n * @returns {CylinderOutlineGeometry} The modified result parameter or a new CylinderOutlineGeometry instance if one was not provided.\n */\nCylinderOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var length = array[startingIndex++];\n  var topRadius = array[startingIndex++];\n  var bottomRadius = array[startingIndex++];\n  var slices = array[startingIndex++];\n  var numberOfVerticalLines = array[startingIndex++];\n  var offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.length = length;\n    scratchOptions.topRadius = topRadius;\n    scratchOptions.bottomRadius = bottomRadius;\n    scratchOptions.slices = slices;\n    scratchOptions.numberOfVerticalLines = numberOfVerticalLines;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new CylinderOutlineGeometry(scratchOptions);\n  }\n\n  result._length = length;\n  result._topRadius = topRadius;\n  result._bottomRadius = bottomRadius;\n  result._slices = slices;\n  result._numberOfVerticalLines = numberOfVerticalLines;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of a cylinder, including its vertices, indices, and a bounding sphere.\n *\n * @param {CylinderOutlineGeometry} cylinderGeometry A description of the cylinder outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCylinderOutlineGeometry.createGeometry = function (cylinderGeometry) {\n  var length = cylinderGeometry._length;\n  var topRadius = cylinderGeometry._topRadius;\n  var bottomRadius = cylinderGeometry._bottomRadius;\n  var slices = cylinderGeometry._slices;\n  var numberOfVerticalLines = cylinderGeometry._numberOfVerticalLines;\n\n  if (\n    length <= 0 ||\n    topRadius < 0 ||\n    bottomRadius < 0 ||\n    (topRadius === 0 && bottomRadius === 0)\n  ) {\n    return;\n  }\n\n  var numVertices = slices * 2;\n\n  var positions = CylinderGeometryLibrary.computePositions(\n    length,\n    topRadius,\n    bottomRadius,\n    slices,\n    false\n  );\n  var numIndices = slices * 2;\n  var numSide;\n  if (numberOfVerticalLines > 0) {\n    var numSideLines = Math.min(numberOfVerticalLines, slices);\n    numSide = Math.round(slices / numSideLines);\n    numIndices += numSideLines;\n  }\n\n  var indices = IndexDatatype.createTypedArray(numVertices, numIndices * 2);\n  var index = 0;\n  var i;\n  for (i = 0; i < slices - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n    indices[index++] = i + slices;\n    indices[index++] = i + 1 + slices;\n  }\n\n  indices[index++] = slices - 1;\n  indices[index++] = 0;\n  indices[index++] = slices + slices - 1;\n  indices[index++] = slices;\n\n  if (numberOfVerticalLines > 0) {\n    for (i = 0; i < slices; i += numSide) {\n      indices[index++] = i;\n      indices[index++] = i + slices;\n    }\n  }\n\n  var attributes = new GeometryAttributes();\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positions,\n  });\n\n  radiusScratch.x = length * 0.5;\n  radiusScratch.y = Math.max(bottomRadius, topRadius);\n\n  var boundingSphere = new BoundingSphere(\n    Cartesian3.ZERO,\n    Cartesian2.magnitude(radiusScratch)\n  );\n\n  if (defined(cylinderGeometry._offsetAttribute)) {\n    length = positions.length;\n    var applyOffset = new Uint8Array(length / 3);\n    var offsetValue =\n      cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n        ? 0\n        : 1;\n    arrayFill(applyOffset, offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: cylinderGeometry._offsetAttribute,\n  });\n};\nexport default CylinderOutlineGeometry;\n","import CylinderOutlineGeometry from \"../Core/CylinderOutlineGeometry.js\";\nimport defined from \"../Core/defined.js\";\n\nfunction createCylinderOutlineGeometry(cylinderGeometry, offset) {\n  if (defined(offset)) {\n    cylinderGeometry = CylinderOutlineGeometry.unpack(cylinderGeometry, offset);\n  }\n  return CylinderOutlineGeometry.createGeometry(cylinderGeometry);\n}\nexport default createCylinderOutlineGeometry;\n"],"names":["radiusScratch","Cartesian2","CylinderOutlineGeometry","options","length","defaultValue","EMPTY_OBJECT","topRadius","bottomRadius","slices","numberOfVerticalLines","Math","max","Check","typeOf","number","greaterThanOrEquals","defined","offsetAttribute","GeometryOffsetAttribute","TOP","DeveloperError","this","_length","_topRadius","_bottomRadius","_slices","_numberOfVerticalLines","_offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","object","scratchOptions","undefined","unpack","result","createGeometry","cylinderGeometry","numSideLines","numSide","numVertices","positions","CylinderGeometryLibrary","computePositions","numIndices","min","round","indices","IndexDatatype","createTypedArray","index","i","attributes","GeometryAttributes","position","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","x","y","boundingSphere","BoundingSphere","Cartesian3","ZERO","magnitude","applyOffset","Uint8Array","offsetValue","NONE","arrayFill","UNSIGNED_BYTE","Geometry","primitiveType","PrimitiveType","LINES","offset"],"mappings":"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"}