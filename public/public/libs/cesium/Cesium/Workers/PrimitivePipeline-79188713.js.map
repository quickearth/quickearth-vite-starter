{"version":3,"file":"PrimitivePipeline-79188713.js","sources":["../../../../Source/Core/OffsetGeometryInstanceAttribute.js","../../../../Source/Scene/PrimitivePipeline.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\n\n/**\n * Value and type information for per-instance geometry attribute that determines the geometry instance offset\n *\n * @alias OffsetGeometryInstanceAttribute\n * @constructor\n *\n * @param {Number} [x=0] The x translation\n * @param {Number} [y=0] The y translation\n * @param {Number} [z=0] The z translation\n *\n * @private\n *\n * @see GeometryInstance\n * @see GeometryInstanceAttribute\n */\nfunction OffsetGeometryInstanceAttribute(x, y, z) {\n  x = defaultValue(x, 0);\n  y = defaultValue(y, 0);\n  z = defaultValue(z, 0);\n\n  /**\n   * The values for the attributes stored in a typed array.\n   *\n   * @type Float32Array\n   */\n  this.value = new Float32Array([x, y, z]);\n}\n\nObject.defineProperties(OffsetGeometryInstanceAttribute.prototype, {\n  /**\n   * The datatype of each component in the attribute, e.g., individual elements in\n   * {@link OffsetGeometryInstanceAttribute#value}.\n   *\n   * @memberof OffsetGeometryInstanceAttribute.prototype\n   *\n   * @type {ComponentDatatype}\n   * @readonly\n   *\n   * @default {@link ComponentDatatype.FLOAT}\n   */\n  componentDatatype: {\n    get: function () {\n      return ComponentDatatype.FLOAT;\n    },\n  },\n\n  /**\n   * The number of components in the attributes, i.e., {@link OffsetGeometryInstanceAttribute#value}.\n   *\n   * @memberof OffsetGeometryInstanceAttribute.prototype\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @default 3\n   */\n  componentsPerAttribute: {\n    get: function () {\n      return 3;\n    },\n  },\n\n  /**\n   * When <code>true</code> and <code>componentDatatype</code> is an integer format,\n   * indicate that the components should be mapped to the range [0, 1] (unsigned)\n   * or [-1, 1] (signed) when they are accessed as floating-point for rendering.\n   *\n   * @memberof OffsetGeometryInstanceAttribute.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  normalize: {\n    get: function () {\n      return false;\n    },\n  },\n});\n\n/**\n * Creates a new {@link OffsetGeometryInstanceAttribute} instance given the provided an enabled flag and {@link DistanceDisplayCondition}.\n *\n * @param {Cartesian3} offset The cartesian offset\n * @returns {OffsetGeometryInstanceAttribute} The new {@link OffsetGeometryInstanceAttribute} instance.\n */\nOffsetGeometryInstanceAttribute.fromCartesian3 = function (offset) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"offset\", offset);\n  //>>includeEnd('debug');\n\n  return new OffsetGeometryInstanceAttribute(offset.x, offset.y, offset.z);\n};\n\n/**\n * Converts a distance display condition to a typed array that can be used to assign a distance display condition attribute.\n *\n * @param {Cartesian3} offset The cartesian offset\n * @param {Float32Array} [result] The array to store the result in, if undefined a new instance will be created.\n * @returns {Float32Array} The modified result parameter or a new instance if result was undefined.\n *\n * @example\n * var attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.modelMatrix = Cesium.OffsetGeometryInstanceAttribute.toValue(modelMatrix, attributes.modelMatrix);\n */\nOffsetGeometryInstanceAttribute.toValue = function (offset, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"offset\", offset);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Float32Array([offset.x, offset.y, offset.z]);\n  }\n\n  result[0] = offset.x;\n  result[1] = offset.y;\n  result[2] = offset.z;\n  return result;\n};\nexport default OffsetGeometryInstanceAttribute;\n","import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport GeographicProjection from \"../Core/GeographicProjection.js\";\nimport Geometry from \"../Core/Geometry.js\";\nimport GeometryAttribute from \"../Core/GeometryAttribute.js\";\nimport GeometryAttributes from \"../Core/GeometryAttributes.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\n\nfunction transformToWorldCoordinates(\n  instances,\n  primitiveModelMatrix,\n  scene3DOnly\n) {\n  var toWorld = !scene3DOnly;\n  var length = instances.length;\n  var i;\n\n  if (!toWorld && length > 1) {\n    var modelMatrix = instances[0].modelMatrix;\n\n    for (i = 1; i < length; ++i) {\n      if (!Matrix4.equals(modelMatrix, instances[i].modelMatrix)) {\n        toWorld = true;\n        break;\n      }\n    }\n  }\n\n  if (toWorld) {\n    for (i = 0; i < length; ++i) {\n      if (defined(instances[i].geometry)) {\n        GeometryPipeline.transformToWorldCoordinates(instances[i]);\n      }\n    }\n  } else {\n    // Leave geometry in local coordinate system; auto update model-matrix.\n    Matrix4.multiplyTransformation(\n      primitiveModelMatrix,\n      instances[0].modelMatrix,\n      primitiveModelMatrix\n    );\n  }\n}\n\nfunction addGeometryBatchId(geometry, batchId) {\n  var attributes = geometry.attributes;\n  var positionAttr = attributes.position;\n  var numberOfComponents =\n    positionAttr.values.length / positionAttr.componentsPerAttribute;\n\n  attributes.batchId = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 1,\n    values: new Float32Array(numberOfComponents),\n  });\n\n  var values = attributes.batchId.values;\n  for (var j = 0; j < numberOfComponents; ++j) {\n    values[j] = batchId;\n  }\n}\n\nfunction addBatchIds(instances) {\n  var length = instances.length;\n\n  for (var i = 0; i < length; ++i) {\n    var instance = instances[i];\n    if (defined(instance.geometry)) {\n      addGeometryBatchId(instance.geometry, i);\n    } else if (\n      defined(instance.westHemisphereGeometry) &&\n      defined(instance.eastHemisphereGeometry)\n    ) {\n      addGeometryBatchId(instance.westHemisphereGeometry, i);\n      addGeometryBatchId(instance.eastHemisphereGeometry, i);\n    }\n  }\n}\n\nfunction geometryPipeline(parameters) {\n  var instances = parameters.instances;\n  var projection = parameters.projection;\n  var uintIndexSupport = parameters.elementIndexUintSupported;\n  var scene3DOnly = parameters.scene3DOnly;\n  var vertexCacheOptimize = parameters.vertexCacheOptimize;\n  var compressVertices = parameters.compressVertices;\n  var modelMatrix = parameters.modelMatrix;\n\n  var i;\n  var geometry;\n  var primitiveType;\n  var length = instances.length;\n\n  for (i = 0; i < length; ++i) {\n    if (defined(instances[i].geometry)) {\n      primitiveType = instances[i].geometry.primitiveType;\n      break;\n    }\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  for (i = 1; i < length; ++i) {\n    if (\n      defined(instances[i].geometry) &&\n      instances[i].geometry.primitiveType !== primitiveType\n    ) {\n      throw new DeveloperError(\n        \"All instance geometries must have the same primitiveType.\"\n      );\n    }\n  }\n  //>>includeEnd('debug');\n\n  // Unify to world coordinates before combining.\n  transformToWorldCoordinates(instances, modelMatrix, scene3DOnly);\n\n  // Clip to IDL\n  if (!scene3DOnly) {\n    for (i = 0; i < length; ++i) {\n      if (defined(instances[i].geometry)) {\n        GeometryPipeline.splitLongitude(instances[i]);\n      }\n    }\n  }\n\n  addBatchIds(instances);\n\n  // Optimize for vertex shader caches\n  if (vertexCacheOptimize) {\n    for (i = 0; i < length; ++i) {\n      var instance = instances[i];\n      if (defined(instance.geometry)) {\n        GeometryPipeline.reorderForPostVertexCache(instance.geometry);\n        GeometryPipeline.reorderForPreVertexCache(instance.geometry);\n      } else if (\n        defined(instance.westHemisphereGeometry) &&\n        defined(instance.eastHemisphereGeometry)\n      ) {\n        GeometryPipeline.reorderForPostVertexCache(\n          instance.westHemisphereGeometry\n        );\n        GeometryPipeline.reorderForPreVertexCache(\n          instance.westHemisphereGeometry\n        );\n\n        GeometryPipeline.reorderForPostVertexCache(\n          instance.eastHemisphereGeometry\n        );\n        GeometryPipeline.reorderForPreVertexCache(\n          instance.eastHemisphereGeometry\n        );\n      }\n    }\n  }\n\n  // Combine into single geometry for better rendering performance.\n  var geometries = GeometryPipeline.combineInstances(instances);\n\n  length = geometries.length;\n  for (i = 0; i < length; ++i) {\n    geometry = geometries[i];\n\n    // Split positions for GPU RTE\n    var attributes = geometry.attributes;\n    var name;\n    if (!scene3DOnly) {\n      for (name in attributes) {\n        if (\n          attributes.hasOwnProperty(name) &&\n          attributes[name].componentDatatype === ComponentDatatype.DOUBLE\n        ) {\n          var name3D = name + \"3D\";\n          var name2D = name + \"2D\";\n\n          // Compute 2D positions\n          GeometryPipeline.projectTo2D(\n            geometry,\n            name,\n            name3D,\n            name2D,\n            projection\n          );\n          if (defined(geometry.boundingSphere) && name === \"position\") {\n            geometry.boundingSphereCV = BoundingSphere.fromVertices(\n              geometry.attributes.position2D.values\n            );\n          }\n\n          GeometryPipeline.encodeAttribute(\n            geometry,\n            name3D,\n            name3D + \"High\",\n            name3D + \"Low\"\n          );\n          GeometryPipeline.encodeAttribute(\n            geometry,\n            name2D,\n            name2D + \"High\",\n            name2D + \"Low\"\n          );\n        }\n      }\n    } else {\n      for (name in attributes) {\n        if (\n          attributes.hasOwnProperty(name) &&\n          attributes[name].componentDatatype === ComponentDatatype.DOUBLE\n        ) {\n          GeometryPipeline.encodeAttribute(\n            geometry,\n            name,\n            name + \"3DHigh\",\n            name + \"3DLow\"\n          );\n        }\n      }\n    }\n\n    // oct encode and pack normals, compress texture coordinates\n    if (compressVertices) {\n      GeometryPipeline.compressVertices(geometry);\n    }\n  }\n\n  if (!uintIndexSupport) {\n    // Break into multiple geometries to fit within unsigned short indices if needed\n    var splitGeometries = [];\n    length = geometries.length;\n    for (i = 0; i < length; ++i) {\n      geometry = geometries[i];\n      splitGeometries = splitGeometries.concat(\n        GeometryPipeline.fitToUnsignedShortIndices(geometry)\n      );\n    }\n\n    geometries = splitGeometries;\n  }\n\n  return geometries;\n}\n\nfunction createPickOffsets(instances, geometryName, geometries, pickOffsets) {\n  var offset;\n  var indexCount;\n  var geometryIndex;\n\n  var offsetIndex = pickOffsets.length - 1;\n  if (offsetIndex >= 0) {\n    var pickOffset = pickOffsets[offsetIndex];\n    offset = pickOffset.offset + pickOffset.count;\n    geometryIndex = pickOffset.index;\n    indexCount = geometries[geometryIndex].indices.length;\n  } else {\n    offset = 0;\n    geometryIndex = 0;\n    indexCount = geometries[geometryIndex].indices.length;\n  }\n\n  var length = instances.length;\n  for (var i = 0; i < length; ++i) {\n    var instance = instances[i];\n    var geometry = instance[geometryName];\n    if (!defined(geometry)) {\n      continue;\n    }\n\n    var count = geometry.indices.length;\n\n    if (offset + count > indexCount) {\n      offset = 0;\n      indexCount = geometries[++geometryIndex].indices.length;\n    }\n\n    pickOffsets.push({\n      index: geometryIndex,\n      offset: offset,\n      count: count,\n    });\n    offset += count;\n  }\n}\n\nfunction createInstancePickOffsets(instances, geometries) {\n  var pickOffsets = [];\n  createPickOffsets(instances, \"geometry\", geometries, pickOffsets);\n  createPickOffsets(\n    instances,\n    \"westHemisphereGeometry\",\n    geometries,\n    pickOffsets\n  );\n  createPickOffsets(\n    instances,\n    \"eastHemisphereGeometry\",\n    geometries,\n    pickOffsets\n  );\n  return pickOffsets;\n}\n\n/**\n * @private\n */\nvar PrimitivePipeline = {};\n\n/**\n * @private\n */\nPrimitivePipeline.combineGeometry = function (parameters) {\n  var geometries;\n  var attributeLocations;\n  var instances = parameters.instances;\n  var length = instances.length;\n  var pickOffsets;\n\n  var offsetInstanceExtend;\n  var hasOffset = false;\n  if (length > 0) {\n    geometries = geometryPipeline(parameters);\n    if (geometries.length > 0) {\n      attributeLocations = GeometryPipeline.createAttributeLocations(\n        geometries[0]\n      );\n      if (parameters.createPickOffsets) {\n        pickOffsets = createInstancePickOffsets(instances, geometries);\n      }\n    }\n    if (\n      defined(instances[0].attributes) &&\n      defined(instances[0].attributes.offset)\n    ) {\n      offsetInstanceExtend = new Array(length);\n      hasOffset = true;\n    }\n  }\n\n  var boundingSpheres = new Array(length);\n  var boundingSpheresCV = new Array(length);\n  for (var i = 0; i < length; ++i) {\n    var instance = instances[i];\n    var geometry = instance.geometry;\n    if (defined(geometry)) {\n      boundingSpheres[i] = geometry.boundingSphere;\n      boundingSpheresCV[i] = geometry.boundingSphereCV;\n      if (hasOffset) {\n        offsetInstanceExtend[i] = instance.geometry.offsetAttribute;\n      }\n    }\n\n    var eastHemisphereGeometry = instance.eastHemisphereGeometry;\n    var westHemisphereGeometry = instance.westHemisphereGeometry;\n    if (defined(eastHemisphereGeometry) && defined(westHemisphereGeometry)) {\n      if (\n        defined(eastHemisphereGeometry.boundingSphere) &&\n        defined(westHemisphereGeometry.boundingSphere)\n      ) {\n        boundingSpheres[i] = BoundingSphere.union(\n          eastHemisphereGeometry.boundingSphere,\n          westHemisphereGeometry.boundingSphere\n        );\n      }\n      if (\n        defined(eastHemisphereGeometry.boundingSphereCV) &&\n        defined(westHemisphereGeometry.boundingSphereCV)\n      ) {\n        boundingSpheresCV[i] = BoundingSphere.union(\n          eastHemisphereGeometry.boundingSphereCV,\n          westHemisphereGeometry.boundingSphereCV\n        );\n      }\n    }\n  }\n\n  return {\n    geometries: geometries,\n    modelMatrix: parameters.modelMatrix,\n    attributeLocations: attributeLocations,\n    pickOffsets: pickOffsets,\n    offsetInstanceExtend: offsetInstanceExtend,\n    boundingSpheres: boundingSpheres,\n    boundingSpheresCV: boundingSpheresCV,\n  };\n};\n\nfunction transferGeometry(geometry, transferableObjects) {\n  var attributes = geometry.attributes;\n  for (var name in attributes) {\n    if (attributes.hasOwnProperty(name)) {\n      var attribute = attributes[name];\n\n      if (defined(attribute) && defined(attribute.values)) {\n        transferableObjects.push(attribute.values.buffer);\n      }\n    }\n  }\n\n  if (defined(geometry.indices)) {\n    transferableObjects.push(geometry.indices.buffer);\n  }\n}\n\nfunction transferGeometries(geometries, transferableObjects) {\n  var length = geometries.length;\n  for (var i = 0; i < length; ++i) {\n    transferGeometry(geometries[i], transferableObjects);\n  }\n}\n\n// This function was created by simplifying packCreateGeometryResults into a count-only operation.\nfunction countCreateGeometryResults(items) {\n  var count = 1;\n  var length = items.length;\n  for (var i = 0; i < length; i++) {\n    var geometry = items[i];\n    ++count;\n\n    if (!defined(geometry)) {\n      continue;\n    }\n\n    var attributes = geometry.attributes;\n\n    count +=\n      7 +\n      2 * BoundingSphere.packedLength +\n      (defined(geometry.indices) ? geometry.indices.length : 0);\n\n    for (var property in attributes) {\n      if (\n        attributes.hasOwnProperty(property) &&\n        defined(attributes[property])\n      ) {\n        var attribute = attributes[property];\n        count += 5 + attribute.values.length;\n      }\n    }\n  }\n\n  return count;\n}\n\n/**\n * @private\n */\nPrimitivePipeline.packCreateGeometryResults = function (\n  items,\n  transferableObjects\n) {\n  var packedData = new Float64Array(countCreateGeometryResults(items));\n  var stringTable = [];\n  var stringHash = {};\n\n  var length = items.length;\n  var count = 0;\n  packedData[count++] = length;\n  for (var i = 0; i < length; i++) {\n    var geometry = items[i];\n\n    var validGeometry = defined(geometry);\n    packedData[count++] = validGeometry ? 1.0 : 0.0;\n\n    if (!validGeometry) {\n      continue;\n    }\n\n    packedData[count++] = geometry.primitiveType;\n    packedData[count++] = geometry.geometryType;\n    packedData[count++] = defaultValue(geometry.offsetAttribute, -1);\n\n    var validBoundingSphere = defined(geometry.boundingSphere) ? 1.0 : 0.0;\n    packedData[count++] = validBoundingSphere;\n    if (validBoundingSphere) {\n      BoundingSphere.pack(geometry.boundingSphere, packedData, count);\n    }\n\n    count += BoundingSphere.packedLength;\n\n    var validBoundingSphereCV = defined(geometry.boundingSphereCV) ? 1.0 : 0.0;\n    packedData[count++] = validBoundingSphereCV;\n    if (validBoundingSphereCV) {\n      BoundingSphere.pack(geometry.boundingSphereCV, packedData, count);\n    }\n\n    count += BoundingSphere.packedLength;\n\n    var attributes = geometry.attributes;\n    var attributesToWrite = [];\n    for (var property in attributes) {\n      if (\n        attributes.hasOwnProperty(property) &&\n        defined(attributes[property])\n      ) {\n        attributesToWrite.push(property);\n        if (!defined(stringHash[property])) {\n          stringHash[property] = stringTable.length;\n          stringTable.push(property);\n        }\n      }\n    }\n\n    packedData[count++] = attributesToWrite.length;\n    for (var q = 0; q < attributesToWrite.length; q++) {\n      var name = attributesToWrite[q];\n      var attribute = attributes[name];\n      packedData[count++] = stringHash[name];\n      packedData[count++] = attribute.componentDatatype;\n      packedData[count++] = attribute.componentsPerAttribute;\n      packedData[count++] = attribute.normalize ? 1 : 0;\n      packedData[count++] = attribute.values.length;\n      packedData.set(attribute.values, count);\n      count += attribute.values.length;\n    }\n\n    var indicesLength = defined(geometry.indices) ? geometry.indices.length : 0;\n    packedData[count++] = indicesLength;\n\n    if (indicesLength > 0) {\n      packedData.set(geometry.indices, count);\n      count += indicesLength;\n    }\n  }\n\n  transferableObjects.push(packedData.buffer);\n\n  return {\n    stringTable: stringTable,\n    packedData: packedData,\n  };\n};\n\n/**\n * @private\n */\nPrimitivePipeline.unpackCreateGeometryResults = function (\n  createGeometryResult\n) {\n  var stringTable = createGeometryResult.stringTable;\n  var packedGeometry = createGeometryResult.packedData;\n\n  var i;\n  var result = new Array(packedGeometry[0]);\n  var resultIndex = 0;\n\n  var packedGeometryIndex = 1;\n  while (packedGeometryIndex < packedGeometry.length) {\n    var valid = packedGeometry[packedGeometryIndex++] === 1.0;\n    if (!valid) {\n      result[resultIndex++] = undefined;\n      continue;\n    }\n\n    var primitiveType = packedGeometry[packedGeometryIndex++];\n    var geometryType = packedGeometry[packedGeometryIndex++];\n    var offsetAttribute = packedGeometry[packedGeometryIndex++];\n    if (offsetAttribute === -1) {\n      offsetAttribute = undefined;\n    }\n\n    var boundingSphere;\n    var boundingSphereCV;\n\n    var validBoundingSphere = packedGeometry[packedGeometryIndex++] === 1.0;\n    if (validBoundingSphere) {\n      boundingSphere = BoundingSphere.unpack(\n        packedGeometry,\n        packedGeometryIndex\n      );\n    }\n\n    packedGeometryIndex += BoundingSphere.packedLength;\n\n    var validBoundingSphereCV = packedGeometry[packedGeometryIndex++] === 1.0;\n    if (validBoundingSphereCV) {\n      boundingSphereCV = BoundingSphere.unpack(\n        packedGeometry,\n        packedGeometryIndex\n      );\n    }\n\n    packedGeometryIndex += BoundingSphere.packedLength;\n\n    var length;\n    var values;\n    var componentsPerAttribute;\n    var attributes = new GeometryAttributes();\n    var numAttributes = packedGeometry[packedGeometryIndex++];\n    for (i = 0; i < numAttributes; i++) {\n      var name = stringTable[packedGeometry[packedGeometryIndex++]];\n      var componentDatatype = packedGeometry[packedGeometryIndex++];\n      componentsPerAttribute = packedGeometry[packedGeometryIndex++];\n      var normalize = packedGeometry[packedGeometryIndex++] !== 0;\n\n      length = packedGeometry[packedGeometryIndex++];\n      values = ComponentDatatype.createTypedArray(componentDatatype, length);\n      for (var valuesIndex = 0; valuesIndex < length; valuesIndex++) {\n        values[valuesIndex] = packedGeometry[packedGeometryIndex++];\n      }\n\n      attributes[name] = new GeometryAttribute({\n        componentDatatype: componentDatatype,\n        componentsPerAttribute: componentsPerAttribute,\n        normalize: normalize,\n        values: values,\n      });\n    }\n\n    var indices;\n    length = packedGeometry[packedGeometryIndex++];\n\n    if (length > 0) {\n      var numberOfVertices = values.length / componentsPerAttribute;\n      indices = IndexDatatype.createTypedArray(numberOfVertices, length);\n      for (i = 0; i < length; i++) {\n        indices[i] = packedGeometry[packedGeometryIndex++];\n      }\n    }\n\n    result[resultIndex++] = new Geometry({\n      primitiveType: primitiveType,\n      geometryType: geometryType,\n      boundingSphere: boundingSphere,\n      boundingSphereCV: boundingSphereCV,\n      indices: indices,\n      attributes: attributes,\n      offsetAttribute: offsetAttribute,\n    });\n  }\n\n  return result;\n};\n\nfunction packInstancesForCombine(instances, transferableObjects) {\n  var length = instances.length;\n  var packedData = new Float64Array(1 + length * 19);\n  var count = 0;\n  packedData[count++] = length;\n  for (var i = 0; i < length; i++) {\n    var instance = instances[i];\n    Matrix4.pack(instance.modelMatrix, packedData, count);\n    count += Matrix4.packedLength;\n    if (defined(instance.attributes) && defined(instance.attributes.offset)) {\n      var values = instance.attributes.offset.value;\n      packedData[count] = values[0];\n      packedData[count + 1] = values[1];\n      packedData[count + 2] = values[2];\n    }\n    count += 3;\n  }\n  transferableObjects.push(packedData.buffer);\n\n  return packedData;\n}\n\nfunction unpackInstancesForCombine(data) {\n  var packedInstances = data;\n  var result = new Array(packedInstances[0]);\n  var count = 0;\n\n  var i = 1;\n  while (i < packedInstances.length) {\n    var modelMatrix = Matrix4.unpack(packedInstances, i);\n    var attributes;\n    i += Matrix4.packedLength;\n    if (defined(packedInstances[i])) {\n      attributes = {\n        offset: new OffsetGeometryInstanceAttribute(\n          packedInstances[i],\n          packedInstances[i + 1],\n          packedInstances[i + 2]\n        ),\n      };\n    }\n    i += 3;\n\n    result[count++] = {\n      modelMatrix: modelMatrix,\n      attributes: attributes,\n    };\n  }\n\n  return result;\n}\n\n/**\n * @private\n */\nPrimitivePipeline.packCombineGeometryParameters = function (\n  parameters,\n  transferableObjects\n) {\n  var createGeometryResults = parameters.createGeometryResults;\n  var length = createGeometryResults.length;\n\n  for (var i = 0; i < length; i++) {\n    transferableObjects.push(createGeometryResults[i].packedData.buffer);\n  }\n\n  return {\n    createGeometryResults: parameters.createGeometryResults,\n    packedInstances: packInstancesForCombine(\n      parameters.instances,\n      transferableObjects\n    ),\n    ellipsoid: parameters.ellipsoid,\n    isGeographic: parameters.projection instanceof GeographicProjection,\n    elementIndexUintSupported: parameters.elementIndexUintSupported,\n    scene3DOnly: parameters.scene3DOnly,\n    vertexCacheOptimize: parameters.vertexCacheOptimize,\n    compressVertices: parameters.compressVertices,\n    modelMatrix: parameters.modelMatrix,\n    createPickOffsets: parameters.createPickOffsets,\n  };\n};\n\n/**\n * @private\n */\nPrimitivePipeline.unpackCombineGeometryParameters = function (\n  packedParameters\n) {\n  var instances = unpackInstancesForCombine(packedParameters.packedInstances);\n  var createGeometryResults = packedParameters.createGeometryResults;\n  var length = createGeometryResults.length;\n  var instanceIndex = 0;\n\n  for (var resultIndex = 0; resultIndex < length; resultIndex++) {\n    var geometries = PrimitivePipeline.unpackCreateGeometryResults(\n      createGeometryResults[resultIndex]\n    );\n    var geometriesLength = geometries.length;\n    for (\n      var geometryIndex = 0;\n      geometryIndex < geometriesLength;\n      geometryIndex++\n    ) {\n      var geometry = geometries[geometryIndex];\n      var instance = instances[instanceIndex];\n      instance.geometry = geometry;\n      ++instanceIndex;\n    }\n  }\n\n  var ellipsoid = Ellipsoid.clone(packedParameters.ellipsoid);\n  var projection = packedParameters.isGeographic\n    ? new GeographicProjection(ellipsoid)\n    : new WebMercatorProjection(ellipsoid);\n\n  return {\n    instances: instances,\n    ellipsoid: ellipsoid,\n    projection: projection,\n    elementIndexUintSupported: packedParameters.elementIndexUintSupported,\n    scene3DOnly: packedParameters.scene3DOnly,\n    vertexCacheOptimize: packedParameters.vertexCacheOptimize,\n    compressVertices: packedParameters.compressVertices,\n    modelMatrix: Matrix4.clone(packedParameters.modelMatrix),\n    createPickOffsets: packedParameters.createPickOffsets,\n  };\n};\n\nfunction packBoundingSpheres(boundingSpheres) {\n  var length = boundingSpheres.length;\n  var bufferLength = 1 + (BoundingSphere.packedLength + 1) * length;\n  var buffer = new Float32Array(bufferLength);\n\n  var bufferIndex = 0;\n  buffer[bufferIndex++] = length;\n\n  for (var i = 0; i < length; ++i) {\n    var bs = boundingSpheres[i];\n    if (!defined(bs)) {\n      buffer[bufferIndex++] = 0.0;\n    } else {\n      buffer[bufferIndex++] = 1.0;\n      BoundingSphere.pack(boundingSpheres[i], buffer, bufferIndex);\n    }\n    bufferIndex += BoundingSphere.packedLength;\n  }\n\n  return buffer;\n}\n\nfunction unpackBoundingSpheres(buffer) {\n  var result = new Array(buffer[0]);\n  var count = 0;\n\n  var i = 1;\n  while (i < buffer.length) {\n    if (buffer[i++] === 1.0) {\n      result[count] = BoundingSphere.unpack(buffer, i);\n    }\n    ++count;\n    i += BoundingSphere.packedLength;\n  }\n\n  return result;\n}\n\n/**\n * @private\n */\nPrimitivePipeline.packCombineGeometryResults = function (\n  results,\n  transferableObjects\n) {\n  if (defined(results.geometries)) {\n    transferGeometries(results.geometries, transferableObjects);\n  }\n\n  var packedBoundingSpheres = packBoundingSpheres(results.boundingSpheres);\n  var packedBoundingSpheresCV = packBoundingSpheres(results.boundingSpheresCV);\n  transferableObjects.push(\n    packedBoundingSpheres.buffer,\n    packedBoundingSpheresCV.buffer\n  );\n\n  return {\n    geometries: results.geometries,\n    attributeLocations: results.attributeLocations,\n    modelMatrix: results.modelMatrix,\n    pickOffsets: results.pickOffsets,\n    offsetInstanceExtend: results.offsetInstanceExtend,\n    boundingSpheres: packedBoundingSpheres,\n    boundingSpheresCV: packedBoundingSpheresCV,\n  };\n};\n\n/**\n * @private\n */\nPrimitivePipeline.unpackCombineGeometryResults = function (packedResult) {\n  return {\n    geometries: packedResult.geometries,\n    attributeLocations: packedResult.attributeLocations,\n    modelMatrix: packedResult.modelMatrix,\n    pickOffsets: packedResult.pickOffsets,\n    offsetInstanceExtend: packedResult.offsetInstanceExtend,\n    boundingSpheres: unpackBoundingSpheres(packedResult.boundingSpheres),\n    boundingSpheresCV: unpackBoundingSpheres(packedResult.boundingSpheresCV),\n  };\n};\nexport default PrimitivePipeline;\n"],"names":["OffsetGeometryInstanceAttribute","x","y","z","defaultValue","this","value","Float32Array","addGeometryBatchId","geometry","batchId","attributes","positionAttr","position","numberOfComponents","values","length","componentsPerAttribute","GeometryAttribute","componentDatatype","ComponentDatatype","FLOAT","j","geometryPipeline","parameters","primitiveType","instances","projection","uintIndexSupport","elementIndexUintSupported","scene3DOnly","vertexCacheOptimize","compressVertices","modelMatrix","i","defined","DeveloperError","primitiveModelMatrix","toWorld","Matrix4","equals","GeometryPipeline","transformToWorldCoordinates","multiplyTransformation","splitLongitude","instance","westHemisphereGeometry","eastHemisphereGeometry","addBatchIds","reorderForPostVertexCache","reorderForPreVertexCache","geometries","combineInstances","name","name3D","name2D","hasOwnProperty","DOUBLE","encodeAttribute","projectTo2D","boundingSphere","boundingSphereCV","BoundingSphere","fromVertices","position2D","splitGeometries","concat","fitToUnsignedShortIndices","createPickOffsets","geometryName","pickOffsets","offset","geometryIndex","indexCount","offsetIndex","pickOffset","count","index","indices","push","Object","defineProperties","prototype","get","normalize","fromCartesian3","Check","toValue","result","PrimitivePipeline","transferGeometries","transferableObjects","attribute","buffer","transferGeometry","packBoundingSpheres","boundingSpheres","bufferLength","packedLength","bufferIndex","bs","pack","unpackBoundingSpheres","Array","unpack","combineGeometry","attributeLocations","offsetInstanceExtend","hasOffset","createAttributeLocations","boundingSpheresCV","offsetAttribute","union","packCreateGeometryResults","items","packedData","Float64Array","property","countCreateGeometryResults","stringTable","stringHash","validGeometry","geometryType","validBoundingSphere","validBoundingSphereCV","attributesToWrite","q","set","indicesLength","unpackCreateGeometryResults","createGeometryResult","packedGeometry","resultIndex","packedGeometryIndex","undefined","GeometryAttributes","numAttributes","createTypedArray","valuesIndex","numberOfVertices","IndexDatatype","Geometry","packCombineGeometryParameters","createGeometryResults","packedInstances","packInstancesForCombine","ellipsoid","isGeographic","GeographicProjection","unpackCombineGeometryParameters","packedParameters","data","unpackInstancesForCombine","instanceIndex","geometriesLength","Ellipsoid","clone","WebMercatorProjection","packCombineGeometryResults","results","packedBoundingSpheres","packedBoundingSpheresCV","unpackCombineGeometryResults","packedResult"],"mappings":"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"}