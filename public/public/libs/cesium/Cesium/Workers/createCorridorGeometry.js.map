{"version":3,"file":"createCorridorGeometry.js","sources":["../../../../Source/Core/CorridorGeometry.js","../../../../Source/WorkersES6/createCorridorGeometry.js"],"sourcesContent":["import arrayFill from \"./arrayFill.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CornerType from \"./CornerType.js\";\nimport CorridorGeometryLibrary from \"./CorridorGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nvar cartesian1 = new Cartesian3();\nvar cartesian2 = new Cartesian3();\nvar cartesian3 = new Cartesian3();\nvar cartesian4 = new Cartesian3();\nvar cartesian5 = new Cartesian3();\nvar cartesian6 = new Cartesian3();\n\nvar scratch1 = new Cartesian3();\nvar scratch2 = new Cartesian3();\n\nfunction scaleToSurface(positions, ellipsoid) {\n  for (var i = 0; i < positions.length; i++) {\n    positions[i] = ellipsoid.scaleToGeodeticSurface(positions[i], positions[i]);\n  }\n  return positions;\n}\n\nfunction addNormals(attr, normal, left, front, back, vertexFormat) {\n  var normals = attr.normals;\n  var tangents = attr.tangents;\n  var bitangents = attr.bitangents;\n  var forward = Cartesian3.normalize(\n    Cartesian3.cross(left, normal, scratch1),\n    scratch1\n  );\n  if (vertexFormat.normal) {\n    CorridorGeometryLibrary.addAttribute(normals, normal, front, back);\n  }\n  if (vertexFormat.tangent) {\n    CorridorGeometryLibrary.addAttribute(tangents, forward, front, back);\n  }\n  if (vertexFormat.bitangent) {\n    CorridorGeometryLibrary.addAttribute(bitangents, left, front, back);\n  }\n}\n\nfunction combine(computedPositions, vertexFormat, ellipsoid) {\n  var positions = computedPositions.positions;\n  var corners = computedPositions.corners;\n  var endPositions = computedPositions.endPositions;\n  var computedLefts = computedPositions.lefts;\n  var computedNormals = computedPositions.normals;\n  var attributes = new GeometryAttributes();\n  var corner;\n  var leftCount = 0;\n  var rightCount = 0;\n  var i;\n  var indicesLength = 0;\n  var length;\n  for (i = 0; i < positions.length; i += 2) {\n    length = positions[i].length - 3;\n    leftCount += length; //subtracting 3 to account for duplicate points at corners\n    indicesLength += length * 2;\n    rightCount += positions[i + 1].length - 3;\n  }\n  leftCount += 3; //add back count for end positions\n  rightCount += 3;\n  for (i = 0; i < corners.length; i++) {\n    corner = corners[i];\n    var leftSide = corners[i].leftPositions;\n    if (defined(leftSide)) {\n      length = leftSide.length;\n      leftCount += length;\n      indicesLength += length;\n    } else {\n      length = corners[i].rightPositions.length;\n      rightCount += length;\n      indicesLength += length;\n    }\n  }\n\n  var addEndPositions = defined(endPositions);\n  var endPositionLength;\n  if (addEndPositions) {\n    endPositionLength = endPositions[0].length - 3;\n    leftCount += endPositionLength;\n    rightCount += endPositionLength;\n    endPositionLength /= 3;\n    indicesLength += endPositionLength * 6;\n  }\n  var size = leftCount + rightCount;\n  var finalPositions = new Float64Array(size);\n  var normals = vertexFormat.normal ? new Float32Array(size) : undefined;\n  var tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;\n  var bitangents = vertexFormat.bitangent ? new Float32Array(size) : undefined;\n  var attr = {\n    normals: normals,\n    tangents: tangents,\n    bitangents: bitangents,\n  };\n  var front = 0;\n  var back = size - 1;\n  var UL, LL, UR, LR;\n  var normal = cartesian1;\n  var left = cartesian2;\n  var rightPos, leftPos;\n  var halfLength = endPositionLength / 2;\n\n  var indices = IndexDatatype.createTypedArray(size / 3, indicesLength);\n  var index = 0;\n  if (addEndPositions) {\n    // add rounded end\n    leftPos = cartesian3;\n    rightPos = cartesian4;\n    var firstEndPositions = endPositions[0];\n    normal = Cartesian3.fromArray(computedNormals, 0, normal);\n    left = Cartesian3.fromArray(computedLefts, 0, left);\n    for (i = 0; i < halfLength; i++) {\n      leftPos = Cartesian3.fromArray(\n        firstEndPositions,\n        (halfLength - 1 - i) * 3,\n        leftPos\n      );\n      rightPos = Cartesian3.fromArray(\n        firstEndPositions,\n        (halfLength + i) * 3,\n        rightPos\n      );\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n      CorridorGeometryLibrary.addAttribute(\n        finalPositions,\n        leftPos,\n        undefined,\n        back\n      );\n      addNormals(attr, normal, left, front, back, vertexFormat);\n\n      LL = front / 3;\n      LR = LL + 1;\n      UL = (back - 2) / 3;\n      UR = UL - 1;\n      indices[index++] = UL;\n      indices[index++] = LL;\n      indices[index++] = UR;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n\n      front += 3;\n      back -= 3;\n    }\n  }\n\n  var posIndex = 0;\n  var compIndex = 0;\n  var rightEdge = positions[posIndex++]; //add first two edges\n  var leftEdge = positions[posIndex++];\n  finalPositions.set(rightEdge, front);\n  finalPositions.set(leftEdge, back - leftEdge.length + 1);\n\n  left = Cartesian3.fromArray(computedLefts, compIndex, left);\n  var rightNormal;\n  var leftNormal;\n  length = leftEdge.length - 3;\n  for (i = 0; i < length; i += 3) {\n    rightNormal = ellipsoid.geodeticSurfaceNormal(\n      Cartesian3.fromArray(rightEdge, i, scratch1),\n      scratch1\n    );\n    leftNormal = ellipsoid.geodeticSurfaceNormal(\n      Cartesian3.fromArray(leftEdge, length - i, scratch2),\n      scratch2\n    );\n    normal = Cartesian3.normalize(\n      Cartesian3.add(rightNormal, leftNormal, normal),\n      normal\n    );\n    addNormals(attr, normal, left, front, back, vertexFormat);\n\n    LL = front / 3;\n    LR = LL + 1;\n    UL = (back - 2) / 3;\n    UR = UL - 1;\n    indices[index++] = UL;\n    indices[index++] = LL;\n    indices[index++] = UR;\n    indices[index++] = UR;\n    indices[index++] = LL;\n    indices[index++] = LR;\n\n    front += 3;\n    back -= 3;\n  }\n\n  rightNormal = ellipsoid.geodeticSurfaceNormal(\n    Cartesian3.fromArray(rightEdge, length, scratch1),\n    scratch1\n  );\n  leftNormal = ellipsoid.geodeticSurfaceNormal(\n    Cartesian3.fromArray(leftEdge, length, scratch2),\n    scratch2\n  );\n  normal = Cartesian3.normalize(\n    Cartesian3.add(rightNormal, leftNormal, normal),\n    normal\n  );\n  compIndex += 3;\n  for (i = 0; i < corners.length; i++) {\n    var j;\n    corner = corners[i];\n    var l = corner.leftPositions;\n    var r = corner.rightPositions;\n    var pivot;\n    var start;\n    var outsidePoint = cartesian6;\n    var previousPoint = cartesian3;\n    var nextPoint = cartesian4;\n    normal = Cartesian3.fromArray(computedNormals, compIndex, normal);\n    if (defined(l)) {\n      addNormals(attr, normal, left, undefined, back, vertexFormat);\n      back -= 3;\n      pivot = LR;\n      start = UR;\n      for (j = 0; j < l.length / 3; j++) {\n        outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);\n        indices[index++] = pivot;\n        indices[index++] = start - j - 1;\n        indices[index++] = start - j;\n        CorridorGeometryLibrary.addAttribute(\n          finalPositions,\n          outsidePoint,\n          undefined,\n          back\n        );\n        previousPoint = Cartesian3.fromArray(\n          finalPositions,\n          (start - j - 1) * 3,\n          previousPoint\n        );\n        nextPoint = Cartesian3.fromArray(finalPositions, pivot * 3, nextPoint);\n        left = Cartesian3.normalize(\n          Cartesian3.subtract(previousPoint, nextPoint, left),\n          left\n        );\n        addNormals(attr, normal, left, undefined, back, vertexFormat);\n        back -= 3;\n      }\n      outsidePoint = Cartesian3.fromArray(\n        finalPositions,\n        pivot * 3,\n        outsidePoint\n      );\n      previousPoint = Cartesian3.subtract(\n        Cartesian3.fromArray(finalPositions, start * 3, previousPoint),\n        outsidePoint,\n        previousPoint\n      );\n      nextPoint = Cartesian3.subtract(\n        Cartesian3.fromArray(finalPositions, (start - j) * 3, nextPoint),\n        outsidePoint,\n        nextPoint\n      );\n      left = Cartesian3.normalize(\n        Cartesian3.add(previousPoint, nextPoint, left),\n        left\n      );\n      addNormals(attr, normal, left, front, undefined, vertexFormat);\n      front += 3;\n    } else {\n      addNormals(attr, normal, left, front, undefined, vertexFormat);\n      front += 3;\n      pivot = UR;\n      start = LR;\n      for (j = 0; j < r.length / 3; j++) {\n        outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);\n        indices[index++] = pivot;\n        indices[index++] = start + j;\n        indices[index++] = start + j + 1;\n        CorridorGeometryLibrary.addAttribute(\n          finalPositions,\n          outsidePoint,\n          front\n        );\n        previousPoint = Cartesian3.fromArray(\n          finalPositions,\n          pivot * 3,\n          previousPoint\n        );\n        nextPoint = Cartesian3.fromArray(\n          finalPositions,\n          (start + j) * 3,\n          nextPoint\n        );\n        left = Cartesian3.normalize(\n          Cartesian3.subtract(previousPoint, nextPoint, left),\n          left\n        );\n        addNormals(attr, normal, left, front, undefined, vertexFormat);\n        front += 3;\n      }\n      outsidePoint = Cartesian3.fromArray(\n        finalPositions,\n        pivot * 3,\n        outsidePoint\n      );\n      previousPoint = Cartesian3.subtract(\n        Cartesian3.fromArray(finalPositions, (start + j) * 3, previousPoint),\n        outsidePoint,\n        previousPoint\n      );\n      nextPoint = Cartesian3.subtract(\n        Cartesian3.fromArray(finalPositions, start * 3, nextPoint),\n        outsidePoint,\n        nextPoint\n      );\n      left = Cartesian3.normalize(\n        Cartesian3.negate(Cartesian3.add(nextPoint, previousPoint, left), left),\n        left\n      );\n      addNormals(attr, normal, left, undefined, back, vertexFormat);\n      back -= 3;\n    }\n    rightEdge = positions[posIndex++];\n    leftEdge = positions[posIndex++];\n    rightEdge.splice(0, 3); //remove duplicate points added by corner\n    leftEdge.splice(leftEdge.length - 3, 3);\n    finalPositions.set(rightEdge, front);\n    finalPositions.set(leftEdge, back - leftEdge.length + 1);\n    length = leftEdge.length - 3;\n\n    compIndex += 3;\n    left = Cartesian3.fromArray(computedLefts, compIndex, left);\n    for (j = 0; j < leftEdge.length; j += 3) {\n      rightNormal = ellipsoid.geodeticSurfaceNormal(\n        Cartesian3.fromArray(rightEdge, j, scratch1),\n        scratch1\n      );\n      leftNormal = ellipsoid.geodeticSurfaceNormal(\n        Cartesian3.fromArray(leftEdge, length - j, scratch2),\n        scratch2\n      );\n      normal = Cartesian3.normalize(\n        Cartesian3.add(rightNormal, leftNormal, normal),\n        normal\n      );\n      addNormals(attr, normal, left, front, back, vertexFormat);\n\n      LR = front / 3;\n      LL = LR - 1;\n      UR = (back - 2) / 3;\n      UL = UR + 1;\n      indices[index++] = UL;\n      indices[index++] = LL;\n      indices[index++] = UR;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n\n      front += 3;\n      back -= 3;\n    }\n    front -= 3;\n    back += 3;\n  }\n  normal = Cartesian3.fromArray(\n    computedNormals,\n    computedNormals.length - 3,\n    normal\n  );\n  addNormals(attr, normal, left, front, back, vertexFormat);\n\n  if (addEndPositions) {\n    // add rounded end\n    front += 3;\n    back -= 3;\n    leftPos = cartesian3;\n    rightPos = cartesian4;\n    var lastEndPositions = endPositions[1];\n    for (i = 0; i < halfLength; i++) {\n      leftPos = Cartesian3.fromArray(\n        lastEndPositions,\n        (endPositionLength - i - 1) * 3,\n        leftPos\n      );\n      rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);\n      CorridorGeometryLibrary.addAttribute(\n        finalPositions,\n        leftPos,\n        undefined,\n        back\n      );\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n      addNormals(attr, normal, left, front, back, vertexFormat);\n\n      LR = front / 3;\n      LL = LR - 1;\n      UR = (back - 2) / 3;\n      UL = UR + 1;\n      indices[index++] = UL;\n      indices[index++] = LL;\n      indices[index++] = UR;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n\n      front += 3;\n      back -= 3;\n    }\n  }\n\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: finalPositions,\n  });\n\n  if (vertexFormat.st) {\n    var st = new Float32Array((size / 3) * 2);\n    var rightSt;\n    var leftSt;\n    var stIndex = 0;\n    if (addEndPositions) {\n      leftCount /= 3;\n      rightCount /= 3;\n      var theta = Math.PI / (endPositionLength + 1);\n      leftSt = 1 / (leftCount - endPositionLength + 1);\n      rightSt = 1 / (rightCount - endPositionLength + 1);\n      var a;\n      var halfEndPos = endPositionLength / 2;\n      for (i = halfEndPos + 1; i < endPositionLength + 1; i++) {\n        // lower left rounded end\n        a = CesiumMath.PI_OVER_TWO + theta * i;\n        st[stIndex++] = rightSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n      for (i = 1; i < rightCount - endPositionLength + 1; i++) {\n        // bottom edge\n        st[stIndex++] = i * rightSt;\n        st[stIndex++] = 0;\n      }\n      for (i = endPositionLength; i > halfEndPos; i--) {\n        // lower right rounded end\n        a = CesiumMath.PI_OVER_TWO - i * theta;\n        st[stIndex++] = 1 - rightSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n      for (i = halfEndPos; i > 0; i--) {\n        // upper right rounded end\n        a = CesiumMath.PI_OVER_TWO - theta * i;\n        st[stIndex++] = 1 - leftSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n      for (i = leftCount - endPositionLength; i > 0; i--) {\n        // top edge\n        st[stIndex++] = i * leftSt;\n        st[stIndex++] = 1;\n      }\n      for (i = 1; i < halfEndPos + 1; i++) {\n        // upper left rounded end\n        a = CesiumMath.PI_OVER_TWO + theta * i;\n        st[stIndex++] = leftSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n    } else {\n      leftCount /= 3;\n      rightCount /= 3;\n      leftSt = 1 / (leftCount - 1);\n      rightSt = 1 / (rightCount - 1);\n      for (i = 0; i < rightCount; i++) {\n        // bottom edge\n        st[stIndex++] = i * rightSt;\n        st[stIndex++] = 0;\n      }\n      for (i = leftCount; i > 0; i--) {\n        // top edge\n        st[stIndex++] = (i - 1) * leftSt;\n        st[stIndex++] = 1;\n      }\n    }\n\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: st,\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attr.normals,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attr.tangents,\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attr.bitangents,\n    });\n  }\n\n  return {\n    attributes: attributes,\n    indices: indices,\n  };\n}\n\nfunction extrudedAttributes(attributes, vertexFormat) {\n  if (\n    !vertexFormat.normal &&\n    !vertexFormat.tangent &&\n    !vertexFormat.bitangent &&\n    !vertexFormat.st\n  ) {\n    return attributes;\n  }\n  var positions = attributes.position.values;\n  var topNormals;\n  var topBitangents;\n  if (vertexFormat.normal || vertexFormat.bitangent) {\n    topNormals = attributes.normal.values;\n    topBitangents = attributes.bitangent.values;\n  }\n  var size = attributes.position.values.length / 18;\n  var threeSize = size * 3;\n  var twoSize = size * 2;\n  var sixSize = threeSize * 2;\n  var i;\n  if (vertexFormat.normal || vertexFormat.bitangent || vertexFormat.tangent) {\n    var normals = vertexFormat.normal\n      ? new Float32Array(threeSize * 6)\n      : undefined;\n    var tangents = vertexFormat.tangent\n      ? new Float32Array(threeSize * 6)\n      : undefined;\n    var bitangents = vertexFormat.bitangent\n      ? new Float32Array(threeSize * 6)\n      : undefined;\n    var topPosition = cartesian1;\n    var bottomPosition = cartesian2;\n    var previousPosition = cartesian3;\n    var normal = cartesian4;\n    var tangent = cartesian5;\n    var bitangent = cartesian6;\n    var attrIndex = sixSize;\n    for (i = 0; i < threeSize; i += 3) {\n      var attrIndexOffset = attrIndex + sixSize;\n      topPosition = Cartesian3.fromArray(positions, i, topPosition);\n      bottomPosition = Cartesian3.fromArray(\n        positions,\n        i + threeSize,\n        bottomPosition\n      );\n      previousPosition = Cartesian3.fromArray(\n        positions,\n        (i + 3) % threeSize,\n        previousPosition\n      );\n      bottomPosition = Cartesian3.subtract(\n        bottomPosition,\n        topPosition,\n        bottomPosition\n      );\n      previousPosition = Cartesian3.subtract(\n        previousPosition,\n        topPosition,\n        previousPosition\n      );\n      normal = Cartesian3.normalize(\n        Cartesian3.cross(bottomPosition, previousPosition, normal),\n        normal\n      );\n      if (vertexFormat.normal) {\n        CorridorGeometryLibrary.addAttribute(normals, normal, attrIndexOffset);\n        CorridorGeometryLibrary.addAttribute(\n          normals,\n          normal,\n          attrIndexOffset + 3\n        );\n        CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex);\n        CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex + 3);\n      }\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\n        bitangent = Cartesian3.fromArray(topNormals, i, bitangent);\n        if (vertexFormat.bitangent) {\n          CorridorGeometryLibrary.addAttribute(\n            bitangents,\n            bitangent,\n            attrIndexOffset\n          );\n          CorridorGeometryLibrary.addAttribute(\n            bitangents,\n            bitangent,\n            attrIndexOffset + 3\n          );\n          CorridorGeometryLibrary.addAttribute(\n            bitangents,\n            bitangent,\n            attrIndex\n          );\n          CorridorGeometryLibrary.addAttribute(\n            bitangents,\n            bitangent,\n            attrIndex + 3\n          );\n        }\n\n        if (vertexFormat.tangent) {\n          tangent = Cartesian3.normalize(\n            Cartesian3.cross(bitangent, normal, tangent),\n            tangent\n          );\n          CorridorGeometryLibrary.addAttribute(\n            tangents,\n            tangent,\n            attrIndexOffset\n          );\n          CorridorGeometryLibrary.addAttribute(\n            tangents,\n            tangent,\n            attrIndexOffset + 3\n          );\n          CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndex);\n          CorridorGeometryLibrary.addAttribute(\n            tangents,\n            tangent,\n            attrIndex + 3\n          );\n        }\n      }\n      attrIndex += 6;\n    }\n\n    if (vertexFormat.normal) {\n      normals.set(topNormals); //top\n      for (i = 0; i < threeSize; i += 3) {\n        //bottom normals\n        normals[i + threeSize] = -topNormals[i];\n        normals[i + threeSize + 1] = -topNormals[i + 1];\n        normals[i + threeSize + 2] = -topNormals[i + 2];\n      }\n      attributes.normal.values = normals;\n    } else {\n      attributes.normal = undefined;\n    }\n\n    if (vertexFormat.bitangent) {\n      bitangents.set(topBitangents); //top\n      bitangents.set(topBitangents, threeSize); //bottom\n      attributes.bitangent.values = bitangents;\n    } else {\n      attributes.bitangent = undefined;\n    }\n\n    if (vertexFormat.tangent) {\n      var topTangents = attributes.tangent.values;\n      tangents.set(topTangents); //top\n      tangents.set(topTangents, threeSize); //bottom\n      attributes.tangent.values = tangents;\n    }\n  }\n  if (vertexFormat.st) {\n    var topSt = attributes.st.values;\n    var st = new Float32Array(twoSize * 6);\n    st.set(topSt); //top\n    st.set(topSt, twoSize); //bottom\n    var index = twoSize * 2;\n\n    for (var j = 0; j < 2; j++) {\n      st[index++] = topSt[0];\n      st[index++] = topSt[1];\n      for (i = 2; i < twoSize; i += 2) {\n        var s = topSt[i];\n        var t = topSt[i + 1];\n        st[index++] = s;\n        st[index++] = t;\n        st[index++] = s;\n        st[index++] = t;\n      }\n      st[index++] = topSt[0];\n      st[index++] = topSt[1];\n    }\n    attributes.st.values = st;\n  }\n\n  return attributes;\n}\n\nfunction addWallPositions(positions, index, wallPositions) {\n  wallPositions[index++] = positions[0];\n  wallPositions[index++] = positions[1];\n  wallPositions[index++] = positions[2];\n  for (var i = 3; i < positions.length; i += 3) {\n    var x = positions[i];\n    var y = positions[i + 1];\n    var z = positions[i + 2];\n    wallPositions[index++] = x;\n    wallPositions[index++] = y;\n    wallPositions[index++] = z;\n    wallPositions[index++] = x;\n    wallPositions[index++] = y;\n    wallPositions[index++] = z;\n  }\n  wallPositions[index++] = positions[0];\n  wallPositions[index++] = positions[1];\n  wallPositions[index++] = positions[2];\n\n  return wallPositions;\n}\n\nfunction computePositionsExtruded(params, vertexFormat) {\n  var topVertexFormat = new VertexFormat({\n    position: vertexFormat.position,\n    normal:\n      vertexFormat.normal || vertexFormat.bitangent || params.shadowVolume,\n    tangent: vertexFormat.tangent,\n    bitangent: vertexFormat.normal || vertexFormat.bitangent,\n    st: vertexFormat.st,\n  });\n  var ellipsoid = params.ellipsoid;\n  var computedPositions = CorridorGeometryLibrary.computePositions(params);\n  var attr = combine(computedPositions, topVertexFormat, ellipsoid);\n  var height = params.height;\n  var extrudedHeight = params.extrudedHeight;\n  var attributes = attr.attributes;\n  var indices = attr.indices;\n  var positions = attributes.position.values;\n  var length = positions.length;\n  var newPositions = new Float64Array(length * 6);\n  var extrudedPositions = new Float64Array(length);\n  extrudedPositions.set(positions);\n  var wallPositions = new Float64Array(length * 4);\n\n  positions = PolygonPipeline.scaleToGeodeticHeight(\n    positions,\n    height,\n    ellipsoid\n  );\n  wallPositions = addWallPositions(positions, 0, wallPositions);\n  extrudedPositions = PolygonPipeline.scaleToGeodeticHeight(\n    extrudedPositions,\n    extrudedHeight,\n    ellipsoid\n  );\n  wallPositions = addWallPositions(\n    extrudedPositions,\n    length * 2,\n    wallPositions\n  );\n  newPositions.set(positions);\n  newPositions.set(extrudedPositions, length);\n  newPositions.set(wallPositions, length * 2);\n  attributes.position.values = newPositions;\n\n  attributes = extrudedAttributes(attributes, vertexFormat);\n  var i;\n  var size = length / 3;\n  if (params.shadowVolume) {\n    var topNormals = attributes.normal.values;\n    length = topNormals.length;\n\n    var extrudeNormals = new Float32Array(length * 6);\n    for (i = 0; i < length; i++) {\n      topNormals[i] = -topNormals[i];\n    }\n    //only get normals for bottom layer that's going to be pushed down\n    extrudeNormals.set(topNormals, length); //bottom face\n    extrudeNormals = addWallPositions(topNormals, length * 4, extrudeNormals); //bottom wall\n    attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals,\n    });\n    if (!vertexFormat.normal) {\n      attributes.normal = undefined;\n    }\n  }\n  if (defined(params.offsetAttribute)) {\n    var applyOffset = new Uint8Array(size * 6);\n    if (params.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      applyOffset = arrayFill(applyOffset, 1, 0, size); // top face\n      applyOffset = arrayFill(applyOffset, 1, size * 2, size * 4); // top wall\n    } else {\n      var applyOffsetValue =\n        params.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      applyOffset = arrayFill(applyOffset, applyOffsetValue);\n    }\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  var iLength = indices.length;\n  var twoSize = size + size;\n  var newIndices = IndexDatatype.createTypedArray(\n    newPositions.length / 3,\n    iLength * 2 + twoSize * 3\n  );\n  newIndices.set(indices);\n  var index = iLength;\n  for (i = 0; i < iLength; i += 3) {\n    // bottom indices\n    var v0 = indices[i];\n    var v1 = indices[i + 1];\n    var v2 = indices[i + 2];\n    newIndices[index++] = v2 + size;\n    newIndices[index++] = v1 + size;\n    newIndices[index++] = v0 + size;\n  }\n\n  var UL, LL, UR, LR;\n\n  for (i = 0; i < twoSize; i += 2) {\n    //wall indices\n    UL = i + twoSize;\n    LL = UL + twoSize;\n    UR = UL + 1;\n    LR = LL + 1;\n    newIndices[index++] = UL;\n    newIndices[index++] = LL;\n    newIndices[index++] = UR;\n    newIndices[index++] = UR;\n    newIndices[index++] = LL;\n    newIndices[index++] = LR;\n  }\n\n  return {\n    attributes: attributes,\n    indices: newIndices,\n  };\n}\n\nvar scratchCartesian1 = new Cartesian3();\nvar scratchCartesian2 = new Cartesian3();\nvar scratchCartographic = new Cartographic();\n\nfunction computeOffsetPoints(\n  position1,\n  position2,\n  ellipsoid,\n  halfWidth,\n  min,\n  max\n) {\n  // Compute direction of offset the point\n  var direction = Cartesian3.subtract(position2, position1, scratchCartesian1);\n  Cartesian3.normalize(direction, direction);\n  var normal = ellipsoid.geodeticSurfaceNormal(position1, scratchCartesian2);\n  var offsetDirection = Cartesian3.cross(direction, normal, scratchCartesian1);\n  Cartesian3.multiplyByScalar(offsetDirection, halfWidth, offsetDirection);\n\n  var minLat = min.latitude;\n  var minLon = min.longitude;\n  var maxLat = max.latitude;\n  var maxLon = max.longitude;\n\n  // Compute 2 offset points\n  Cartesian3.add(position1, offsetDirection, scratchCartesian2);\n  ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);\n\n  var lat = scratchCartographic.latitude;\n  var lon = scratchCartographic.longitude;\n  minLat = Math.min(minLat, lat);\n  minLon = Math.min(minLon, lon);\n  maxLat = Math.max(maxLat, lat);\n  maxLon = Math.max(maxLon, lon);\n\n  Cartesian3.subtract(position1, offsetDirection, scratchCartesian2);\n  ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);\n\n  lat = scratchCartographic.latitude;\n  lon = scratchCartographic.longitude;\n  minLat = Math.min(minLat, lat);\n  minLon = Math.min(minLon, lon);\n  maxLat = Math.max(maxLat, lat);\n  maxLon = Math.max(maxLon, lon);\n\n  min.latitude = minLat;\n  min.longitude = minLon;\n  max.latitude = maxLat;\n  max.longitude = maxLon;\n}\n\nvar scratchCartesianOffset = new Cartesian3();\nvar scratchCartesianEnds = new Cartesian3();\nvar scratchCartographicMin = new Cartographic();\nvar scratchCartographicMax = new Cartographic();\n\nfunction computeRectangle(positions, ellipsoid, width, cornerType, result) {\n  positions = scaleToSurface(positions, ellipsoid);\n  var cleanPositions = arrayRemoveDuplicates(\n    positions,\n    Cartesian3.equalsEpsilon\n  );\n  var length = cleanPositions.length;\n  if (length < 2 || width <= 0) {\n    return new Rectangle();\n  }\n  var halfWidth = width * 0.5;\n\n  scratchCartographicMin.latitude = Number.POSITIVE_INFINITY;\n  scratchCartographicMin.longitude = Number.POSITIVE_INFINITY;\n  scratchCartographicMax.latitude = Number.NEGATIVE_INFINITY;\n  scratchCartographicMax.longitude = Number.NEGATIVE_INFINITY;\n\n  var lat, lon;\n  if (cornerType === CornerType.ROUNDED) {\n    // Compute start cap\n    var first = cleanPositions[0];\n    Cartesian3.subtract(first, cleanPositions[1], scratchCartesianOffset);\n    Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);\n    Cartesian3.multiplyByScalar(\n      scratchCartesianOffset,\n      halfWidth,\n      scratchCartesianOffset\n    );\n    Cartesian3.add(first, scratchCartesianOffset, scratchCartesianEnds);\n\n    ellipsoid.cartesianToCartographic(\n      scratchCartesianEnds,\n      scratchCartographic\n    );\n    lat = scratchCartographic.latitude;\n    lon = scratchCartographic.longitude;\n    scratchCartographicMin.latitude = Math.min(\n      scratchCartographicMin.latitude,\n      lat\n    );\n    scratchCartographicMin.longitude = Math.min(\n      scratchCartographicMin.longitude,\n      lon\n    );\n    scratchCartographicMax.latitude = Math.max(\n      scratchCartographicMax.latitude,\n      lat\n    );\n    scratchCartographicMax.longitude = Math.max(\n      scratchCartographicMax.longitude,\n      lon\n    );\n  }\n\n  // Compute the rest\n  for (var i = 0; i < length - 1; ++i) {\n    computeOffsetPoints(\n      cleanPositions[i],\n      cleanPositions[i + 1],\n      ellipsoid,\n      halfWidth,\n      scratchCartographicMin,\n      scratchCartographicMax\n    );\n  }\n\n  // Compute ending point\n  var last = cleanPositions[length - 1];\n  Cartesian3.subtract(last, cleanPositions[length - 2], scratchCartesianOffset);\n  Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);\n  Cartesian3.multiplyByScalar(\n    scratchCartesianOffset,\n    halfWidth,\n    scratchCartesianOffset\n  );\n  Cartesian3.add(last, scratchCartesianOffset, scratchCartesianEnds);\n  computeOffsetPoints(\n    last,\n    scratchCartesianEnds,\n    ellipsoid,\n    halfWidth,\n    scratchCartographicMin,\n    scratchCartographicMax\n  );\n\n  if (cornerType === CornerType.ROUNDED) {\n    // Compute end cap\n    ellipsoid.cartesianToCartographic(\n      scratchCartesianEnds,\n      scratchCartographic\n    );\n    lat = scratchCartographic.latitude;\n    lon = scratchCartographic.longitude;\n    scratchCartographicMin.latitude = Math.min(\n      scratchCartographicMin.latitude,\n      lat\n    );\n    scratchCartographicMin.longitude = Math.min(\n      scratchCartographicMin.longitude,\n      lon\n    );\n    scratchCartographicMax.latitude = Math.max(\n      scratchCartographicMax.latitude,\n      lat\n    );\n    scratchCartographicMax.longitude = Math.max(\n      scratchCartographicMax.longitude,\n      lon\n    );\n  }\n\n  var rectangle = defined(result) ? result : new Rectangle();\n  rectangle.north = scratchCartographicMax.latitude;\n  rectangle.south = scratchCartographicMin.latitude;\n  rectangle.east = scratchCartographicMax.longitude;\n  rectangle.west = scratchCartographicMin.longitude;\n\n  return rectangle;\n}\n\n/**\n * A description of a corridor. Corridor geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias CorridorGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.\n * @param {Number} options.width The distance between the edges of the corridor in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Number} [options.height=0] The distance in meters between the ellipsoid surface and the positions.\n * @param {Number} [options.extrudedHeight] The distance in meters between the ellipsoid surface and the extruded face.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n *\n * @see CorridorGeometry.createGeometry\n * @see Packable\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Corridor.html|Cesium Sandcastle Corridor Demo}\n *\n * @example\n * var corridor = new Cesium.CorridorGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\n *   width : 100000\n * });\n */\nfunction CorridorGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var positions = options.positions;\n  var width = options.width;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", positions);\n  Check.defined(\"options.width\", width);\n  //>>includeEnd('debug');\n\n  var height = defaultValue(options.height, 0.0);\n  var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  this._positions = positions;\n  this._ellipsoid = Ellipsoid.clone(\n    defaultValue(options.ellipsoid, Ellipsoid.WGS84)\n  );\n  this._vertexFormat = VertexFormat.clone(\n    defaultValue(options.vertexFormat, VertexFormat.DEFAULT)\n  );\n  this._width = width;\n  this._height = Math.max(height, extrudedHeight);\n  this._extrudedHeight = Math.min(height, extrudedHeight);\n  this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n  this._granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\n  this._workerName = \"createCorridorGeometry\";\n  this._offsetAttribute = options.offsetAttribute;\n  this._rectangle = undefined;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  this.packedLength =\n    1 +\n    positions.length * Cartesian3.packedLength +\n    Ellipsoid.packedLength +\n    VertexFormat.packedLength +\n    7;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CorridorGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCorridorGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var positions = value._positions;\n  var length = positions.length;\n  array[startingIndex++] = length;\n\n  for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._width;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._cornerType;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nvar scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nvar scratchVertexFormat = new VertexFormat();\nvar scratchOptions = {\n  positions: undefined,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  width: undefined,\n  height: undefined,\n  extrudedHeight: undefined,\n  cornerType: undefined,\n  granularity: undefined,\n  shadowVolume: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CorridorGeometry} [result] The object into which to store the result.\n * @returns {CorridorGeometry} The modified result parameter or a new CorridorGeometry instance if one was not provided.\n */\nCorridorGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var length = array[startingIndex++];\n  var positions = new Array(length);\n\n  for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  var vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  var width = array[startingIndex++];\n  var height = array[startingIndex++];\n  var extrudedHeight = array[startingIndex++];\n  var cornerType = array[startingIndex++];\n  var granularity = array[startingIndex++];\n  var shadowVolume = array[startingIndex++] === 1.0;\n  var offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.positions = positions;\n    scratchOptions.width = width;\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.cornerType = cornerType;\n    scratchOptions.granularity = granularity;\n    scratchOptions.shadowVolume = shadowVolume;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n\n    return new CorridorGeometry(scratchOptions);\n  }\n\n  result._positions = positions;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._width = width;\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._cornerType = cornerType;\n  result._granularity = granularity;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the bounding rectangle given the provided options\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.\n * @param {Number} options.width The distance between the edges of the corridor in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n * @param {Rectangle} [result] An object in which to store the result.\n *\n * @returns {Rectangle} The result rectangle.\n */\nCorridorGeometry.computeRectangle = function (options, result) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var positions = options.positions;\n  var width = options.width;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", positions);\n  Check.defined(\"options.width\", width);\n  //>>includeEnd('debug');\n\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n\n  return computeRectangle(positions, ellipsoid, width, cornerType, result);\n};\n\n/**\n * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.\n *\n * @param {CorridorGeometry} corridorGeometry A description of the corridor.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCorridorGeometry.createGeometry = function (corridorGeometry) {\n  var positions = corridorGeometry._positions;\n  var width = corridorGeometry._width;\n  var ellipsoid = corridorGeometry._ellipsoid;\n\n  positions = scaleToSurface(positions, ellipsoid);\n  var cleanPositions = arrayRemoveDuplicates(\n    positions,\n    Cartesian3.equalsEpsilon\n  );\n\n  if (cleanPositions.length < 2 || width <= 0) {\n    return;\n  }\n\n  var height = corridorGeometry._height;\n  var extrudedHeight = corridorGeometry._extrudedHeight;\n  var extrude = !CesiumMath.equalsEpsilon(\n    height,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2\n  );\n\n  var vertexFormat = corridorGeometry._vertexFormat;\n  var params = {\n    ellipsoid: ellipsoid,\n    positions: cleanPositions,\n    width: width,\n    cornerType: corridorGeometry._cornerType,\n    granularity: corridorGeometry._granularity,\n    saveAttributes: true,\n  };\n  var attr;\n  if (extrude) {\n    params.height = height;\n    params.extrudedHeight = extrudedHeight;\n    params.shadowVolume = corridorGeometry._shadowVolume;\n    params.offsetAttribute = corridorGeometry._offsetAttribute;\n    attr = computePositionsExtruded(params, vertexFormat);\n  } else {\n    var computedPositions = CorridorGeometryLibrary.computePositions(params);\n    attr = combine(computedPositions, vertexFormat, ellipsoid);\n    attr.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n      attr.attributes.position.values,\n      height,\n      ellipsoid\n    );\n\n    if (defined(corridorGeometry._offsetAttribute)) {\n      var applyOffsetValue =\n        corridorGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      var length = attr.attributes.position.values.length;\n      var applyOffset = new Uint8Array(length / 3);\n      arrayFill(applyOffset, applyOffsetValue);\n      attr.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n  }\n  var attributes = attr.attributes;\n  var boundingSphere = BoundingSphere.fromVertices(\n    attributes.position.values,\n    undefined,\n    3\n  );\n  if (!vertexFormat.position) {\n    attr.attributes.position.values = undefined;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: attr.indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: corridorGeometry._offsetAttribute,\n  });\n};\n\n/**\n * @private\n */\nCorridorGeometry.createShadowVolume = function (\n  corridorGeometry,\n  minHeightFunc,\n  maxHeightFunc\n) {\n  var granularity = corridorGeometry._granularity;\n  var ellipsoid = corridorGeometry._ellipsoid;\n\n  var minHeight = minHeightFunc(granularity, ellipsoid);\n  var maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n  return new CorridorGeometry({\n    positions: corridorGeometry._positions,\n    width: corridorGeometry._width,\n    cornerType: corridorGeometry._cornerType,\n    ellipsoid: ellipsoid,\n    granularity: granularity,\n    extrudedHeight: minHeight,\n    height: maxHeight,\n    vertexFormat: VertexFormat.POSITION_ONLY,\n    shadowVolume: true,\n  });\n};\n\nObject.defineProperties(CorridorGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function () {\n      if (!defined(this._rectangle)) {\n        this._rectangle = computeRectangle(\n          this._positions,\n          this._ellipsoid,\n          this._width,\n          this._cornerType\n        );\n      }\n      return this._rectangle;\n    },\n  },\n  /**\n   * For remapping texture coordinates when rendering CorridorGeometries as GroundPrimitives.\n   *\n   * Corridors don't support stRotation,\n   * so just return the corners of the original system.\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function () {\n      return [0, 0, 0, 1, 1, 0];\n    },\n  },\n});\nexport default CorridorGeometry;\n","import CorridorGeometry from \"../Core/CorridorGeometry.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\n\nfunction createCorridorGeometry(corridorGeometry, offset) {\n  if (defined(offset)) {\n    corridorGeometry = CorridorGeometry.unpack(corridorGeometry, offset);\n  }\n  corridorGeometry._ellipsoid = Ellipsoid.clone(corridorGeometry._ellipsoid);\n  return CorridorGeometry.createGeometry(corridorGeometry);\n}\nexport default createCorridorGeometry;\n"],"names":["cartesian1","Cartesian3","cartesian2","cartesian3","cartesian4","cartesian5","cartesian6","scratch1","scratch2","scaleToSurface","positions","ellipsoid","i","length","scaleToGeodeticSurface","addNormals","attr","normal","left","front","back","vertexFormat","normals","tangents","bitangents","forward","normalize","cross","CorridorGeometryLibrary","addAttribute","tangent","bitangent","combine","computedPositions","corners","endPositions","computedLefts","lefts","computedNormals","attributes","GeometryAttributes","leftCount","rightCount","indicesLength","corner","leftSide","leftPositions","defined","rightPositions","endPositionLength","addEndPositions","UL","LL","UR","LR","size","finalPositions","Float64Array","Float32Array","undefined","halfLength","indices","IndexDatatype","createTypedArray","index","leftPos","rightPos","firstEndPositions","fromArray","rightNormal","leftNormal","posIndex","compIndex","rightEdge","leftEdge","set","geodeticSurfaceNormal","add","j","pivot","start","l","r","outsidePoint","previousPoint","nextPoint","subtract","negate","splice","lastEndPositions","position","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","st","stIndex","a","theta","Math","PI","leftSt","rightSt","halfEndPos","CesiumMath","PI_OVER_TWO","cos","sin","FLOAT","addWallPositions","wallPositions","x","y","z","computePositionsExtruded","params","topVertexFormat","VertexFormat","shadowVolume","computePositions","height","extrudedHeight","newPositions","extrudedPositions","PolygonPipeline","scaleToGeodeticHeight","topNormals","topBitangents","threeSize","twoSize","sixSize","topTangents","topPosition","bottomPosition","previousPosition","attrIndex","attrIndexOffset","topSt","s","t","extrudedAttributes","extrudeNormals","extrudeDirection","offsetAttribute","applyOffset","Uint8Array","GeometryOffsetAttribute","TOP","arrayFill","applyOffsetValue","NONE","UNSIGNED_BYTE","iLength","newIndices","v0","v1","v2","scratchCartesian1","scratchCartesian2","scratchCartographic","Cartographic","computeOffsetPoints","position1","position2","halfWidth","min","max","direction","offsetDirection","multiplyByScalar","minLat","latitude","minLon","longitude","maxLat","maxLon","cartesianToCartographic","lat","lon","scratchCartesianOffset","scratchCartesianEnds","scratchCartographicMin","scratchCartographicMax","computeRectangle","width","cornerType","result","cleanPositions","arrayRemoveDuplicates","equalsEpsilon","Rectangle","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","CornerType","ROUNDED","first","last","rectangle","north","south","east","west","CorridorGeometry","options","defaultValue","EMPTY_OBJECT","Check","this","_positions","_ellipsoid","Ellipsoid","clone","WGS84","_vertexFormat","DEFAULT","_width","_height","_extrudedHeight","_cornerType","_granularity","granularity","RADIANS_PER_DEGREE","_shadowVolume","_workerName","_offsetAttribute","_rectangle","packedLength","pack","value","array","startingIndex","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","scratchOptions","unpack","Array","createGeometry","corridorGeometry","extrude","EPSILON2","saveAttributes","boundingSphere","BoundingSphere","fromVertices","Geometry","primitiveType","PrimitiveType","TRIANGLES","createShadowVolume","minHeightFunc","maxHeightFunc","minHeight","maxHeight","POSITION_ONLY","Object","defineProperties","prototype","get","textureCoordinateRotationPoints","offset"],"mappings":"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"}