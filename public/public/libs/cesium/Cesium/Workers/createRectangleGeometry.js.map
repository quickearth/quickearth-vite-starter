{"version":3,"file":"createRectangleGeometry.js","sources":["../../../../Source/Core/RectangleGeometry.js","../../../../Source/WorkersES6/createRectangleGeometry.js"],"sourcesContent":["import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix2 from \"./Matrix2.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport RectangleGeometryLibrary from \"./RectangleGeometryLibrary.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nvar positionScratch = new Cartesian3();\nvar normalScratch = new Cartesian3();\nvar tangentScratch = new Cartesian3();\nvar bitangentScratch = new Cartesian3();\nvar rectangleScratch = new Rectangle();\nvar stScratch = new Cartesian2();\nvar bottomBoundingSphere = new BoundingSphere();\nvar topBoundingSphere = new BoundingSphere();\n\nfunction createAttributes(vertexFormat, attributes) {\n  var geo = new Geometry({\n    attributes: new GeometryAttributes(),\n    primitiveType: PrimitiveType.TRIANGLES,\n  });\n\n  geo.attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: attributes.positions,\n  });\n  if (vertexFormat.normal) {\n    geo.attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attributes.normals,\n    });\n  }\n  if (vertexFormat.tangent) {\n    geo.attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attributes.tangents,\n    });\n  }\n  if (vertexFormat.bitangent) {\n    geo.attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attributes.bitangents,\n    });\n  }\n  return geo;\n}\n\nfunction calculateAttributes(\n  positions,\n  vertexFormat,\n  ellipsoid,\n  tangentRotationMatrix\n) {\n  var length = positions.length;\n\n  var normals = vertexFormat.normal ? new Float32Array(length) : undefined;\n  var tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;\n  var bitangents = vertexFormat.bitangent\n    ? new Float32Array(length)\n    : undefined;\n\n  var attrIndex = 0;\n  var bitangent = bitangentScratch;\n  var tangent = tangentScratch;\n  var normal = normalScratch;\n  if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n    for (var i = 0; i < length; i += 3) {\n      var p = Cartesian3.fromArray(positions, i, positionScratch);\n      var attrIndex1 = attrIndex + 1;\n      var attrIndex2 = attrIndex + 2;\n\n      normal = ellipsoid.geodeticSurfaceNormal(p, normal);\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\n        Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\n        Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent);\n        Cartesian3.normalize(tangent, tangent);\n\n        if (vertexFormat.bitangent) {\n          Cartesian3.normalize(\n            Cartesian3.cross(normal, tangent, bitangent),\n            bitangent\n          );\n        }\n      }\n\n      if (vertexFormat.normal) {\n        normals[attrIndex] = normal.x;\n        normals[attrIndex1] = normal.y;\n        normals[attrIndex2] = normal.z;\n      }\n      if (vertexFormat.tangent) {\n        tangents[attrIndex] = tangent.x;\n        tangents[attrIndex1] = tangent.y;\n        tangents[attrIndex2] = tangent.z;\n      }\n      if (vertexFormat.bitangent) {\n        bitangents[attrIndex] = bitangent.x;\n        bitangents[attrIndex1] = bitangent.y;\n        bitangents[attrIndex2] = bitangent.z;\n      }\n      attrIndex += 3;\n    }\n  }\n  return createAttributes(vertexFormat, {\n    positions: positions,\n    normals: normals,\n    tangents: tangents,\n    bitangents: bitangents,\n  });\n}\n\nvar v1Scratch = new Cartesian3();\nvar v2Scratch = new Cartesian3();\n\nfunction calculateAttributesWall(positions, vertexFormat, ellipsoid) {\n  var length = positions.length;\n\n  var normals = vertexFormat.normal ? new Float32Array(length) : undefined;\n  var tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;\n  var bitangents = vertexFormat.bitangent\n    ? new Float32Array(length)\n    : undefined;\n\n  var normalIndex = 0;\n  var tangentIndex = 0;\n  var bitangentIndex = 0;\n  var recomputeNormal = true;\n\n  var bitangent = bitangentScratch;\n  var tangent = tangentScratch;\n  var normal = normalScratch;\n  if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n    for (var i = 0; i < length; i += 6) {\n      var p = Cartesian3.fromArray(positions, i, positionScratch);\n      var p1 = Cartesian3.fromArray(positions, (i + 6) % length, v1Scratch);\n      if (recomputeNormal) {\n        var p2 = Cartesian3.fromArray(positions, (i + 3) % length, v2Scratch);\n        Cartesian3.subtract(p1, p, p1);\n        Cartesian3.subtract(p2, p, p2);\n        normal = Cartesian3.normalize(Cartesian3.cross(p2, p1, normal), normal);\n        recomputeNormal = false;\n      }\n\n      if (Cartesian3.equalsEpsilon(p1, p, CesiumMath.EPSILON10)) {\n        // if we've reached a corner\n        recomputeNormal = true;\n      }\n\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\n        bitangent = ellipsoid.geodeticSurfaceNormal(p, bitangent);\n        if (vertexFormat.tangent) {\n          tangent = Cartesian3.normalize(\n            Cartesian3.cross(bitangent, normal, tangent),\n            tangent\n          );\n        }\n      }\n\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = normal.x;\n        normals[normalIndex++] = normal.y;\n        normals[normalIndex++] = normal.z;\n        normals[normalIndex++] = normal.x;\n        normals[normalIndex++] = normal.y;\n        normals[normalIndex++] = normal.z;\n      }\n\n      if (vertexFormat.tangent) {\n        tangents[tangentIndex++] = tangent.x;\n        tangents[tangentIndex++] = tangent.y;\n        tangents[tangentIndex++] = tangent.z;\n        tangents[tangentIndex++] = tangent.x;\n        tangents[tangentIndex++] = tangent.y;\n        tangents[tangentIndex++] = tangent.z;\n      }\n\n      if (vertexFormat.bitangent) {\n        bitangents[bitangentIndex++] = bitangent.x;\n        bitangents[bitangentIndex++] = bitangent.y;\n        bitangents[bitangentIndex++] = bitangent.z;\n        bitangents[bitangentIndex++] = bitangent.x;\n        bitangents[bitangentIndex++] = bitangent.y;\n        bitangents[bitangentIndex++] = bitangent.z;\n      }\n    }\n  }\n\n  return createAttributes(vertexFormat, {\n    positions: positions,\n    normals: normals,\n    tangents: tangents,\n    bitangents: bitangents,\n  });\n}\n\nfunction constructRectangle(rectangleGeometry, computedOptions) {\n  var vertexFormat = rectangleGeometry._vertexFormat;\n  var ellipsoid = rectangleGeometry._ellipsoid;\n  var height = computedOptions.height;\n  var width = computedOptions.width;\n  var northCap = computedOptions.northCap;\n  var southCap = computedOptions.southCap;\n\n  var rowStart = 0;\n  var rowEnd = height;\n  var rowHeight = height;\n  var size = 0;\n  if (northCap) {\n    rowStart = 1;\n    rowHeight -= 1;\n    size += 1;\n  }\n  if (southCap) {\n    rowEnd -= 1;\n    rowHeight -= 1;\n    size += 1;\n  }\n  size += width * rowHeight;\n\n  var positions = vertexFormat.position\n    ? new Float64Array(size * 3)\n    : undefined;\n  var textureCoordinates = vertexFormat.st\n    ? new Float32Array(size * 2)\n    : undefined;\n\n  var posIndex = 0;\n  var stIndex = 0;\n\n  var position = positionScratch;\n  var st = stScratch;\n\n  var minX = Number.MAX_VALUE;\n  var minY = Number.MAX_VALUE;\n  var maxX = -Number.MAX_VALUE;\n  var maxY = -Number.MAX_VALUE;\n\n  for (var row = rowStart; row < rowEnd; ++row) {\n    for (var col = 0; col < width; ++col) {\n      RectangleGeometryLibrary.computePosition(\n        computedOptions,\n        ellipsoid,\n        vertexFormat.st,\n        row,\n        col,\n        position,\n        st\n      );\n\n      positions[posIndex++] = position.x;\n      positions[posIndex++] = position.y;\n      positions[posIndex++] = position.z;\n\n      if (vertexFormat.st) {\n        textureCoordinates[stIndex++] = st.x;\n        textureCoordinates[stIndex++] = st.y;\n\n        minX = Math.min(minX, st.x);\n        minY = Math.min(minY, st.y);\n        maxX = Math.max(maxX, st.x);\n        maxY = Math.max(maxY, st.y);\n      }\n    }\n  }\n  if (northCap) {\n    RectangleGeometryLibrary.computePosition(\n      computedOptions,\n      ellipsoid,\n      vertexFormat.st,\n      0,\n      0,\n      position,\n      st\n    );\n\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n\n    if (vertexFormat.st) {\n      textureCoordinates[stIndex++] = st.x;\n      textureCoordinates[stIndex++] = st.y;\n\n      minX = st.x;\n      minY = st.y;\n      maxX = st.x;\n      maxY = st.y;\n    }\n  }\n  if (southCap) {\n    RectangleGeometryLibrary.computePosition(\n      computedOptions,\n      ellipsoid,\n      vertexFormat.st,\n      height - 1,\n      0,\n      position,\n      st\n    );\n\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex] = position.z;\n\n    if (vertexFormat.st) {\n      textureCoordinates[stIndex++] = st.x;\n      textureCoordinates[stIndex] = st.y;\n\n      minX = Math.min(minX, st.x);\n      minY = Math.min(minY, st.y);\n      maxX = Math.max(maxX, st.x);\n      maxY = Math.max(maxY, st.y);\n    }\n  }\n\n  if (\n    vertexFormat.st &&\n    (minX < 0.0 || minY < 0.0 || maxX > 1.0 || maxY > 1.0)\n  ) {\n    for (var k = 0; k < textureCoordinates.length; k += 2) {\n      textureCoordinates[k] = (textureCoordinates[k] - minX) / (maxX - minX);\n      textureCoordinates[k + 1] =\n        (textureCoordinates[k + 1] - minY) / (maxY - minY);\n    }\n  }\n\n  var geo = calculateAttributes(\n    positions,\n    vertexFormat,\n    ellipsoid,\n    computedOptions.tangentRotationMatrix\n  );\n\n  var indicesSize = 6 * (width - 1) * (rowHeight - 1);\n  if (northCap) {\n    indicesSize += 3 * (width - 1);\n  }\n  if (southCap) {\n    indicesSize += 3 * (width - 1);\n  }\n  var indices = IndexDatatype.createTypedArray(size, indicesSize);\n  var index = 0;\n  var indicesIndex = 0;\n  var i;\n  for (i = 0; i < rowHeight - 1; ++i) {\n    for (var j = 0; j < width - 1; ++j) {\n      var upperLeft = index;\n      var lowerLeft = upperLeft + width;\n      var lowerRight = lowerLeft + 1;\n      var upperRight = upperLeft + 1;\n      indices[indicesIndex++] = upperLeft;\n      indices[indicesIndex++] = lowerLeft;\n      indices[indicesIndex++] = upperRight;\n      indices[indicesIndex++] = upperRight;\n      indices[indicesIndex++] = lowerLeft;\n      indices[indicesIndex++] = lowerRight;\n      ++index;\n    }\n    ++index;\n  }\n  if (northCap || southCap) {\n    var northIndex = size - 1;\n    var southIndex = size - 1;\n    if (northCap && southCap) {\n      northIndex = size - 2;\n    }\n\n    var p1;\n    var p2;\n    index = 0;\n\n    if (northCap) {\n      for (i = 0; i < width - 1; i++) {\n        p1 = index;\n        p2 = p1 + 1;\n        indices[indicesIndex++] = northIndex;\n        indices[indicesIndex++] = p1;\n        indices[indicesIndex++] = p2;\n        ++index;\n      }\n    }\n    if (southCap) {\n      index = (rowHeight - 1) * width;\n      for (i = 0; i < width - 1; i++) {\n        p1 = index;\n        p2 = p1 + 1;\n        indices[indicesIndex++] = p1;\n        indices[indicesIndex++] = southIndex;\n        indices[indicesIndex++] = p2;\n        ++index;\n      }\n    }\n  }\n\n  geo.indices = indices;\n  if (vertexFormat.st) {\n    geo.attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: textureCoordinates,\n    });\n  }\n\n  return geo;\n}\n\nfunction addWallPositions(\n  wallPositions,\n  posIndex,\n  i,\n  topPositions,\n  bottomPositions\n) {\n  wallPositions[posIndex++] = topPositions[i];\n  wallPositions[posIndex++] = topPositions[i + 1];\n  wallPositions[posIndex++] = topPositions[i + 2];\n  wallPositions[posIndex++] = bottomPositions[i];\n  wallPositions[posIndex++] = bottomPositions[i + 1];\n  wallPositions[posIndex] = bottomPositions[i + 2];\n  return wallPositions;\n}\n\nfunction addWallTextureCoordinates(wallTextures, stIndex, i, st) {\n  wallTextures[stIndex++] = st[i];\n  wallTextures[stIndex++] = st[i + 1];\n  wallTextures[stIndex++] = st[i];\n  wallTextures[stIndex] = st[i + 1];\n  return wallTextures;\n}\n\nvar scratchVertexFormat = new VertexFormat();\n\nfunction constructExtrudedRectangle(rectangleGeometry, computedOptions) {\n  var shadowVolume = rectangleGeometry._shadowVolume;\n  var offsetAttributeValue = rectangleGeometry._offsetAttribute;\n  var vertexFormat = rectangleGeometry._vertexFormat;\n  var minHeight = rectangleGeometry._extrudedHeight;\n  var maxHeight = rectangleGeometry._surfaceHeight;\n  var ellipsoid = rectangleGeometry._ellipsoid;\n\n  var height = computedOptions.height;\n  var width = computedOptions.width;\n\n  var i;\n\n  if (shadowVolume) {\n    var newVertexFormat = VertexFormat.clone(vertexFormat, scratchVertexFormat);\n    newVertexFormat.normal = true;\n    rectangleGeometry._vertexFormat = newVertexFormat;\n  }\n\n  var topBottomGeo = constructRectangle(rectangleGeometry, computedOptions);\n\n  if (shadowVolume) {\n    rectangleGeometry._vertexFormat = vertexFormat;\n  }\n\n  var topPositions = PolygonPipeline.scaleToGeodeticHeight(\n    topBottomGeo.attributes.position.values,\n    maxHeight,\n    ellipsoid,\n    false\n  );\n  topPositions = new Float64Array(topPositions);\n  var length = topPositions.length;\n  var newLength = length * 2;\n  var positions = new Float64Array(newLength);\n  positions.set(topPositions);\n  var bottomPositions = PolygonPipeline.scaleToGeodeticHeight(\n    topBottomGeo.attributes.position.values,\n    minHeight,\n    ellipsoid\n  );\n  positions.set(bottomPositions, length);\n  topBottomGeo.attributes.position.values = positions;\n\n  var normals = vertexFormat.normal ? new Float32Array(newLength) : undefined;\n  var tangents = vertexFormat.tangent ? new Float32Array(newLength) : undefined;\n  var bitangents = vertexFormat.bitangent\n    ? new Float32Array(newLength)\n    : undefined;\n  var textures = vertexFormat.st\n    ? new Float32Array((newLength / 3) * 2)\n    : undefined;\n  var topSt;\n  var topNormals;\n  if (vertexFormat.normal) {\n    topNormals = topBottomGeo.attributes.normal.values;\n    normals.set(topNormals);\n    for (i = 0; i < length; i++) {\n      topNormals[i] = -topNormals[i];\n    }\n    normals.set(topNormals, length);\n    topBottomGeo.attributes.normal.values = normals;\n  }\n  if (shadowVolume) {\n    topNormals = topBottomGeo.attributes.normal.values;\n    if (!vertexFormat.normal) {\n      topBottomGeo.attributes.normal = undefined;\n    }\n    var extrudeNormals = new Float32Array(newLength);\n    for (i = 0; i < length; i++) {\n      topNormals[i] = -topNormals[i];\n    }\n    extrudeNormals.set(topNormals, length); //only get normals for bottom layer that's going to be pushed down\n    topBottomGeo.attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals,\n    });\n  }\n\n  var offsetValue;\n  var hasOffsets = defined(offsetAttributeValue);\n  if (hasOffsets) {\n    var size = (length / 3) * 2;\n    var offsetAttribute = new Uint8Array(size);\n    if (offsetAttributeValue === GeometryOffsetAttribute.TOP) {\n      offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n    } else {\n      offsetValue =\n        offsetAttributeValue === GeometryOffsetAttribute.NONE ? 0 : 1;\n      offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n    }\n\n    topBottomGeo.attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    var topTangents = topBottomGeo.attributes.tangent.values;\n    tangents.set(topTangents);\n    for (i = 0; i < length; i++) {\n      topTangents[i] = -topTangents[i];\n    }\n    tangents.set(topTangents, length);\n    topBottomGeo.attributes.tangent.values = tangents;\n  }\n  if (vertexFormat.bitangent) {\n    var topBitangents = topBottomGeo.attributes.bitangent.values;\n    bitangents.set(topBitangents);\n    bitangents.set(topBitangents, length);\n    topBottomGeo.attributes.bitangent.values = bitangents;\n  }\n  if (vertexFormat.st) {\n    topSt = topBottomGeo.attributes.st.values;\n    textures.set(topSt);\n    textures.set(topSt, (length / 3) * 2);\n    topBottomGeo.attributes.st.values = textures;\n  }\n\n  var indices = topBottomGeo.indices;\n  var indicesLength = indices.length;\n  var posLength = length / 3;\n  var newIndices = IndexDatatype.createTypedArray(\n    newLength / 3,\n    indicesLength * 2\n  );\n  newIndices.set(indices);\n  for (i = 0; i < indicesLength; i += 3) {\n    newIndices[i + indicesLength] = indices[i + 2] + posLength;\n    newIndices[i + 1 + indicesLength] = indices[i + 1] + posLength;\n    newIndices[i + 2 + indicesLength] = indices[i] + posLength;\n  }\n  topBottomGeo.indices = newIndices;\n\n  var northCap = computedOptions.northCap;\n  var southCap = computedOptions.southCap;\n\n  var rowHeight = height;\n  var widthMultiplier = 2;\n  var perimeterPositions = 0;\n  var corners = 4;\n  var dupliateCorners = 4;\n  if (northCap) {\n    widthMultiplier -= 1;\n    rowHeight -= 1;\n    perimeterPositions += 1;\n    corners -= 2;\n    dupliateCorners -= 1;\n  }\n  if (southCap) {\n    widthMultiplier -= 1;\n    rowHeight -= 1;\n    perimeterPositions += 1;\n    corners -= 2;\n    dupliateCorners -= 1;\n  }\n  perimeterPositions += widthMultiplier * width + 2 * rowHeight - corners;\n\n  var wallCount = (perimeterPositions + dupliateCorners) * 2;\n\n  var wallPositions = new Float64Array(wallCount * 3);\n  var wallExtrudeNormals = shadowVolume\n    ? new Float32Array(wallCount * 3)\n    : undefined;\n  var wallOffsetAttribute = hasOffsets ? new Uint8Array(wallCount) : undefined;\n  var wallTextures = vertexFormat.st\n    ? new Float32Array(wallCount * 2)\n    : undefined;\n\n  var computeTopOffsets = offsetAttributeValue === GeometryOffsetAttribute.TOP;\n  if (hasOffsets && !computeTopOffsets) {\n    offsetValue = offsetAttributeValue === GeometryOffsetAttribute.ALL ? 1 : 0;\n    wallOffsetAttribute = arrayFill(wallOffsetAttribute, offsetValue);\n  }\n\n  var posIndex = 0;\n  var stIndex = 0;\n  var extrudeNormalIndex = 0;\n  var wallOffsetIndex = 0;\n  var area = width * rowHeight;\n  var threeI;\n  for (i = 0; i < area; i += width) {\n    threeI = i * 3;\n    wallPositions = addWallPositions(\n      wallPositions,\n      posIndex,\n      threeI,\n      topPositions,\n      bottomPositions\n    );\n    posIndex += 6;\n    if (vertexFormat.st) {\n      wallTextures = addWallTextureCoordinates(\n        wallTextures,\n        stIndex,\n        i * 2,\n        topSt\n      );\n      stIndex += 4;\n    }\n    if (shadowVolume) {\n      extrudeNormalIndex += 3;\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n    }\n    if (computeTopOffsets) {\n      wallOffsetAttribute[wallOffsetIndex++] = 1;\n      wallOffsetIndex += 1;\n    }\n  }\n\n  if (!southCap) {\n    for (i = area - width; i < area; i++) {\n      threeI = i * 3;\n      wallPositions = addWallPositions(\n        wallPositions,\n        posIndex,\n        threeI,\n        topPositions,\n        bottomPositions\n      );\n      posIndex += 6;\n      if (vertexFormat.st) {\n        wallTextures = addWallTextureCoordinates(\n          wallTextures,\n          stIndex,\n          i * 2,\n          topSt\n        );\n        stIndex += 4;\n      }\n      if (shadowVolume) {\n        extrudeNormalIndex += 3;\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n      }\n      if (computeTopOffsets) {\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\n        wallOffsetIndex += 1;\n      }\n    }\n  } else {\n    var southIndex = northCap ? area + 1 : area;\n    threeI = southIndex * 3;\n\n    for (i = 0; i < 2; i++) {\n      // duplicate corner points\n      wallPositions = addWallPositions(\n        wallPositions,\n        posIndex,\n        threeI,\n        topPositions,\n        bottomPositions\n      );\n      posIndex += 6;\n      if (vertexFormat.st) {\n        wallTextures = addWallTextureCoordinates(\n          wallTextures,\n          stIndex,\n          southIndex * 2,\n          topSt\n        );\n        stIndex += 4;\n      }\n      if (shadowVolume) {\n        extrudeNormalIndex += 3;\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n      }\n      if (computeTopOffsets) {\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\n        wallOffsetIndex += 1;\n      }\n    }\n  }\n\n  for (i = area - 1; i > 0; i -= width) {\n    threeI = i * 3;\n    wallPositions = addWallPositions(\n      wallPositions,\n      posIndex,\n      threeI,\n      topPositions,\n      bottomPositions\n    );\n    posIndex += 6;\n    if (vertexFormat.st) {\n      wallTextures = addWallTextureCoordinates(\n        wallTextures,\n        stIndex,\n        i * 2,\n        topSt\n      );\n      stIndex += 4;\n    }\n    if (shadowVolume) {\n      extrudeNormalIndex += 3;\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n    }\n    if (computeTopOffsets) {\n      wallOffsetAttribute[wallOffsetIndex++] = 1;\n      wallOffsetIndex += 1;\n    }\n  }\n\n  if (!northCap) {\n    for (i = width - 1; i >= 0; i--) {\n      threeI = i * 3;\n      wallPositions = addWallPositions(\n        wallPositions,\n        posIndex,\n        threeI,\n        topPositions,\n        bottomPositions\n      );\n      posIndex += 6;\n      if (vertexFormat.st) {\n        wallTextures = addWallTextureCoordinates(\n          wallTextures,\n          stIndex,\n          i * 2,\n          topSt\n        );\n        stIndex += 4;\n      }\n      if (shadowVolume) {\n        extrudeNormalIndex += 3;\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n      }\n      if (computeTopOffsets) {\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\n        wallOffsetIndex += 1;\n      }\n    }\n  } else {\n    var northIndex = area;\n    threeI = northIndex * 3;\n\n    for (i = 0; i < 2; i++) {\n      // duplicate corner points\n      wallPositions = addWallPositions(\n        wallPositions,\n        posIndex,\n        threeI,\n        topPositions,\n        bottomPositions\n      );\n      posIndex += 6;\n      if (vertexFormat.st) {\n        wallTextures = addWallTextureCoordinates(\n          wallTextures,\n          stIndex,\n          northIndex * 2,\n          topSt\n        );\n        stIndex += 4;\n      }\n      if (shadowVolume) {\n        extrudeNormalIndex += 3;\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n      }\n      if (computeTopOffsets) {\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\n        wallOffsetIndex += 1;\n      }\n    }\n  }\n\n  var geo = calculateAttributesWall(wallPositions, vertexFormat, ellipsoid);\n\n  if (vertexFormat.st) {\n    geo.attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: wallTextures,\n    });\n  }\n  if (shadowVolume) {\n    geo.attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: wallExtrudeNormals,\n    });\n  }\n  if (hasOffsets) {\n    geo.attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: wallOffsetAttribute,\n    });\n  }\n\n  var wallIndices = IndexDatatype.createTypedArray(\n    wallCount,\n    perimeterPositions * 6\n  );\n\n  var upperLeft;\n  var lowerLeft;\n  var lowerRight;\n  var upperRight;\n  length = wallPositions.length / 3;\n  var index = 0;\n  for (i = 0; i < length - 1; i += 2) {\n    upperLeft = i;\n    upperRight = (upperLeft + 2) % length;\n    var p1 = Cartesian3.fromArray(wallPositions, upperLeft * 3, v1Scratch);\n    var p2 = Cartesian3.fromArray(wallPositions, upperRight * 3, v2Scratch);\n    if (Cartesian3.equalsEpsilon(p1, p2, CesiumMath.EPSILON10)) {\n      continue;\n    }\n    lowerLeft = (upperLeft + 1) % length;\n    lowerRight = (lowerLeft + 2) % length;\n    wallIndices[index++] = upperLeft;\n    wallIndices[index++] = lowerLeft;\n    wallIndices[index++] = upperRight;\n    wallIndices[index++] = upperRight;\n    wallIndices[index++] = lowerLeft;\n    wallIndices[index++] = lowerRight;\n  }\n\n  geo.indices = wallIndices;\n\n  geo = GeometryPipeline.combineInstances([\n    new GeometryInstance({\n      geometry: topBottomGeo,\n    }),\n    new GeometryInstance({\n      geometry: geo,\n    }),\n  ]);\n\n  return geo[0];\n}\n\nvar scratchRectanglePoints = [\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n];\nvar nwScratch = new Cartographic();\nvar stNwScratch = new Cartographic();\nfunction computeRectangle(rectangle, granularity, rotation, ellipsoid, result) {\n  if (rotation === 0.0) {\n    return Rectangle.clone(rectangle, result);\n  }\n\n  var computedOptions = RectangleGeometryLibrary.computeOptions(\n    rectangle,\n    granularity,\n    rotation,\n    0,\n    rectangleScratch,\n    nwScratch\n  );\n\n  var height = computedOptions.height;\n  var width = computedOptions.width;\n\n  var positions = scratchRectanglePoints;\n  RectangleGeometryLibrary.computePosition(\n    computedOptions,\n    ellipsoid,\n    false,\n    0,\n    0,\n    positions[0]\n  );\n  RectangleGeometryLibrary.computePosition(\n    computedOptions,\n    ellipsoid,\n    false,\n    0,\n    width - 1,\n    positions[1]\n  );\n  RectangleGeometryLibrary.computePosition(\n    computedOptions,\n    ellipsoid,\n    false,\n    height - 1,\n    0,\n    positions[2]\n  );\n  RectangleGeometryLibrary.computePosition(\n    computedOptions,\n    ellipsoid,\n    false,\n    height - 1,\n    width - 1,\n    positions[3]\n  );\n\n  return Rectangle.fromCartesianArray(positions, ellipsoid, result);\n}\n\n/**\n * A description of a cartographic rectangle on an ellipsoid centered at the origin. Rectangle geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias RectangleGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Number} [options.height=0.0] The distance in meters between the rectangle and the ellipsoid surface.\n * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\n * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n * @param {Number} [options.extrudedHeight] The distance in meters between the rectangle's extruded face and the ellipsoid surface.\n *\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>options.rectangle.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>options.rectangle.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>options.rectangle.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be greater than <code>options.rectangle.south</code>.\n *\n * @see RectangleGeometry#createGeometry\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Rectangle.html|Cesium Sandcastle Rectangle Demo}\n *\n * @example\n * // 1. create a rectangle\n * var rectangle = new Cesium.RectangleGeometry({\n *   ellipsoid : Cesium.Ellipsoid.WGS84,\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n *   height : 10000.0\n * });\n * var geometry = Cesium.RectangleGeometry.createGeometry(rectangle);\n *\n * // 2. create an extruded rectangle without a top\n * var rectangle = new Cesium.RectangleGeometry({\n *   ellipsoid : Cesium.Ellipsoid.WGS84,\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n *   height : 10000.0,\n *   extrudedHeight: 300000\n * });\n * var geometry = Cesium.RectangleGeometry.createGeometry(rectangle);\n */\nfunction RectangleGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var rectangle = options.rectangle;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Rectangle.validate(rectangle);\n  if (rectangle.north < rectangle.south) {\n    throw new DeveloperError(\n      \"options.rectangle.north must be greater than or equal to options.rectangle.south\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var height = defaultValue(options.height, 0.0);\n  var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  this._rectangle = Rectangle.clone(rectangle);\n  this._granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  this._ellipsoid = Ellipsoid.clone(\n    defaultValue(options.ellipsoid, Ellipsoid.WGS84)\n  );\n  this._surfaceHeight = Math.max(height, extrudedHeight);\n  this._rotation = defaultValue(options.rotation, 0.0);\n  this._stRotation = defaultValue(options.stRotation, 0.0);\n  this._vertexFormat = VertexFormat.clone(\n    defaultValue(options.vertexFormat, VertexFormat.DEFAULT)\n  );\n  this._extrudedHeight = Math.min(height, extrudedHeight);\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\n  this._workerName = \"createRectangleGeometry\";\n  this._offsetAttribute = options.offsetAttribute;\n  this._rotatedRectangle = undefined;\n\n  this._textureCoordinateRotationPoints = undefined;\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nRectangleGeometry.packedLength =\n  Rectangle.packedLength +\n  Ellipsoid.packedLength +\n  VertexFormat.packedLength +\n  7;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {RectangleGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nRectangleGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Rectangle.pack(value._rectangle, array, startingIndex);\n  startingIndex += Rectangle.packedLength;\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._surfaceHeight;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._stRotation;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nvar scratchRectangle = new Rectangle();\nvar scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nvar scratchOptions = {\n  rectangle: scratchRectangle,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  granularity: undefined,\n  height: undefined,\n  rotation: undefined,\n  stRotation: undefined,\n  extrudedHeight: undefined,\n  shadowVolume: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {RectangleGeometry} [result] The object into which to store the result.\n * @returns {RectangleGeometry} The modified result parameter or a new RectangleGeometry instance if one was not provided.\n */\nRectangleGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var rectangle = Rectangle.unpack(array, startingIndex, scratchRectangle);\n  startingIndex += Rectangle.packedLength;\n\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  var vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  var granularity = array[startingIndex++];\n  var surfaceHeight = array[startingIndex++];\n  var rotation = array[startingIndex++];\n  var stRotation = array[startingIndex++];\n  var extrudedHeight = array[startingIndex++];\n  var shadowVolume = array[startingIndex++] === 1.0;\n  var offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.granularity = granularity;\n    scratchOptions.height = surfaceHeight;\n    scratchOptions.rotation = rotation;\n    scratchOptions.stRotation = stRotation;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.shadowVolume = shadowVolume;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n\n    return new RectangleGeometry(scratchOptions);\n  }\n\n  result._rectangle = Rectangle.clone(rectangle, result._rectangle);\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._granularity = granularity;\n  result._surfaceHeight = surfaceHeight;\n  result._rotation = rotation;\n  result._stRotation = stRotation;\n  result._extrudedHeight = extrudedHeight;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the bounding rectangle based on the provided options\n *\n * @param {Object} options Object with the following properties:\n * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\n * @param {Rectangle} [result] An object in which to store the result.\n *\n * @returns {Rectangle} The result rectangle\n */\nRectangleGeometry.computeRectangle = function (options, result) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var rectangle = options.rectangle;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Rectangle.validate(rectangle);\n  if (rectangle.north < rectangle.south) {\n    throw new DeveloperError(\n      \"options.rectangle.north must be greater than or equal to options.rectangle.south\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var rotation = defaultValue(options.rotation, 0.0);\n\n  return computeRectangle(rectangle, granularity, rotation, ellipsoid, result);\n};\n\nvar tangentRotationMatrixScratch = new Matrix3();\nvar quaternionScratch = new Quaternion();\nvar centerScratch = new Cartographic();\n/**\n * Computes the geometric representation of a rectangle, including its vertices, indices, and a bounding sphere.\n *\n * @param {RectangleGeometry} rectangleGeometry A description of the rectangle.\n * @returns {Geometry|undefined} The computed vertices and indices.\n *\n * @exception {DeveloperError} Rotated rectangle is invalid.\n */\nRectangleGeometry.createGeometry = function (rectangleGeometry) {\n  if (\n    CesiumMath.equalsEpsilon(\n      rectangleGeometry._rectangle.north,\n      rectangleGeometry._rectangle.south,\n      CesiumMath.EPSILON10\n    ) ||\n    CesiumMath.equalsEpsilon(\n      rectangleGeometry._rectangle.east,\n      rectangleGeometry._rectangle.west,\n      CesiumMath.EPSILON10\n    )\n  ) {\n    return undefined;\n  }\n\n  var rectangle = rectangleGeometry._rectangle;\n  var ellipsoid = rectangleGeometry._ellipsoid;\n  var rotation = rectangleGeometry._rotation;\n  var stRotation = rectangleGeometry._stRotation;\n  var vertexFormat = rectangleGeometry._vertexFormat;\n\n  var computedOptions = RectangleGeometryLibrary.computeOptions(\n    rectangle,\n    rectangleGeometry._granularity,\n    rotation,\n    stRotation,\n    rectangleScratch,\n    nwScratch,\n    stNwScratch\n  );\n\n  var tangentRotationMatrix = tangentRotationMatrixScratch;\n  if (stRotation !== 0 || rotation !== 0) {\n    var center = Rectangle.center(rectangle, centerScratch);\n    var axis = ellipsoid.geodeticSurfaceNormalCartographic(center, v1Scratch);\n    Quaternion.fromAxisAngle(axis, -stRotation, quaternionScratch);\n    Matrix3.fromQuaternion(quaternionScratch, tangentRotationMatrix);\n  } else {\n    Matrix3.clone(Matrix3.IDENTITY, tangentRotationMatrix);\n  }\n\n  var surfaceHeight = rectangleGeometry._surfaceHeight;\n  var extrudedHeight = rectangleGeometry._extrudedHeight;\n  var extrude = !CesiumMath.equalsEpsilon(\n    surfaceHeight,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2\n  );\n\n  computedOptions.lonScalar = 1.0 / rectangleGeometry._rectangle.width;\n  computedOptions.latScalar = 1.0 / rectangleGeometry._rectangle.height;\n  computedOptions.tangentRotationMatrix = tangentRotationMatrix;\n\n  var geometry;\n  var boundingSphere;\n  rectangle = rectangleGeometry._rectangle;\n  if (extrude) {\n    geometry = constructExtrudedRectangle(rectangleGeometry, computedOptions);\n    var topBS = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      surfaceHeight,\n      topBoundingSphere\n    );\n    var bottomBS = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      extrudedHeight,\n      bottomBoundingSphere\n    );\n    boundingSphere = BoundingSphere.union(topBS, bottomBS);\n  } else {\n    geometry = constructRectangle(rectangleGeometry, computedOptions);\n    geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n      geometry.attributes.position.values,\n      surfaceHeight,\n      ellipsoid,\n      false\n    );\n\n    if (defined(rectangleGeometry._offsetAttribute)) {\n      var length = geometry.attributes.position.values.length;\n      var applyOffset = new Uint8Array(length / 3);\n      var offsetValue =\n        rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      arrayFill(applyOffset, offsetValue);\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n\n    boundingSphere = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      surfaceHeight\n    );\n  }\n\n  if (!vertexFormat.position) {\n    delete geometry.attributes.position;\n  }\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: boundingSphere,\n    offsetAttribute: rectangleGeometry._offsetAttribute,\n  });\n};\n\n/**\n * @private\n */\nRectangleGeometry.createShadowVolume = function (\n  rectangleGeometry,\n  minHeightFunc,\n  maxHeightFunc\n) {\n  var granularity = rectangleGeometry._granularity;\n  var ellipsoid = rectangleGeometry._ellipsoid;\n\n  var minHeight = minHeightFunc(granularity, ellipsoid);\n  var maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n  return new RectangleGeometry({\n    rectangle: rectangleGeometry._rectangle,\n    rotation: rectangleGeometry._rotation,\n    ellipsoid: ellipsoid,\n    stRotation: rectangleGeometry._stRotation,\n    granularity: granularity,\n    extrudedHeight: maxHeight,\n    height: minHeight,\n    vertexFormat: VertexFormat.POSITION_ONLY,\n    shadowVolume: true,\n  });\n};\n\nvar unrotatedTextureRectangleScratch = new Rectangle();\nvar points2DScratch = [new Cartesian2(), new Cartesian2(), new Cartesian2()];\nvar rotation2DScratch = new Matrix2();\nvar rectangleCenterScratch = new Cartographic();\n\nfunction textureCoordinateRotationPoints(rectangleGeometry) {\n  if (rectangleGeometry._stRotation === 0.0) {\n    return [0, 0, 0, 1, 1, 0];\n  }\n\n  var rectangle = Rectangle.clone(\n    rectangleGeometry._rectangle,\n    unrotatedTextureRectangleScratch\n  );\n  var granularity = rectangleGeometry._granularity;\n  var ellipsoid = rectangleGeometry._ellipsoid;\n\n  // Rotate to align the texture coordinates with ENU\n  var rotation = rectangleGeometry._rotation - rectangleGeometry._stRotation;\n\n  var unrotatedTextureRectangle = computeRectangle(\n    rectangle,\n    granularity,\n    rotation,\n    ellipsoid,\n    unrotatedTextureRectangleScratch\n  );\n\n  // Assume a computed \"east-north\" texture coordinate system based on spherical or planar tricks, bounded by `boundingRectangle`.\n  // The \"desired\" texture coordinate system forms an oriented rectangle (un-oriented computed) around the geometry that completely and tightly bounds it.\n  // We want to map from the \"east-north\" texture coordinate system into the \"desired\" system using a pair of lines (analagous planes in 2D)\n  // Compute 3 corners of the \"desired\" texture coordinate system in \"east-north\" texture space by the following in cartographic space:\n  // - rotate 3 of the corners in unrotatedTextureRectangle by stRotation around the center of the bounding rectangle\n  // - apply the \"east-north\" system's normalization formula to the rotated cartographics, even though this is likely to produce values outside [0-1].\n  // This gives us a set of points in the \"east-north\" texture coordinate system that can be used to map \"east-north\" texture coordinates to \"desired.\"\n\n  var points2D = points2DScratch;\n  points2D[0].x = unrotatedTextureRectangle.west;\n  points2D[0].y = unrotatedTextureRectangle.south;\n\n  points2D[1].x = unrotatedTextureRectangle.west;\n  points2D[1].y = unrotatedTextureRectangle.north;\n\n  points2D[2].x = unrotatedTextureRectangle.east;\n  points2D[2].y = unrotatedTextureRectangle.south;\n\n  var boundingRectangle = rectangleGeometry.rectangle;\n  var toDesiredInComputed = Matrix2.fromRotation(\n    rectangleGeometry._stRotation,\n    rotation2DScratch\n  );\n  var boundingRectangleCenter = Rectangle.center(\n    boundingRectangle,\n    rectangleCenterScratch\n  );\n\n  for (var i = 0; i < 3; ++i) {\n    var point2D = points2D[i];\n    point2D.x -= boundingRectangleCenter.longitude;\n    point2D.y -= boundingRectangleCenter.latitude;\n    Matrix2.multiplyByVector(toDesiredInComputed, point2D, point2D);\n    point2D.x += boundingRectangleCenter.longitude;\n    point2D.y += boundingRectangleCenter.latitude;\n\n    // Convert point into east-north texture coordinate space\n    point2D.x = (point2D.x - boundingRectangle.west) / boundingRectangle.width;\n    point2D.y =\n      (point2D.y - boundingRectangle.south) / boundingRectangle.height;\n  }\n\n  var minXYCorner = points2D[0];\n  var maxYCorner = points2D[1];\n  var maxXCorner = points2D[2];\n  var result = new Array(6);\n  Cartesian2.pack(minXYCorner, result);\n  Cartesian2.pack(maxYCorner, result, 2);\n  Cartesian2.pack(maxXCorner, result, 4);\n  return result;\n}\n\nObject.defineProperties(RectangleGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function () {\n      if (!defined(this._rotatedRectangle)) {\n        this._rotatedRectangle = computeRectangle(\n          this._rectangle,\n          this._granularity,\n          this._rotation,\n          this._ellipsoid\n        );\n      }\n      return this._rotatedRectangle;\n    },\n  },\n  /**\n   * For remapping texture coordinates when rendering RectangleGeometries as GroundPrimitives.\n   * This version permits skew in textures by computing offsets directly in cartographic space and\n   * more accurately approximates rendering RectangleGeometries with height as standard Primitives.\n   * @see Geometry#_textureCoordinateRotationPoints\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function () {\n      if (!defined(this._textureCoordinateRotationPoints)) {\n        this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(\n          this\n        );\n      }\n      return this._textureCoordinateRotationPoints;\n    },\n  },\n});\nexport default RectangleGeometry;\n","import defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport RectangleGeometry from \"../Core/RectangleGeometry.js\";\n\nfunction createRectangleGeometry(rectangleGeometry, offset) {\n  if (defined(offset)) {\n    rectangleGeometry = RectangleGeometry.unpack(rectangleGeometry, offset);\n  }\n  rectangleGeometry._ellipsoid = Ellipsoid.clone(rectangleGeometry._ellipsoid);\n  rectangleGeometry._rectangle = Rectangle.clone(rectangleGeometry._rectangle);\n  return RectangleGeometry.createGeometry(rectangleGeometry);\n}\nexport default createRectangleGeometry;\n"],"names":["positionScratch","Cartesian3","normalScratch","tangentScratch","bitangentScratch","rectangleScratch","Rectangle","stScratch","Cartesian2","bottomBoundingSphere","BoundingSphere","topBoundingSphere","createAttributes","vertexFormat","attributes","geo","Geometry","GeometryAttributes","primitiveType","PrimitiveType","TRIANGLES","position","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","positions","normal","FLOAT","normals","tangent","tangents","bitangent","bitangents","v1Scratch","v2Scratch","constructRectangle","rectangleGeometry","computedOptions","_vertexFormat","ellipsoid","_ellipsoid","height","width","northCap","southCap","rowStart","rowEnd","rowHeight","size","Float64Array","undefined","textureCoordinates","st","Float32Array","posIndex","stIndex","minX","Number","MAX_VALUE","minY","maxX","maxY","row","col","RectangleGeometryLibrary","computePosition","x","y","z","Math","min","max","k","length","tangentRotationMatrix","attrIndex","i","p","fromArray","attrIndex1","attrIndex2","geodeticSurfaceNormal","cross","UNIT_Z","Matrix3","multiplyByVector","normalize","calculateAttributes","indicesSize","indices","IndexDatatype","createTypedArray","index","indicesIndex","j","lowerLeft","lowerRight","upperRight","p1","p2","northIndex","southIndex","addWallPositions","wallPositions","topPositions","bottomPositions","addWallTextureCoordinates","wallTextures","scratchVertexFormat","VertexFormat","constructExtrudedRectangle","shadowVolume","_shadowVolume","offsetAttributeValue","_offsetAttribute","minHeight","_extrudedHeight","maxHeight","_surfaceHeight","newVertexFormat","clone","topBottomGeo","PolygonPipeline","scaleToGeodeticHeight","newLength","set","topSt","topNormals","offsetValue","textures","extrudeNormals","extrudeDirection","hasOffsets","defined","offsetAttribute","Uint8Array","GeometryOffsetAttribute","TOP","arrayFill","NONE","applyOffset","UNSIGNED_BYTE","topTangents","topBitangents","indicesLength","posLength","newIndices","widthMultiplier","perimeterPositions","corners","dupliateCorners","wallCount","wallExtrudeNormals","wallOffsetAttribute","computeTopOffsets","ALL","extrudeNormalIndex","wallOffsetIndex","area","threeI","normalIndex","tangentIndex","bitangentIndex","recomputeNormal","subtract","equalsEpsilon","CesiumMath","EPSILON10","calculateAttributesWall","wallIndices","upperLeft","GeometryPipeline","combineInstances","GeometryInstance","geometry","scratchRectanglePoints","nwScratch","Cartographic","stNwScratch","computeRectangle","rectangle","granularity","rotation","result","computeOptions","fromCartesianArray","RectangleGeometry","options","defaultValue","EMPTY_OBJECT","Check","typeOf","object","validate","north","south","DeveloperError","extrudedHeight","this","_rectangle","_granularity","RADIANS_PER_DEGREE","Ellipsoid","WGS84","_rotation","_stRotation","stRotation","DEFAULT","_workerName","_rotatedRectangle","_textureCoordinateRotationPoints","packedLength","pack","value","array","startingIndex","scratchRectangle","scratchEllipsoid","UNIT_SPHERE","scratchOptions","unpack","surfaceHeight","tangentRotationMatrixScratch","quaternionScratch","Quaternion","centerScratch","createGeometry","east","west","center","axis","geodeticSurfaceNormalCartographic","fromAxisAngle","fromQuaternion","IDENTITY","extrude","EPSILON2","lonScalar","latScalar","boundingSphere","topBS","fromRectangle3D","bottomBS","union","createShadowVolume","minHeightFunc","maxHeightFunc","POSITION_ONLY","unrotatedTextureRectangleScratch","points2DScratch","rotation2DScratch","Matrix2","rectangleCenterScratch","Object","defineProperties","prototype","get","textureCoordinateRotationPoints","unrotatedTextureRectangle","points2D","boundingRectangle","toDesiredInComputed","fromRotation","boundingRectangleCenter","point2D","longitude","latitude","minXYCorner","maxYCorner","maxXCorner","Array","offset"],"mappings":"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"}