{"version":3,"file":"decodeDraco.js","sources":["../../../../Source/WorkersES6/decodeDraco.js"],"sourcesContent":["/* global require */\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport createTaskProcessorWorker from \"./createTaskProcessorWorker.js\";\n\nvar draco;\n\nfunction decodeIndexArray(dracoGeometry, dracoDecoder) {\n  var numPoints = dracoGeometry.num_points();\n  var numFaces = dracoGeometry.num_faces();\n  var faceIndices = new draco.DracoInt32Array();\n  var numIndices = numFaces * 3;\n  var indexArray = IndexDatatype.createTypedArray(numPoints, numIndices);\n\n  var offset = 0;\n  for (var i = 0; i < numFaces; ++i) {\n    dracoDecoder.GetFaceFromMesh(dracoGeometry, i, faceIndices);\n\n    indexArray[offset + 0] = faceIndices.GetValue(0);\n    indexArray[offset + 1] = faceIndices.GetValue(1);\n    indexArray[offset + 2] = faceIndices.GetValue(2);\n    offset += 3;\n  }\n\n  draco.destroy(faceIndices);\n\n  return {\n    typedArray: indexArray,\n    numberOfIndices: numIndices,\n  };\n}\n\nfunction decodeQuantizedDracoTypedArray(\n  dracoGeometry,\n  dracoDecoder,\n  dracoAttribute,\n  quantization,\n  vertexArrayLength\n) {\n  var vertexArray;\n  var attributeData;\n  if (quantization.quantizationBits <= 8) {\n    attributeData = new draco.DracoUInt8Array();\n    vertexArray = new Uint8Array(vertexArrayLength);\n    dracoDecoder.GetAttributeUInt8ForAllPoints(\n      dracoGeometry,\n      dracoAttribute,\n      attributeData\n    );\n  } else {\n    attributeData = new draco.DracoUInt16Array();\n    vertexArray = new Uint16Array(vertexArrayLength);\n    dracoDecoder.GetAttributeUInt16ForAllPoints(\n      dracoGeometry,\n      dracoAttribute,\n      attributeData\n    );\n  }\n\n  for (var i = 0; i < vertexArrayLength; ++i) {\n    vertexArray[i] = attributeData.GetValue(i);\n  }\n\n  draco.destroy(attributeData);\n  return vertexArray;\n}\n\nfunction decodeDracoTypedArray(\n  dracoGeometry,\n  dracoDecoder,\n  dracoAttribute,\n  vertexArrayLength\n) {\n  var vertexArray;\n  var attributeData;\n\n  // Some attribute types are casted down to 32 bit since Draco only returns 32 bit values\n  switch (dracoAttribute.data_type()) {\n    case 1:\n    case 11: // DT_INT8 or DT_BOOL\n      attributeData = new draco.DracoInt8Array();\n      vertexArray = new Int8Array(vertexArrayLength);\n      dracoDecoder.GetAttributeInt8ForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        attributeData\n      );\n      break;\n    case 2: // DT_UINT8\n      attributeData = new draco.DracoUInt8Array();\n      vertexArray = new Uint8Array(vertexArrayLength);\n      dracoDecoder.GetAttributeUInt8ForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        attributeData\n      );\n      break;\n    case 3: // DT_INT16\n      attributeData = new draco.DracoInt16Array();\n      vertexArray = new Int16Array(vertexArrayLength);\n      dracoDecoder.GetAttributeInt16ForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        attributeData\n      );\n      break;\n    case 4: // DT_UINT16\n      attributeData = new draco.DracoUInt16Array();\n      vertexArray = new Uint16Array(vertexArrayLength);\n      dracoDecoder.GetAttributeUInt16ForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        attributeData\n      );\n      break;\n    case 5:\n    case 7: // DT_INT32 or DT_INT64\n      attributeData = new draco.DracoInt32Array();\n      vertexArray = new Int32Array(vertexArrayLength);\n      dracoDecoder.GetAttributeInt32ForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        attributeData\n      );\n      break;\n    case 6:\n    case 8: // DT_UINT32 or DT_UINT64\n      attributeData = new draco.DracoUInt32Array();\n      vertexArray = new Uint32Array(vertexArrayLength);\n      dracoDecoder.GetAttributeUInt32ForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        attributeData\n      );\n      break;\n    case 9:\n    case 10: // DT_FLOAT32 or DT_FLOAT64\n      attributeData = new draco.DracoFloat32Array();\n      vertexArray = new Float32Array(vertexArrayLength);\n      dracoDecoder.GetAttributeFloatForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        attributeData\n      );\n      break;\n  }\n\n  for (var i = 0; i < vertexArrayLength; ++i) {\n    vertexArray[i] = attributeData.GetValue(i);\n  }\n\n  draco.destroy(attributeData);\n  return vertexArray;\n}\n\nfunction decodeAttribute(dracoGeometry, dracoDecoder, dracoAttribute) {\n  var numPoints = dracoGeometry.num_points();\n  var numComponents = dracoAttribute.num_components();\n\n  var quantization;\n  var transform = new draco.AttributeQuantizationTransform();\n  if (transform.InitFromAttribute(dracoAttribute)) {\n    var minValues = new Array(numComponents);\n    for (var i = 0; i < numComponents; ++i) {\n      minValues[i] = transform.min_value(i);\n    }\n    quantization = {\n      quantizationBits: transform.quantization_bits(),\n      minValues: minValues,\n      range: transform.range(),\n      octEncoded: false,\n    };\n  }\n  draco.destroy(transform);\n\n  transform = new draco.AttributeOctahedronTransform();\n  if (transform.InitFromAttribute(dracoAttribute)) {\n    quantization = {\n      quantizationBits: transform.quantization_bits(),\n      octEncoded: true,\n    };\n  }\n  draco.destroy(transform);\n\n  var vertexArrayLength = numPoints * numComponents;\n  var vertexArray;\n  if (defined(quantization)) {\n    vertexArray = decodeQuantizedDracoTypedArray(\n      dracoGeometry,\n      dracoDecoder,\n      dracoAttribute,\n      quantization,\n      vertexArrayLength\n    );\n  } else {\n    vertexArray = decodeDracoTypedArray(\n      dracoGeometry,\n      dracoDecoder,\n      dracoAttribute,\n      vertexArrayLength\n    );\n  }\n\n  var componentDatatype = ComponentDatatype.fromTypedArray(vertexArray);\n\n  return {\n    array: vertexArray,\n    data: {\n      componentsPerAttribute: numComponents,\n      componentDatatype: componentDatatype,\n      byteOffset: dracoAttribute.byte_offset(),\n      byteStride:\n        ComponentDatatype.getSizeInBytes(componentDatatype) * numComponents,\n      normalized: dracoAttribute.normalized(),\n      quantization: quantization,\n    },\n  };\n}\n\nfunction decodePointCloud(parameters) {\n  var dracoDecoder = new draco.Decoder();\n\n  if (parameters.dequantizeInShader) {\n    dracoDecoder.SkipAttributeTransform(draco.POSITION);\n    dracoDecoder.SkipAttributeTransform(draco.NORMAL);\n  }\n\n  var buffer = new draco.DecoderBuffer();\n  buffer.Init(parameters.buffer, parameters.buffer.length);\n\n  var geometryType = dracoDecoder.GetEncodedGeometryType(buffer);\n  if (geometryType !== draco.POINT_CLOUD) {\n    throw new RuntimeError(\"Draco geometry type must be POINT_CLOUD.\");\n  }\n\n  var dracoPointCloud = new draco.PointCloud();\n  var decodingStatus = dracoDecoder.DecodeBufferToPointCloud(\n    buffer,\n    dracoPointCloud\n  );\n  if (!decodingStatus.ok() || dracoPointCloud.ptr === 0) {\n    throw new RuntimeError(\n      \"Error decoding draco point cloud: \" + decodingStatus.error_msg()\n    );\n  }\n\n  draco.destroy(buffer);\n\n  var result = {};\n\n  var properties = parameters.properties;\n  for (var propertyName in properties) {\n    if (properties.hasOwnProperty(propertyName)) {\n      var attributeId = properties[propertyName];\n      var dracoAttribute = dracoDecoder.GetAttributeByUniqueId(\n        dracoPointCloud,\n        attributeId\n      );\n      result[propertyName] = decodeAttribute(\n        dracoPointCloud,\n        dracoDecoder,\n        dracoAttribute\n      );\n    }\n  }\n\n  draco.destroy(dracoPointCloud);\n  draco.destroy(dracoDecoder);\n\n  return result;\n}\n\nfunction decodePrimitive(parameters) {\n  var dracoDecoder = new draco.Decoder();\n\n  // Skip all parameter types except generic\n  var attributesToSkip = [\"POSITION\", \"NORMAL\", \"COLOR\", \"TEX_COORD\"];\n  if (parameters.dequantizeInShader) {\n    for (var i = 0; i < attributesToSkip.length; ++i) {\n      dracoDecoder.SkipAttributeTransform(draco[attributesToSkip[i]]);\n    }\n  }\n\n  var bufferView = parameters.bufferView;\n  var buffer = new draco.DecoderBuffer();\n  buffer.Init(parameters.array, bufferView.byteLength);\n\n  var geometryType = dracoDecoder.GetEncodedGeometryType(buffer);\n  if (geometryType !== draco.TRIANGULAR_MESH) {\n    throw new RuntimeError(\"Unsupported draco mesh geometry type.\");\n  }\n\n  var dracoGeometry = new draco.Mesh();\n  var decodingStatus = dracoDecoder.DecodeBufferToMesh(buffer, dracoGeometry);\n  if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n    throw new RuntimeError(\n      \"Error decoding draco mesh geometry: \" + decodingStatus.error_msg()\n    );\n  }\n\n  draco.destroy(buffer);\n\n  var attributeData = {};\n\n  var compressedAttributes = parameters.compressedAttributes;\n  for (var attributeName in compressedAttributes) {\n    if (compressedAttributes.hasOwnProperty(attributeName)) {\n      var compressedAttribute = compressedAttributes[attributeName];\n      var dracoAttribute = dracoDecoder.GetAttributeByUniqueId(\n        dracoGeometry,\n        compressedAttribute\n      );\n      attributeData[attributeName] = decodeAttribute(\n        dracoGeometry,\n        dracoDecoder,\n        dracoAttribute\n      );\n    }\n  }\n\n  var result = {\n    indexArray: decodeIndexArray(dracoGeometry, dracoDecoder),\n    attributeData: attributeData,\n  };\n\n  draco.destroy(dracoGeometry);\n  draco.destroy(dracoDecoder);\n\n  return result;\n}\n\nfunction decode(parameters) {\n  if (defined(parameters.primitive)) {\n    return decodePrimitive(parameters);\n  }\n  return decodePointCloud(parameters);\n}\n\nfunction initWorker(dracoModule) {\n  draco = dracoModule;\n  self.onmessage = createTaskProcessorWorker(decode);\n  self.postMessage(true);\n}\n\nfunction decodeDraco(event) {\n  var data = event.data;\n\n  // Expect the first message to be to load a web assembly module\n  var wasmConfig = data.webAssemblyConfig;\n  if (defined(wasmConfig)) {\n    // Require and compile WebAssembly module, or use fallback if not supported\n    return require([wasmConfig.modulePath], function (dracoModule) {\n      if (defined(wasmConfig.wasmBinaryFile)) {\n        if (!defined(dracoModule)) {\n          dracoModule = self.DracoDecoderModule;\n        }\n\n        dracoModule(wasmConfig).then(function (compiledModule) {\n          initWorker(compiledModule);\n        });\n      } else {\n        initWorker(dracoModule());\n      }\n    });\n  }\n}\nexport default decodeDraco;\n"],"names":["draco","decodeAttribute","dracoGeometry","dracoDecoder","dracoAttribute","quantization","numPoints","num_points","numComponents","num_components","transform","AttributeQuantizationTransform","InitFromAttribute","minValues","Array","i","min_value","quantizationBits","quantization_bits","range","octEncoded","destroy","AttributeOctahedronTransform","vertexArrayLength","vertexArray","defined","attributeData","DracoUInt8Array","Uint8Array","GetAttributeUInt8ForAllPoints","DracoUInt16Array","Uint16Array","GetAttributeUInt16ForAllPoints","GetValue","decodeQuantizedDracoTypedArray","data_type","DracoInt8Array","Int8Array","GetAttributeInt8ForAllPoints","DracoInt16Array","Int16Array","GetAttributeInt16ForAllPoints","DracoInt32Array","Int32Array","GetAttributeInt32ForAllPoints","DracoUInt32Array","Uint32Array","GetAttributeUInt32ForAllPoints","DracoFloat32Array","Float32Array","GetAttributeFloatForAllPoints","decodeDracoTypedArray","componentDatatype","ComponentDatatype","fromTypedArray","array","data","componentsPerAttribute","byteOffset","byte_offset","byteStride","getSizeInBytes","normalized","decodePrimitive","parameters","Decoder","attributesToSkip","dequantizeInShader","length","SkipAttributeTransform","bufferView","buffer","DecoderBuffer","Init","byteLength","GetEncodedGeometryType","TRIANGULAR_MESH","RuntimeError","Mesh","decodingStatus","DecodeBufferToMesh","ok","ptr","error_msg","attributeName","compressedAttributes","hasOwnProperty","compressedAttribute","GetAttributeByUniqueId","result","indexArray","numFaces","num_faces","faceIndices","numIndices","IndexDatatype","createTypedArray","offset","GetFaceFromMesh","typedArray","numberOfIndices","decodeIndexArray","decode","primitive","POSITION","NORMAL","POINT_CLOUD","dracoPointCloud","PointCloud","DecodeBufferToPointCloud","propertyName","properties","attributeId","initWorker","dracoModule","self","onmessage","createTaskProcessorWorker","postMessage","event","wasmConfig","webAssemblyConfig","require","modulePath","wasmBinaryFile","DracoDecoderModule","then","compiledModule"],"mappings":"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"}