{"version":3,"file":"createPolylineGeometry.js","sources":["../../../../Source/Core/PolylineGeometry.js","../../../../Source/WorkersES6/createPolylineGeometry.js"],"sourcesContent":["import ArcType from \"./ArcType.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Color from \"./Color.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryType from \"./GeometryType.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nvar scratchInterpolateColorsArray = [];\n\nfunction interpolateColors(p0, p1, color0, color1, numPoints) {\n  var colors = scratchInterpolateColorsArray;\n  colors.length = numPoints;\n  var i;\n\n  var r0 = color0.red;\n  var g0 = color0.green;\n  var b0 = color0.blue;\n  var a0 = color0.alpha;\n\n  var r1 = color1.red;\n  var g1 = color1.green;\n  var b1 = color1.blue;\n  var a1 = color1.alpha;\n\n  if (Color.equals(color0, color1)) {\n    for (i = 0; i < numPoints; i++) {\n      colors[i] = Color.clone(color0);\n    }\n    return colors;\n  }\n\n  var redPerVertex = (r1 - r0) / numPoints;\n  var greenPerVertex = (g1 - g0) / numPoints;\n  var bluePerVertex = (b1 - b0) / numPoints;\n  var alphaPerVertex = (a1 - a0) / numPoints;\n\n  for (i = 0; i < numPoints; i++) {\n    colors[i] = new Color(\n      r0 + i * redPerVertex,\n      g0 + i * greenPerVertex,\n      b0 + i * bluePerVertex,\n      a0 + i * alphaPerVertex\n    );\n  }\n\n  return colors;\n}\n\n/**\n * A description of a polyline modeled as a line strip; the first two positions define a line segment,\n * and each additional position defines a line segment from the previous position. The polyline is capable of\n * displaying with a material.\n *\n * @alias PolylineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the positions in the polyline as a line strip.\n * @param {Number} [options.width=1.0] The width in pixels.\n * @param {Color[]} [options.colors] An Array of {@link Color} defining the per vertex or per segment colors.\n * @param {Boolean} [options.colorsPerVertex=false] A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude if options.arcType is not ArcType.NONE. Determines the number of positions in the buffer.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n *\n * @exception {DeveloperError} At least two positions are required.\n * @exception {DeveloperError} width must be greater than or equal to one.\n * @exception {DeveloperError} colors has an invalid length.\n *\n * @see PolylineGeometry#createGeometry\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Polyline.html|Cesium Sandcastle Polyline Demo}\n *\n * @example\n * // A polyline with two connected line segments\n * var polyline = new Cesium.PolylineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     0.0, 0.0,\n *     5.0, 0.0,\n *     5.0, 5.0\n *   ]),\n *   width : 10.0\n * });\n * var geometry = Cesium.PolylineGeometry.createGeometry(polyline);\n */\nfunction PolylineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var positions = options.positions;\n  var colors = options.colors;\n  var width = defaultValue(options.width, 1.0);\n  var colorsPerVertex = defaultValue(options.colorsPerVertex, false);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions) || positions.length < 2) {\n    throw new DeveloperError(\"At least two positions are required.\");\n  }\n  if (typeof width !== \"number\") {\n    throw new DeveloperError(\"width must be a number\");\n  }\n  if (\n    defined(colors) &&\n    ((colorsPerVertex && colors.length < positions.length) ||\n      (!colorsPerVertex && colors.length < positions.length - 1))\n  ) {\n    throw new DeveloperError(\"colors has an invalid length.\");\n  }\n  //>>includeEnd('debug');\n\n  this._positions = positions;\n  this._colors = colors;\n  this._width = width;\n  this._colorsPerVertex = colorsPerVertex;\n  this._vertexFormat = VertexFormat.clone(\n    defaultValue(options.vertexFormat, VertexFormat.DEFAULT)\n  );\n\n  this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n  this._granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  this._ellipsoid = Ellipsoid.clone(\n    defaultValue(options.ellipsoid, Ellipsoid.WGS84)\n  );\n  this._workerName = \"createPolylineGeometry\";\n\n  var numComponents = 1 + positions.length * Cartesian3.packedLength;\n  numComponents += defined(colors) ? 1 + colors.length * Color.packedLength : 1;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  this.packedLength =\n    numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 4;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolylineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nPolylineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var i;\n\n  var positions = value._positions;\n  var length = positions.length;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  var colors = value._colors;\n  length = defined(colors) ? colors.length : 0.0;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n    Color.pack(colors[i], array, startingIndex);\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._width;\n  array[startingIndex++] = value._colorsPerVertex ? 1.0 : 0.0;\n  array[startingIndex++] = value._arcType;\n  array[startingIndex] = value._granularity;\n\n  return array;\n};\n\nvar scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nvar scratchVertexFormat = new VertexFormat();\nvar scratchOptions = {\n  positions: undefined,\n  colors: undefined,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  width: undefined,\n  colorsPerVertex: undefined,\n  arcType: undefined,\n  granularity: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolylineGeometry} [result] The object into which to store the result.\n * @returns {PolylineGeometry} The modified result parameter or a new PolylineGeometry instance if one was not provided.\n */\nPolylineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var i;\n\n  var length = array[startingIndex++];\n  var positions = new Array(length);\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  length = array[startingIndex++];\n  var colors = length > 0 ? new Array(length) : undefined;\n\n  for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n    colors[i] = Color.unpack(array, startingIndex);\n  }\n\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  var vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  var width = array[startingIndex++];\n  var colorsPerVertex = array[startingIndex++] === 1.0;\n  var arcType = array[startingIndex++];\n  var granularity = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.positions = positions;\n    scratchOptions.colors = colors;\n    scratchOptions.width = width;\n    scratchOptions.colorsPerVertex = colorsPerVertex;\n    scratchOptions.arcType = arcType;\n    scratchOptions.granularity = granularity;\n    return new PolylineGeometry(scratchOptions);\n  }\n\n  result._positions = positions;\n  result._colors = colors;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._width = width;\n  result._colorsPerVertex = colorsPerVertex;\n  result._arcType = arcType;\n  result._granularity = granularity;\n\n  return result;\n};\n\nvar scratchCartesian3 = new Cartesian3();\nvar scratchPosition = new Cartesian3();\nvar scratchPrevPosition = new Cartesian3();\nvar scratchNextPosition = new Cartesian3();\n\n/**\n * Computes the geometric representation of a polyline, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolylineGeometry} polylineGeometry A description of the polyline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPolylineGeometry.createGeometry = function (polylineGeometry) {\n  var width = polylineGeometry._width;\n  var vertexFormat = polylineGeometry._vertexFormat;\n  var colors = polylineGeometry._colors;\n  var colorsPerVertex = polylineGeometry._colorsPerVertex;\n  var arcType = polylineGeometry._arcType;\n  var granularity = polylineGeometry._granularity;\n  var ellipsoid = polylineGeometry._ellipsoid;\n\n  var i;\n  var j;\n  var k;\n\n  var positions = arrayRemoveDuplicates(\n    polylineGeometry._positions,\n    Cartesian3.equalsEpsilon\n  );\n  var positionsLength = positions.length;\n\n  // A width of a pixel or less is not a valid geometry, but in order to support external data\n  // that may have errors we treat this as an empty geometry.\n  if (positionsLength < 2 || width <= 0.0) {\n    return undefined;\n  }\n\n  if (arcType === ArcType.GEODESIC || arcType === ArcType.RHUMB) {\n    var subdivisionSize;\n    var numberOfPointsFunction;\n    if (arcType === ArcType.GEODESIC) {\n      subdivisionSize = CesiumMath.chordLength(\n        granularity,\n        ellipsoid.maximumRadius\n      );\n      numberOfPointsFunction = PolylinePipeline.numberOfPoints;\n    } else {\n      subdivisionSize = granularity;\n      numberOfPointsFunction = PolylinePipeline.numberOfPointsRhumbLine;\n    }\n\n    var heights = PolylinePipeline.extractHeights(positions, ellipsoid);\n\n    if (defined(colors)) {\n      var colorLength = 1;\n      for (i = 0; i < positionsLength - 1; ++i) {\n        colorLength += numberOfPointsFunction(\n          positions[i],\n          positions[i + 1],\n          subdivisionSize\n        );\n      }\n\n      var newColors = new Array(colorLength);\n      var newColorIndex = 0;\n\n      for (i = 0; i < positionsLength - 1; ++i) {\n        var p0 = positions[i];\n        var p1 = positions[i + 1];\n        var c0 = colors[i];\n\n        var numColors = numberOfPointsFunction(p0, p1, subdivisionSize);\n        if (colorsPerVertex && i < colorLength) {\n          var c1 = colors[i + 1];\n          var interpolatedColors = interpolateColors(p0, p1, c0, c1, numColors);\n          var interpolatedColorsLength = interpolatedColors.length;\n          for (j = 0; j < interpolatedColorsLength; ++j) {\n            newColors[newColorIndex++] = interpolatedColors[j];\n          }\n        } else {\n          for (j = 0; j < numColors; ++j) {\n            newColors[newColorIndex++] = Color.clone(c0);\n          }\n        }\n      }\n\n      newColors[newColorIndex] = Color.clone(colors[colors.length - 1]);\n      colors = newColors;\n\n      scratchInterpolateColorsArray.length = 0;\n    }\n\n    if (arcType === ArcType.GEODESIC) {\n      positions = PolylinePipeline.generateCartesianArc({\n        positions: positions,\n        minDistance: subdivisionSize,\n        ellipsoid: ellipsoid,\n        height: heights,\n      });\n    } else {\n      positions = PolylinePipeline.generateCartesianRhumbArc({\n        positions: positions,\n        granularity: subdivisionSize,\n        ellipsoid: ellipsoid,\n        height: heights,\n      });\n    }\n  }\n\n  positionsLength = positions.length;\n  var size = positionsLength * 4.0 - 4.0;\n\n  var finalPositions = new Float64Array(size * 3);\n  var prevPositions = new Float64Array(size * 3);\n  var nextPositions = new Float64Array(size * 3);\n  var expandAndWidth = new Float32Array(size * 2);\n  var st = vertexFormat.st ? new Float32Array(size * 2) : undefined;\n  var finalColors = defined(colors) ? new Uint8Array(size * 4) : undefined;\n\n  var positionIndex = 0;\n  var expandAndWidthIndex = 0;\n  var stIndex = 0;\n  var colorIndex = 0;\n  var position;\n\n  for (j = 0; j < positionsLength; ++j) {\n    if (j === 0) {\n      position = scratchCartesian3;\n      Cartesian3.subtract(positions[0], positions[1], position);\n      Cartesian3.add(positions[0], position, position);\n    } else {\n      position = positions[j - 1];\n    }\n\n    Cartesian3.clone(position, scratchPrevPosition);\n    Cartesian3.clone(positions[j], scratchPosition);\n\n    if (j === positionsLength - 1) {\n      position = scratchCartesian3;\n      Cartesian3.subtract(\n        positions[positionsLength - 1],\n        positions[positionsLength - 2],\n        position\n      );\n      Cartesian3.add(positions[positionsLength - 1], position, position);\n    } else {\n      position = positions[j + 1];\n    }\n\n    Cartesian3.clone(position, scratchNextPosition);\n\n    var color0, color1;\n    if (defined(finalColors)) {\n      if (j !== 0 && !colorsPerVertex) {\n        color0 = colors[j - 1];\n      } else {\n        color0 = colors[j];\n      }\n\n      if (j !== positionsLength - 1) {\n        color1 = colors[j];\n      }\n    }\n\n    var startK = j === 0 ? 2 : 0;\n    var endK = j === positionsLength - 1 ? 2 : 4;\n\n    for (k = startK; k < endK; ++k) {\n      Cartesian3.pack(scratchPosition, finalPositions, positionIndex);\n      Cartesian3.pack(scratchPrevPosition, prevPositions, positionIndex);\n      Cartesian3.pack(scratchNextPosition, nextPositions, positionIndex);\n      positionIndex += 3;\n\n      var direction = k - 2 < 0 ? -1.0 : 1.0;\n      expandAndWidth[expandAndWidthIndex++] = 2 * (k % 2) - 1; // expand direction\n      expandAndWidth[expandAndWidthIndex++] = direction * width;\n\n      if (vertexFormat.st) {\n        st[stIndex++] = j / (positionsLength - 1);\n        st[stIndex++] = Math.max(expandAndWidth[expandAndWidthIndex - 2], 0.0);\n      }\n\n      if (defined(finalColors)) {\n        var color = k < 2 ? color0 : color1;\n\n        finalColors[colorIndex++] = Color.floatToByte(color.red);\n        finalColors[colorIndex++] = Color.floatToByte(color.green);\n        finalColors[colorIndex++] = Color.floatToByte(color.blue);\n        finalColors[colorIndex++] = Color.floatToByte(color.alpha);\n      }\n    }\n  }\n\n  var attributes = new GeometryAttributes();\n\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: finalPositions,\n  });\n\n  attributes.prevPosition = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: prevPositions,\n  });\n\n  attributes.nextPosition = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: nextPositions,\n  });\n\n  attributes.expandAndWidth = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 2,\n    values: expandAndWidth,\n  });\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: st,\n    });\n  }\n\n  if (defined(finalColors)) {\n    attributes.color = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 4,\n      values: finalColors,\n      normalize: true,\n    });\n  }\n\n  var indices = IndexDatatype.createTypedArray(size, positionsLength * 6 - 6);\n  var index = 0;\n  var indicesIndex = 0;\n  var length = positionsLength - 1.0;\n  for (j = 0; j < length; ++j) {\n    indices[indicesIndex++] = index;\n    indices[indicesIndex++] = index + 2;\n    indices[indicesIndex++] = index + 1;\n\n    indices[indicesIndex++] = index + 1;\n    indices[indicesIndex++] = index + 2;\n    indices[indicesIndex++] = index + 3;\n\n    index += 4;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: BoundingSphere.fromPoints(positions),\n    geometryType: GeometryType.POLYLINES,\n  });\n};\nexport default PolylineGeometry;\n","import defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport PolylineGeometry from \"../Core/PolylineGeometry.js\";\n\nfunction createPolylineGeometry(polylineGeometry, offset) {\n  if (defined(offset)) {\n    polylineGeometry = PolylineGeometry.unpack(polylineGeometry, offset);\n  }\n  polylineGeometry._ellipsoid = Ellipsoid.clone(polylineGeometry._ellipsoid);\n  return PolylineGeometry.createGeometry(polylineGeometry);\n}\nexport default createPolylineGeometry;\n"],"names":["scratchInterpolateColorsArray","PolylineGeometry","options","positions","defaultValue","EMPTY_OBJECT","colors","width","colorsPerVertex","defined","length","DeveloperError","this","_positions","_colors","_width","_colorsPerVertex","_vertexFormat","VertexFormat","clone","vertexFormat","DEFAULT","_arcType","arcType","ArcType","GEODESIC","_granularity","granularity","CesiumMath","RADIANS_PER_DEGREE","_ellipsoid","Ellipsoid","ellipsoid","WGS84","_workerName","numComponents","Cartesian3","packedLength","Color","pack","value","array","startingIndex","i","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","scratchOptions","undefined","unpack","result","Array","scratchCartesian3","scratchPosition","scratchPrevPosition","scratchNextPosition","createGeometry","polylineGeometry","arrayRemoveDuplicates","equalsEpsilon","positionsLength","RHUMB","subdivisionSize","numberOfPointsFunction","chordLength","maximumRadius","PolylinePipeline","numberOfPoints","numberOfPointsRhumbLine","heights","extractHeights","colorLength","newColors","newColorIndex","p0","p1","c0","numColors","interpolatedColors","color0","color1","numPoints","r0","red","g0","green","b0","blue","a0","alpha","r1","g1","b1","a1","equals","redPerVertex","greenPerVertex","bluePerVertex","alphaPerVertex","interpolateColors","interpolatedColorsLength","j","generateCartesianArc","minDistance","height","generateCartesianRhumbArc","position","size","finalPositions","Float64Array","prevPositions","nextPositions","expandAndWidth","Float32Array","st","finalColors","Uint8Array","positionIndex","expandAndWidthIndex","stIndex","colorIndex","subtract","add","endK","k","direction","Math","max","floatToByte","color","attributes","GeometryAttributes","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","prevPosition","nextPosition","FLOAT","UNSIGNED_BYTE","normalize","indices","IndexDatatype","createTypedArray","index","indicesIndex","Geometry","primitiveType","PrimitiveType","TRIANGLES","boundingSphere","BoundingSphere","fromPoints","geometryType","GeometryType","POLYLINES","offset"],"mappings":"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"}