{"version":3,"file":"EllipsoidGeometry-0b7a309b.js","sources":["../../../../Source/Core/EllipsoidGeometry.js"],"sourcesContent":["import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nvar scratchPosition = new Cartesian3();\nvar scratchNormal = new Cartesian3();\nvar scratchTangent = new Cartesian3();\nvar scratchBitangent = new Cartesian3();\nvar scratchNormalST = new Cartesian3();\nvar defaultRadii = new Cartesian3(1.0, 1.0, 1.0);\n\nvar cos = Math.cos;\nvar sin = Math.sin;\n\n/**\n * A description of an ellipsoid centered at the origin.\n *\n * @alias EllipsoidGeometry\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Cartesian3} [options.radii=Cartesian3(1.0, 1.0, 1.0)] The radii of the ellipsoid in the x, y, and z directions.\n * @param {Cartesian3} [options.innerRadii=options.radii] The inner radii of the ellipsoid in the x, y, and z directions.\n * @param {Number} [options.minimumClock=0.0] The minimum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {Number} [options.maximumClock=2*PI] The maximum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {Number} [options.minimumCone=0.0] The minimum angle measured from the positive z-axis and toward the negative z-axis.\n * @param {Number} [options.maximumCone=PI] The maximum angle measured from the positive z-axis and toward the negative z-axis.\n * @param {Number} [options.stackPartitions=64] The number of times to partition the ellipsoid into stacks.\n * @param {Number} [options.slicePartitions=64] The number of times to partition the ellipsoid into radial slices.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @exception {DeveloperError} options.slicePartitions cannot be less than three.\n * @exception {DeveloperError} options.stackPartitions cannot be less than three.\n *\n * @see EllipsoidGeometry#createGeometry\n *\n * @example\n * var ellipsoid = new Cesium.EllipsoidGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   radii : new Cesium.Cartesian3(1000000.0, 500000.0, 500000.0)\n * });\n * var geometry = Cesium.EllipsoidGeometry.createGeometry(ellipsoid);\n */\nfunction EllipsoidGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var radii = defaultValue(options.radii, defaultRadii);\n  var innerRadii = defaultValue(options.innerRadii, radii);\n  var minimumClock = defaultValue(options.minimumClock, 0.0);\n  var maximumClock = defaultValue(options.maximumClock, CesiumMath.TWO_PI);\n  var minimumCone = defaultValue(options.minimumCone, 0.0);\n  var maximumCone = defaultValue(options.maximumCone, CesiumMath.PI);\n  var stackPartitions = Math.round(defaultValue(options.stackPartitions, 64));\n  var slicePartitions = Math.round(defaultValue(options.slicePartitions, 64));\n  var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (slicePartitions < 3) {\n    throw new DeveloperError(\n      \"options.slicePartitions cannot be less than three.\"\n    );\n  }\n  if (stackPartitions < 3) {\n    throw new DeveloperError(\n      \"options.stackPartitions cannot be less than three.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._radii = Cartesian3.clone(radii);\n  this._innerRadii = Cartesian3.clone(innerRadii);\n  this._minimumClock = minimumClock;\n  this._maximumClock = maximumClock;\n  this._minimumCone = minimumCone;\n  this._maximumCone = maximumCone;\n  this._stackPartitions = stackPartitions;\n  this._slicePartitions = slicePartitions;\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createEllipsoidGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nEllipsoidGeometry.packedLength =\n  2 * Cartesian3.packedLength + VertexFormat.packedLength + 7;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipsoidGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nEllipsoidGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value._radii, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n\n  Cartesian3.pack(value._innerRadii, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._minimumClock;\n  array[startingIndex++] = value._maximumClock;\n  array[startingIndex++] = value._minimumCone;\n  array[startingIndex++] = value._maximumCone;\n  array[startingIndex++] = value._stackPartitions;\n  array[startingIndex++] = value._slicePartitions;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nvar scratchRadii = new Cartesian3();\nvar scratchInnerRadii = new Cartesian3();\nvar scratchVertexFormat = new VertexFormat();\nvar scratchOptions = {\n  radii: scratchRadii,\n  innerRadii: scratchInnerRadii,\n  vertexFormat: scratchVertexFormat,\n  minimumClock: undefined,\n  maximumClock: undefined,\n  minimumCone: undefined,\n  maximumCone: undefined,\n  stackPartitions: undefined,\n  slicePartitions: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipsoidGeometry} [result] The object into which to store the result.\n * @returns {EllipsoidGeometry} The modified result parameter or a new EllipsoidGeometry instance if one was not provided.\n */\nEllipsoidGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var radii = Cartesian3.unpack(array, startingIndex, scratchRadii);\n  startingIndex += Cartesian3.packedLength;\n\n  var innerRadii = Cartesian3.unpack(array, startingIndex, scratchInnerRadii);\n  startingIndex += Cartesian3.packedLength;\n\n  var vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  var minimumClock = array[startingIndex++];\n  var maximumClock = array[startingIndex++];\n  var minimumCone = array[startingIndex++];\n  var maximumCone = array[startingIndex++];\n  var stackPartitions = array[startingIndex++];\n  var slicePartitions = array[startingIndex++];\n  var offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.minimumClock = minimumClock;\n    scratchOptions.maximumClock = maximumClock;\n    scratchOptions.minimumCone = minimumCone;\n    scratchOptions.maximumCone = maximumCone;\n    scratchOptions.stackPartitions = stackPartitions;\n    scratchOptions.slicePartitions = slicePartitions;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new EllipsoidGeometry(scratchOptions);\n  }\n\n  result._radii = Cartesian3.clone(radii, result._radii);\n  result._innerRadii = Cartesian3.clone(innerRadii, result._innerRadii);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._minimumClock = minimumClock;\n  result._maximumClock = maximumClock;\n  result._minimumCone = minimumCone;\n  result._maximumCone = maximumCone;\n  result._stackPartitions = stackPartitions;\n  result._slicePartitions = slicePartitions;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipsoidGeometry} ellipsoidGeometry A description of the ellipsoid.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nEllipsoidGeometry.createGeometry = function (ellipsoidGeometry) {\n  var radii = ellipsoidGeometry._radii;\n  if (radii.x <= 0 || radii.y <= 0 || radii.z <= 0) {\n    return;\n  }\n\n  var innerRadii = ellipsoidGeometry._innerRadii;\n  if (innerRadii.x <= 0 || innerRadii.y <= 0 || innerRadii.z <= 0) {\n    return;\n  }\n\n  var minimumClock = ellipsoidGeometry._minimumClock;\n  var maximumClock = ellipsoidGeometry._maximumClock;\n  var minimumCone = ellipsoidGeometry._minimumCone;\n  var maximumCone = ellipsoidGeometry._maximumCone;\n  var vertexFormat = ellipsoidGeometry._vertexFormat;\n\n  // Add an extra slice and stack so that the number of partitions is the\n  // number of surfaces rather than the number of joints\n  var slicePartitions = ellipsoidGeometry._slicePartitions + 1;\n  var stackPartitions = ellipsoidGeometry._stackPartitions + 1;\n\n  slicePartitions = Math.round(\n    (slicePartitions * Math.abs(maximumClock - minimumClock)) /\n      CesiumMath.TWO_PI\n  );\n  stackPartitions = Math.round(\n    (stackPartitions * Math.abs(maximumCone - minimumCone)) / CesiumMath.PI\n  );\n\n  if (slicePartitions < 2) {\n    slicePartitions = 2;\n  }\n  if (stackPartitions < 2) {\n    stackPartitions = 2;\n  }\n\n  var i;\n  var j;\n  var index = 0;\n\n  // Create arrays for theta and phi. Duplicate first and last angle to\n  // allow different normals at the intersections.\n  var phis = [minimumCone];\n  var thetas = [minimumClock];\n  for (i = 0; i < stackPartitions; i++) {\n    phis.push(\n      minimumCone + (i * (maximumCone - minimumCone)) / (stackPartitions - 1)\n    );\n  }\n  phis.push(maximumCone);\n  for (j = 0; j < slicePartitions; j++) {\n    thetas.push(\n      minimumClock + (j * (maximumClock - minimumClock)) / (slicePartitions - 1)\n    );\n  }\n  thetas.push(maximumClock);\n  var numPhis = phis.length;\n  var numThetas = thetas.length;\n\n  // Allow for extra indices if there is an inner surface and if we need\n  // to close the sides if the clock range is not a full circle\n  var extraIndices = 0;\n  var vertexMultiplier = 1.0;\n  var hasInnerSurface =\n    innerRadii.x !== radii.x ||\n    innerRadii.y !== radii.y ||\n    innerRadii.z !== radii.z;\n  var isTopOpen = false;\n  var isBotOpen = false;\n  var isClockOpen = false;\n  if (hasInnerSurface) {\n    vertexMultiplier = 2.0;\n    if (minimumCone > 0.0) {\n      isTopOpen = true;\n      extraIndices += slicePartitions - 1;\n    }\n    if (maximumCone < Math.PI) {\n      isBotOpen = true;\n      extraIndices += slicePartitions - 1;\n    }\n    if ((maximumClock - minimumClock) % CesiumMath.TWO_PI) {\n      isClockOpen = true;\n      extraIndices += (stackPartitions - 1) * 2 + 1;\n    } else {\n      extraIndices += 1;\n    }\n  }\n\n  var vertexCount = numThetas * numPhis * vertexMultiplier;\n  var positions = new Float64Array(vertexCount * 3);\n  var isInner = arrayFill(new Array(vertexCount), false);\n  var negateNormal = arrayFill(new Array(vertexCount), false);\n\n  // Multiply by 6 because there are two triangles per sector\n  var indexCount = slicePartitions * stackPartitions * vertexMultiplier;\n  var numIndices =\n    6 *\n    (indexCount +\n      extraIndices +\n      1 -\n      (slicePartitions + stackPartitions) * vertexMultiplier);\n  var indices = IndexDatatype.createTypedArray(indexCount, numIndices);\n\n  var normals = vertexFormat.normal\n    ? new Float32Array(vertexCount * 3)\n    : undefined;\n  var tangents = vertexFormat.tangent\n    ? new Float32Array(vertexCount * 3)\n    : undefined;\n  var bitangents = vertexFormat.bitangent\n    ? new Float32Array(vertexCount * 3)\n    : undefined;\n  var st = vertexFormat.st ? new Float32Array(vertexCount * 2) : undefined;\n\n  // Calculate sin/cos phi\n  var sinPhi = new Array(numPhis);\n  var cosPhi = new Array(numPhis);\n  for (i = 0; i < numPhis; i++) {\n    sinPhi[i] = sin(phis[i]);\n    cosPhi[i] = cos(phis[i]);\n  }\n\n  // Calculate sin/cos theta\n  var sinTheta = new Array(numThetas);\n  var cosTheta = new Array(numThetas);\n  for (j = 0; j < numThetas; j++) {\n    cosTheta[j] = cos(thetas[j]);\n    sinTheta[j] = sin(thetas[j]);\n  }\n\n  // Create outer surface\n  for (i = 0; i < numPhis; i++) {\n    for (j = 0; j < numThetas; j++) {\n      positions[index++] = radii.x * sinPhi[i] * cosTheta[j];\n      positions[index++] = radii.y * sinPhi[i] * sinTheta[j];\n      positions[index++] = radii.z * cosPhi[i];\n    }\n  }\n\n  // Create inner surface\n  var vertexIndex = vertexCount / 2.0;\n  if (hasInnerSurface) {\n    for (i = 0; i < numPhis; i++) {\n      for (j = 0; j < numThetas; j++) {\n        positions[index++] = innerRadii.x * sinPhi[i] * cosTheta[j];\n        positions[index++] = innerRadii.y * sinPhi[i] * sinTheta[j];\n        positions[index++] = innerRadii.z * cosPhi[i];\n\n        // Keep track of which vertices are the inner and which ones\n        // need the normal to be negated\n        isInner[vertexIndex] = true;\n        if (i > 0 && i !== numPhis - 1 && j !== 0 && j !== numThetas - 1) {\n          negateNormal[vertexIndex] = true;\n        }\n        vertexIndex++;\n      }\n    }\n  }\n\n  // Create indices for outer surface\n  index = 0;\n  var topOffset;\n  var bottomOffset;\n  for (i = 1; i < numPhis - 2; i++) {\n    topOffset = i * numThetas;\n    bottomOffset = (i + 1) * numThetas;\n\n    for (j = 1; j < numThetas - 2; j++) {\n      indices[index++] = bottomOffset + j;\n      indices[index++] = bottomOffset + j + 1;\n      indices[index++] = topOffset + j + 1;\n\n      indices[index++] = bottomOffset + j;\n      indices[index++] = topOffset + j + 1;\n      indices[index++] = topOffset + j;\n    }\n  }\n\n  // Create indices for inner surface\n  if (hasInnerSurface) {\n    var offset = numPhis * numThetas;\n    for (i = 1; i < numPhis - 2; i++) {\n      topOffset = offset + i * numThetas;\n      bottomOffset = offset + (i + 1) * numThetas;\n\n      for (j = 1; j < numThetas - 2; j++) {\n        indices[index++] = bottomOffset + j;\n        indices[index++] = topOffset + j;\n        indices[index++] = topOffset + j + 1;\n\n        indices[index++] = bottomOffset + j;\n        indices[index++] = topOffset + j + 1;\n        indices[index++] = bottomOffset + j + 1;\n      }\n    }\n  }\n\n  var outerOffset;\n  var innerOffset;\n  if (hasInnerSurface) {\n    if (isTopOpen) {\n      // Connect the top of the inner surface to the top of the outer surface\n      innerOffset = numPhis * numThetas;\n      for (i = 1; i < numThetas - 2; i++) {\n        indices[index++] = i;\n        indices[index++] = i + 1;\n        indices[index++] = innerOffset + i + 1;\n\n        indices[index++] = i;\n        indices[index++] = innerOffset + i + 1;\n        indices[index++] = innerOffset + i;\n      }\n    }\n\n    if (isBotOpen) {\n      // Connect the bottom of the inner surface to the bottom of the outer surface\n      outerOffset = numPhis * numThetas - numThetas;\n      innerOffset = numPhis * numThetas * vertexMultiplier - numThetas;\n      for (i = 1; i < numThetas - 2; i++) {\n        indices[index++] = outerOffset + i + 1;\n        indices[index++] = outerOffset + i;\n        indices[index++] = innerOffset + i;\n\n        indices[index++] = outerOffset + i + 1;\n        indices[index++] = innerOffset + i;\n        indices[index++] = innerOffset + i + 1;\n      }\n    }\n  }\n\n  // Connect the edges if clock is not closed\n  if (isClockOpen) {\n    for (i = 1; i < numPhis - 2; i++) {\n      innerOffset = numThetas * numPhis + numThetas * i;\n      outerOffset = numThetas * i;\n      indices[index++] = innerOffset;\n      indices[index++] = outerOffset + numThetas;\n      indices[index++] = outerOffset;\n\n      indices[index++] = innerOffset;\n      indices[index++] = innerOffset + numThetas;\n      indices[index++] = outerOffset + numThetas;\n    }\n\n    for (i = 1; i < numPhis - 2; i++) {\n      innerOffset = numThetas * numPhis + numThetas * (i + 1) - 1;\n      outerOffset = numThetas * (i + 1) - 1;\n      indices[index++] = outerOffset + numThetas;\n      indices[index++] = innerOffset;\n      indices[index++] = outerOffset;\n\n      indices[index++] = outerOffset + numThetas;\n      indices[index++] = innerOffset + numThetas;\n      indices[index++] = innerOffset;\n    }\n  }\n\n  var attributes = new GeometryAttributes();\n\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    });\n  }\n\n  var stIndex = 0;\n  var normalIndex = 0;\n  var tangentIndex = 0;\n  var bitangentIndex = 0;\n  var vertexCountHalf = vertexCount / 2.0;\n\n  var ellipsoid;\n  var ellipsoidOuter = Ellipsoid.fromCartesian3(radii);\n  var ellipsoidInner = Ellipsoid.fromCartesian3(innerRadii);\n\n  if (\n    vertexFormat.st ||\n    vertexFormat.normal ||\n    vertexFormat.tangent ||\n    vertexFormat.bitangent\n  ) {\n    for (i = 0; i < vertexCount; i++) {\n      ellipsoid = isInner[i] ? ellipsoidInner : ellipsoidOuter;\n      var position = Cartesian3.fromArray(positions, i * 3, scratchPosition);\n      var normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\n      if (negateNormal[i]) {\n        Cartesian3.negate(normal, normal);\n      }\n\n      if (vertexFormat.st) {\n        var normalST = Cartesian2.negate(normal, scratchNormalST);\n        st[stIndex++] =\n          Math.atan2(normalST.y, normalST.x) / CesiumMath.TWO_PI + 0.5;\n        st[stIndex++] = Math.asin(normal.z) / Math.PI + 0.5;\n      }\n\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = normal.x;\n        normals[normalIndex++] = normal.y;\n        normals[normalIndex++] = normal.z;\n      }\n\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\n        var tangent = scratchTangent;\n\n        // Use UNIT_X for the poles\n        var tangetOffset = 0;\n        var unit;\n        if (isInner[i]) {\n          tangetOffset = vertexCountHalf;\n        }\n        if (\n          !isTopOpen &&\n          i >= tangetOffset &&\n          i < tangetOffset + numThetas * 2\n        ) {\n          unit = Cartesian3.UNIT_X;\n        } else {\n          unit = Cartesian3.UNIT_Z;\n        }\n        Cartesian3.cross(unit, normal, tangent);\n        Cartesian3.normalize(tangent, tangent);\n\n        if (vertexFormat.tangent) {\n          tangents[tangentIndex++] = tangent.x;\n          tangents[tangentIndex++] = tangent.y;\n          tangents[tangentIndex++] = tangent.z;\n        }\n\n        if (vertexFormat.bitangent) {\n          var bitangent = Cartesian3.cross(normal, tangent, scratchBitangent);\n          Cartesian3.normalize(bitangent, bitangent);\n\n          bitangents[bitangentIndex++] = bitangent.x;\n          bitangents[bitangentIndex++] = bitangent.y;\n          bitangents[bitangentIndex++] = bitangent.z;\n        }\n      }\n    }\n\n    if (vertexFormat.st) {\n      attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: st,\n      });\n    }\n\n    if (vertexFormat.normal) {\n      attributes.normal = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: normals,\n      });\n    }\n\n    if (vertexFormat.tangent) {\n      attributes.tangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: tangents,\n      });\n    }\n\n    if (vertexFormat.bitangent) {\n      attributes.bitangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: bitangents,\n      });\n    }\n  }\n\n  if (defined(ellipsoidGeometry._offsetAttribute)) {\n    var length = positions.length;\n    var applyOffset = new Uint8Array(length / 3);\n    var offsetValue =\n      ellipsoidGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n        ? 0\n        : 1;\n    arrayFill(applyOffset, offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: BoundingSphere.fromEllipsoid(ellipsoidOuter),\n    offsetAttribute: ellipsoidGeometry._offsetAttribute,\n  });\n};\n\nvar unitEllipsoidGeometry;\n\n/**\n * Returns the geometric representation of a unit ellipsoid, including its vertices, indices, and a bounding sphere.\n * @returns {Geometry} The computed vertices and indices.\n *\n * @private\n */\nEllipsoidGeometry.getUnitEllipsoid = function () {\n  if (!defined(unitEllipsoidGeometry)) {\n    unitEllipsoidGeometry = EllipsoidGeometry.createGeometry(\n      new EllipsoidGeometry({\n        radii: new Cartesian3(1.0, 1.0, 1.0),\n        vertexFormat: VertexFormat.POSITION_ONLY,\n      })\n    );\n  }\n  return unitEllipsoidGeometry;\n};\nexport default EllipsoidGeometry;\n"],"names":["scratchPosition","Cartesian3","scratchNormal","scratchTangent","scratchBitangent","scratchNormalST","defaultRadii","cos","Math","sin","EllipsoidGeometry","options","defaultValue","EMPTY_OBJECT","radii","innerRadii","minimumClock","maximumClock","CesiumMath","TWO_PI","minimumCone","maximumCone","PI","stackPartitions","round","slicePartitions","vertexFormat","VertexFormat","DEFAULT","DeveloperError","this","_radii","clone","_innerRadii","_minimumClock","_maximumClock","_minimumCone","_maximumCone","_stackPartitions","_slicePartitions","_vertexFormat","_offsetAttribute","offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","defined","unitEllipsoidGeometry","scratchRadii","scratchInnerRadii","scratchVertexFormat","scratchOptions","undefined","unpack","result","createGeometry","ellipsoidGeometry","x","y","z","abs","index","phis","thetas","i","push","j","numPhis","length","numThetas","extraIndices","vertexMultiplier","hasInnerSurface","isTopOpen","isBotOpen","isClockOpen","vertexCount","positions","Float64Array","isInner","arrayFill","Array","negateNormal","indexCount","indices","IndexDatatype","createTypedArray","normals","normal","Float32Array","tangents","tangent","bitangents","bitangent","st","sinPhi","cosPhi","sinTheta","cosTheta","topOffset","bottomOffset","outerOffset","innerOffset","vertexIndex","offset","attributes","GeometryAttributes","position","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","stIndex","normalIndex","tangentIndex","bitangentIndex","vertexCountHalf","ellipsoidOuter","Ellipsoid","fromCartesian3","ellipsoidInner","ellipsoid","fromArray","geodeticSurfaceNormal","negate","normalST","Cartesian2","atan2","asin","tangetOffset","unit","UNIT_X","UNIT_Z","cross","normalize","FLOAT","applyOffset","Uint8Array","offsetValue","GeometryOffsetAttribute","NONE","UNSIGNED_BYTE","Geometry","primitiveType","PrimitiveType","TRIANGLES","boundingSphere","BoundingSphere","fromEllipsoid","getUnitEllipsoid","POSITION_ONLY"],"mappings":"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"}