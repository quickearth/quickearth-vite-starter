{"version":3,"file":"GeometryAttribute-0ee94cf1.js","sources":["../../../../Source/Core/GeometryType.js","../../../../Source/Core/Matrix2.js","../../../../Source/Core/PrimitiveType.js","../../../../Source/Core/Geometry.js","../../../../Source/Core/GeometryAttribute.js"],"sourcesContent":["/**\n * @private\n */\nvar GeometryType = {\n  NONE: 0,\n  TRIANGLES: 1,\n  LINES: 2,\n  POLYLINES: 3,\n};\nexport default Object.freeze(GeometryType);\n","import Cartesian2 from \"./Cartesian2.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\n\n/**\n * A 2x2 matrix, indexable as a column-major order array.\n * Constructor parameters are in row-major order for code readability.\n * @alias Matrix2\n * @constructor\n * @implements {ArrayLike<number>}\n *\n * @param {Number} [column0Row0=0.0] The value for column 0, row 0.\n * @param {Number} [column1Row0=0.0] The value for column 1, row 0.\n * @param {Number} [column0Row1=0.0] The value for column 0, row 1.\n * @param {Number} [column1Row1=0.0] The value for column 1, row 1.\n *\n * @see Matrix2.fromColumnMajorArray\n * @see Matrix2.fromRowMajorArray\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix3\n * @see Matrix4\n */\nfunction Matrix2(column0Row0, column1Row0, column0Row1, column1Row1) {\n  this[0] = defaultValue(column0Row0, 0.0);\n  this[1] = defaultValue(column0Row1, 0.0);\n  this[2] = defaultValue(column1Row0, 0.0);\n  this[3] = defaultValue(column1Row1, 0.0);\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nMatrix2.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Matrix2} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nMatrix2.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value[0];\n  array[startingIndex++] = value[1];\n  array[startingIndex++] = value[2];\n  array[startingIndex++] = value[3];\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Matrix2} [result] The object into which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n */\nMatrix2.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Matrix2();\n  }\n\n  result[0] = array[startingIndex++];\n  result[1] = array[startingIndex++];\n  result[2] = array[startingIndex++];\n  result[3] = array[startingIndex++];\n  return result;\n};\n\n/**\n * Duplicates a Matrix2 instance.\n *\n * @param {Matrix2} matrix The matrix to duplicate.\n * @param {Matrix2} [result] The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided. (Returns undefined if matrix is undefined)\n */\nMatrix2.clone = function (matrix, result) {\n  if (!defined(matrix)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Matrix2(matrix[0], matrix[2], matrix[1], matrix[3]);\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  return result;\n};\n\n/**\n * Creates a Matrix2 from 4 consecutive elements in an array.\n *\n * @param {Number[]} array The array whose 4 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.\n * @param {Matrix2} [result] The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Create the Matrix2:\n * // [1.0, 2.0]\n * // [1.0, 2.0]\n *\n * var v = [1.0, 1.0, 2.0, 2.0];\n * var m = Cesium.Matrix2.fromArray(v);\n *\n * // Create same Matrix2 with using an offset into an array\n * var v2 = [0.0, 0.0, 1.0, 1.0, 2.0, 2.0];\n * var m2 = Cesium.Matrix2.fromArray(v2, 2);\n */\nMatrix2.fromArray = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Matrix2();\n  }\n\n  result[0] = array[startingIndex];\n  result[1] = array[startingIndex + 1];\n  result[2] = array[startingIndex + 2];\n  result[3] = array[startingIndex + 3];\n  return result;\n};\n\n/**\n * Creates a Matrix2 instance from a column-major order array.\n *\n * @param {Number[]} values The column-major order array.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n */\nMatrix2.fromColumnMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  return Matrix2.clone(values, result);\n};\n\n/**\n * Creates a Matrix2 instance from a row-major order array.\n * The resulting matrix will be in column-major order.\n *\n * @param {Number[]} values The row-major order array.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n */\nMatrix2.fromRowMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix2(values[0], values[1], values[2], values[3]);\n  }\n  result[0] = values[0];\n  result[1] = values[2];\n  result[2] = values[1];\n  result[3] = values[3];\n  return result;\n};\n\n/**\n * Computes a Matrix2 instance representing a non-uniform scale.\n *\n * @param {Cartesian2} scale The x and y scale factors.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [7.0, 0.0]\n * //   [0.0, 8.0]\n * var m = Cesium.Matrix2.fromScale(new Cesium.Cartesian2(7.0, 8.0));\n */\nMatrix2.fromScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix2(scale.x, 0.0, 0.0, scale.y);\n  }\n\n  result[0] = scale.x;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = scale.y;\n  return result;\n};\n\n/**\n * Computes a Matrix2 instance representing a uniform scale.\n *\n * @param {Number} scale The uniform scale factor.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [2.0, 0.0]\n * //   [0.0, 2.0]\n * var m = Cesium.Matrix2.fromUniformScale(2.0);\n */\nMatrix2.fromUniformScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix2(scale, 0.0, 0.0, scale);\n  }\n\n  result[0] = scale;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = scale;\n  return result;\n};\n\n/**\n * Creates a rotation matrix.\n *\n * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise.\n * var p = new Cesium.Cartesian2(5, 6);\n * var m = Cesium.Matrix2.fromRotation(Cesium.Math.toRadians(45.0));\n * var rotated = Cesium.Matrix2.multiplyByVector(m, p, new Cesium.Cartesian2());\n */\nMatrix2.fromRotation = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  var cosAngle = Math.cos(angle);\n  var sinAngle = Math.sin(angle);\n\n  if (!defined(result)) {\n    return new Matrix2(cosAngle, -sinAngle, sinAngle, cosAngle);\n  }\n  result[0] = cosAngle;\n  result[1] = sinAngle;\n  result[2] = -sinAngle;\n  result[3] = cosAngle;\n  return result;\n};\n\n/**\n * Creates an Array from the provided Matrix2 instance.\n * The array will be in column-major order.\n *\n * @param {Matrix2} matrix The matrix to use..\n * @param {Number[]} [result] The Array onto which to store the result.\n * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.\n */\nMatrix2.toArray = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return [matrix[0], matrix[1], matrix[2], matrix[3]];\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  return result;\n};\n\n/**\n * Computes the array index of the element at the provided row and column.\n *\n * @param {Number} row The zero-based index of the row.\n * @param {Number} column The zero-based index of the column.\n * @returns {Number} The index of the element at the provided row and column.\n *\n * @exception {DeveloperError} row must be 0 or 1.\n * @exception {DeveloperError} column must be 0 or 1.\n *\n * @example\n * var myMatrix = new Cesium.Matrix2();\n * var column1Row0Index = Cesium.Matrix2.getElementIndex(1, 0);\n * var column1Row0 = myMatrix[column1Row0Index]\n * myMatrix[column1Row0Index] = 10.0;\n */\nMatrix2.getElementIndex = function (column, row) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"row\", row, 0);\n  Check.typeOf.number.lessThanOrEquals(\"row\", row, 1);\n\n  Check.typeOf.number.greaterThanOrEquals(\"column\", column, 0);\n  Check.typeOf.number.lessThanOrEquals(\"column\", column, 1);\n  //>>includeEnd('debug');\n\n  return column * 2 + row;\n};\n\n/**\n * Retrieves a copy of the matrix column at the provided index as a Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {Number} index The zero-based index of the column to retrieve.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.getColumn = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var startIndex = index * 2;\n  var x = matrix[startIndex];\n  var y = matrix[startIndex + 1];\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {Number} index The zero-based index of the column to set.\n * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified column.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.setColumn = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix2.clone(matrix, result);\n  var startIndex = index * 2;\n  result[startIndex] = cartesian.x;\n  result[startIndex + 1] = cartesian.y;\n  return result;\n};\n\n/**\n * Retrieves a copy of the matrix row at the provided index as a Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {Number} index The zero-based index of the row to retrieve.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.getRow = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var x = matrix[index];\n  var y = matrix[index + 2];\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {Number} index The zero-based index of the row to set.\n * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified row.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.setRow = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix2.clone(matrix, result);\n  result[index] = cartesian.x;\n  result[index + 2] = cartesian.y;\n  return result;\n};\n\nvar scratchColumn = new Cartesian2();\n\n/**\n * Extracts the non-uniform scale assuming the matrix is an affine transformation.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nMatrix2.getScale = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Cartesian2.magnitude(\n    Cartesian2.fromElements(matrix[0], matrix[1], scratchColumn)\n  );\n  result.y = Cartesian2.magnitude(\n    Cartesian2.fromElements(matrix[2], matrix[3], scratchColumn)\n  );\n  return result;\n};\n\nvar scratchScale = new Cartesian2();\n\n/**\n * Computes the maximum scale assuming the matrix is an affine transformation.\n * The maximum scale is the maximum length of the column vectors.\n *\n * @param {Matrix2} matrix The matrix.\n * @returns {Number} The maximum scale.\n */\nMatrix2.getMaximumScale = function (matrix) {\n  Matrix2.getScale(matrix, scratchScale);\n  return Cartesian2.maximumComponent(scratchScale);\n};\n\n/**\n * Computes the product of two matrices.\n *\n * @param {Matrix2} left The first matrix.\n * @param {Matrix2} right The second matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var column0Row0 = left[0] * right[0] + left[2] * right[1];\n  var column1Row0 = left[0] * right[2] + left[2] * right[3];\n  var column0Row1 = left[1] * right[0] + left[3] * right[1];\n  var column1Row1 = left[1] * right[2] + left[3] * right[3];\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column1Row0;\n  result[3] = column1Row1;\n  return result;\n};\n\n/**\n * Computes the sum of two matrices.\n *\n * @param {Matrix2} left The first matrix.\n * @param {Matrix2} right The second matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] + right[0];\n  result[1] = left[1] + right[1];\n  result[2] = left[2] + right[2];\n  result[3] = left[3] + right[3];\n  return result;\n};\n\n/**\n * Computes the difference of two matrices.\n *\n * @param {Matrix2} left The first matrix.\n * @param {Matrix2} right The second matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] - right[0];\n  result[1] = left[1] - right[1];\n  result[2] = left[2] - right[2];\n  result[3] = left[3] - right[3];\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a column vector.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Cartesian2} cartesian The column.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nMatrix2.multiplyByVector = function (matrix, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var x = matrix[0] * cartesian.x + matrix[2] * cartesian.y;\n  var y = matrix[1] * cartesian.x + matrix[3] * cartesian.y;\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a scalar.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Number} scalar The number to multiply by.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.multiplyByScalar = function (matrix, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scalar;\n  result[1] = matrix[1] * scalar;\n  result[2] = matrix[2] * scalar;\n  result[3] = matrix[3] * scalar;\n  return result;\n};\n\n/**\n * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.\n *\n * @param {Matrix2} matrix The matrix on the left-hand side.\n * @param {Cartesian2} scale The non-uniform scale on the right-hand side.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n *\n * @example\n * // Instead of Cesium.Matrix2.multiply(m, Cesium.Matrix2.fromScale(scale), m);\n * Cesium.Matrix2.multiplyByScale(m, scale, m);\n *\n * @see Matrix2.fromScale\n * @see Matrix2.multiplyByUniformScale\n */\nMatrix2.multiplyByScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale.x;\n  result[1] = matrix[1] * scale.x;\n  result[2] = matrix[2] * scale.y;\n  result[3] = matrix[3] * scale.y;\n  return result;\n};\n\n/**\n * Creates a negated copy of the provided matrix.\n *\n * @param {Matrix2} matrix The matrix to negate.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.negate = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = -matrix[0];\n  result[1] = -matrix[1];\n  result[2] = -matrix[2];\n  result[3] = -matrix[3];\n  return result;\n};\n\n/**\n * Computes the transpose of the provided matrix.\n *\n * @param {Matrix2} matrix The matrix to transpose.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.transpose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var column0Row0 = matrix[0];\n  var column0Row1 = matrix[2];\n  var column1Row0 = matrix[1];\n  var column1Row1 = matrix[3];\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column1Row0;\n  result[3] = column1Row1;\n  return result;\n};\n\n/**\n * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.\n *\n * @param {Matrix2} matrix The matrix with signed elements.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.abs = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = Math.abs(matrix[0]);\n  result[1] = Math.abs(matrix[1]);\n  result[2] = Math.abs(matrix[2]);\n  result[3] = Math.abs(matrix[3]);\n\n  return result;\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix2} [left] The first matrix.\n * @param {Matrix2} [right] The second matrix.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nMatrix2.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left[0] === right[0] &&\n      left[1] === right[1] &&\n      left[2] === right[2] &&\n      left[3] === right[3])\n  );\n};\n\n/**\n * @private\n */\nMatrix2.equalsArray = function (matrix, array, offset) {\n  return (\n    matrix[0] === array[offset] &&\n    matrix[1] === array[offset + 1] &&\n    matrix[2] === array[offset + 2] &&\n    matrix[3] === array[offset + 3]\n  );\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix2} [left] The first matrix.\n * @param {Matrix2} [right] The second matrix.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix2.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = defaultValue(epsilon, 0);\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(left[0] - right[0]) <= epsilon &&\n      Math.abs(left[1] - right[1]) <= epsilon &&\n      Math.abs(left[2] - right[2]) <= epsilon &&\n      Math.abs(left[3] - right[3]) <= epsilon)\n  );\n};\n\n/**\n * An immutable Matrix2 instance initialized to the identity matrix.\n *\n * @type {Matrix2}\n * @constant\n */\nMatrix2.IDENTITY = Object.freeze(new Matrix2(1.0, 0.0, 0.0, 1.0));\n\n/**\n * An immutable Matrix2 instance initialized to the zero matrix.\n *\n * @type {Matrix2}\n * @constant\n */\nMatrix2.ZERO = Object.freeze(new Matrix2(0.0, 0.0, 0.0, 0.0));\n\n/**\n * The index into Matrix2 for column 0, row 0.\n *\n * @type {Number}\n * @constant\n *\n * @example\n * var matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN0ROW0] = 5.0; // set column 0, row 0 to 5.0\n */\nMatrix2.COLUMN0ROW0 = 0;\n\n/**\n * The index into Matrix2 for column 0, row 1.\n *\n * @type {Number}\n * @constant\n *\n * @example\n * var matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN0ROW1] = 5.0; // set column 0, row 1 to 5.0\n */\nMatrix2.COLUMN0ROW1 = 1;\n\n/**\n * The index into Matrix2 for column 1, row 0.\n *\n * @type {Number}\n * @constant\n *\n * @example\n * var matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN1ROW0] = 5.0; // set column 1, row 0 to 5.0\n */\nMatrix2.COLUMN1ROW0 = 2;\n\n/**\n * The index into Matrix2 for column 1, row 1.\n *\n * @type {Number}\n * @constant\n *\n * @example\n * var matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN1ROW1] = 5.0; // set column 1, row 1 to 5.0\n */\nMatrix2.COLUMN1ROW1 = 3;\n\nObject.defineProperties(Matrix2.prototype, {\n  /**\n   * Gets the number of items in the collection.\n   * @memberof Matrix2.prototype\n   *\n   * @type {Number}\n   */\n  length: {\n    get: function () {\n      return Matrix2.packedLength;\n    },\n  },\n});\n\n/**\n * Duplicates the provided Matrix2 instance.\n *\n * @param {Matrix2} [result] The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n */\nMatrix2.prototype.clone = function (result) {\n  return Matrix2.clone(this, result);\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix2} [right] The right hand side matrix.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nMatrix2.prototype.equals = function (right) {\n  return Matrix2.equals(this, right);\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix2} [right] The right hand side matrix.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix2.prototype.equalsEpsilon = function (right, epsilon) {\n  return Matrix2.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this Matrix with each row being\n * on a separate line and in the format '(column0, column1)'.\n *\n * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1)'.\n */\nMatrix2.prototype.toString = function () {\n  return (\n    \"(\" +\n    this[0] +\n    \", \" +\n    this[2] +\n    \")\\n\" +\n    \"(\" +\n    this[1] +\n    \", \" +\n    this[3] +\n    \")\"\n  );\n};\nexport default Matrix2;\n","import WebGLConstants from \"./WebGLConstants.js\";\n\n/**\n * The type of a geometric primitive, i.e., points, lines, and triangles.\n *\n * @enum {Number}\n */\nvar PrimitiveType = {\n  /**\n   * Points primitive where each vertex (or index) is a separate point.\n   *\n   * @type {Number}\n   * @constant\n   */\n  POINTS: WebGLConstants.POINTS,\n\n  /**\n   * Lines primitive where each two vertices (or indices) is a line segment.  Line segments are not necessarily connected.\n   *\n   * @type {Number}\n   * @constant\n   */\n  LINES: WebGLConstants.LINES,\n\n  /**\n   * Line loop primitive where each vertex (or index) after the first connects a line to\n   * the previous vertex, and the last vertex implicitly connects to the first.\n   *\n   * @type {Number}\n   * @constant\n   */\n  LINE_LOOP: WebGLConstants.LINE_LOOP,\n\n  /**\n   * Line strip primitive where each vertex (or index) after the first connects a line to the previous vertex.\n   *\n   * @type {Number}\n   * @constant\n   */\n  LINE_STRIP: WebGLConstants.LINE_STRIP,\n\n  /**\n   * Triangles primitive where each three vertices (or indices) is a triangle.  Triangles do not necessarily share edges.\n   *\n   * @type {Number}\n   * @constant\n   */\n  TRIANGLES: WebGLConstants.TRIANGLES,\n\n  /**\n   * Triangle strip primitive where each vertex (or index) after the first two connect to\n   * the previous two vertices forming a triangle.  For example, this can be used to model a wall.\n   *\n   * @type {Number}\n   * @constant\n   */\n  TRIANGLE_STRIP: WebGLConstants.TRIANGLE_STRIP,\n\n  /**\n   * Triangle fan primitive where each vertex (or index) after the first two connect to\n   * the previous vertex and the first vertex forming a triangle.  For example, this can be used\n   * to model a cone or circle.\n   *\n   * @type {Number}\n   * @constant\n   */\n  TRIANGLE_FAN: WebGLConstants.TRIANGLE_FAN,\n};\n\n/**\n * @private\n */\nPrimitiveType.validate = function (primitiveType) {\n  return (\n    primitiveType === PrimitiveType.POINTS ||\n    primitiveType === PrimitiveType.LINES ||\n    primitiveType === PrimitiveType.LINE_LOOP ||\n    primitiveType === PrimitiveType.LINE_STRIP ||\n    primitiveType === PrimitiveType.TRIANGLES ||\n    primitiveType === PrimitiveType.TRIANGLE_STRIP ||\n    primitiveType === PrimitiveType.TRIANGLE_FAN\n  );\n};\n\nexport default Object.freeze(PrimitiveType);\n","import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport GeometryType from \"./GeometryType.js\";\nimport Matrix2 from \"./Matrix2.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Transforms from \"./Transforms.js\";\n\n/**\n * A geometry representation with attributes forming vertices and optional index data\n * defining primitives.  Geometries and an {@link Appearance}, which describes the shading,\n * can be assigned to a {@link Primitive} for visualization.  A <code>Primitive</code> can\n * be created from many heterogeneous - in many cases - geometries for performance.\n * <p>\n * Geometries can be transformed and optimized using functions in {@link GeometryPipeline}.\n * </p>\n *\n * @alias Geometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {GeometryAttributes} options.attributes Attributes, which make up the geometry's vertices.\n * @param {PrimitiveType} [options.primitiveType=PrimitiveType.TRIANGLES] The type of primitives in the geometry.\n * @param {Uint16Array|Uint32Array} [options.indices] Optional index data that determines the primitives in the geometry.\n * @param {BoundingSphere} [options.boundingSphere] An optional bounding sphere that fully enclosed the geometry.\n *\n * @see PolygonGeometry\n * @see RectangleGeometry\n * @see EllipseGeometry\n * @see CircleGeometry\n * @see WallGeometry\n * @see SimplePolylineGeometry\n * @see BoxGeometry\n * @see EllipsoidGeometry\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Geometry%20and%20Appearances.html|Geometry and Appearances Demo}\n *\n * @example\n * // Create geometry with a position attribute and indexed lines.\n * var positions = new Float64Array([\n *   0.0, 0.0, 0.0,\n *   7500000.0, 0.0, 0.0,\n *   0.0, 7500000.0, 0.0\n * ]);\n *\n * var geometry = new Cesium.Geometry({\n *   attributes : {\n *     position : new Cesium.GeometryAttribute({\n *       componentDatatype : Cesium.ComponentDatatype.DOUBLE,\n *       componentsPerAttribute : 3,\n *       values : positions\n *     })\n *   },\n *   indices : new Uint16Array([0, 1, 1, 2, 2, 0]),\n *   primitiveType : Cesium.PrimitiveType.LINES,\n *   boundingSphere : Cesium.BoundingSphere.fromVertices(positions)\n * });\n */\nfunction Geometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.attributes\", options.attributes);\n  //>>includeEnd('debug');\n\n  /**\n   * Attributes, which make up the geometry's vertices.  Each property in this object corresponds to a\n   * {@link GeometryAttribute} containing the attribute's data.\n   * <p>\n   * Attributes are always stored non-interleaved in a Geometry.\n   * </p>\n   * <p>\n   * There are reserved attribute names with well-known semantics.  The following attributes\n   * are created by a Geometry (depending on the provided {@link VertexFormat}.\n   * <ul>\n   *    <li><code>position</code> - 3D vertex position.  64-bit floating-point (for precision).  3 components per attribute.  See {@link VertexFormat#position}.</li>\n   *    <li><code>normal</code> - Normal (normalized), commonly used for lighting.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#normal}.</li>\n   *    <li><code>st</code> - 2D texture coordinate.  32-bit floating-point.  2 components per attribute.  See {@link VertexFormat#st}.</li>\n   *    <li><code>bitangent</code> - Bitangent (normalized), used for tangent-space effects like bump mapping.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#bitangent}.</li>\n   *    <li><code>tangent</code> - Tangent (normalized), used for tangent-space effects like bump mapping.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#tangent}.</li>\n   * </ul>\n   * </p>\n   * <p>\n   * The following attribute names are generally not created by a Geometry, but are added\n   * to a Geometry by a {@link Primitive} or {@link GeometryPipeline} functions to prepare\n   * the geometry for rendering.\n   * <ul>\n   *    <li><code>position3DHigh</code> - High 32 bits for encoded 64-bit position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\n   *    <li><code>position3DLow</code> - Low 32 bits for encoded 64-bit position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\n   *    <li><code>position3DHigh</code> - High 32 bits for encoded 64-bit 2D (Columbus view) position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\n   *    <li><code>position2DLow</code> - Low 32 bits for encoded 64-bit 2D (Columbus view) position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\n   *    <li><code>color</code> - RGBA color (normalized) usually from {@link GeometryInstance#color}.  32-bit floating-point.  4 components per attribute.</li>\n   *    <li><code>pickColor</code> - RGBA color used for picking.  32-bit floating-point.  4 components per attribute.</li>\n   * </ul>\n   * </p>\n   *\n   * @type GeometryAttributes\n   *\n   * @default undefined\n   *\n   *\n   * @example\n   * geometry.attributes.position = new Cesium.GeometryAttribute({\n   *   componentDatatype : Cesium.ComponentDatatype.FLOAT,\n   *   componentsPerAttribute : 3,\n   *   values : new Float32Array(0)\n   * });\n   *\n   * @see GeometryAttribute\n   * @see VertexFormat\n   */\n  this.attributes = options.attributes;\n\n  /**\n   * Optional index data that - along with {@link Geometry#primitiveType} -\n   * determines the primitives in the geometry.\n   *\n   * @type Array\n   *\n   * @default undefined\n   */\n  this.indices = options.indices;\n\n  /**\n   * The type of primitives in the geometry.  This is most often {@link PrimitiveType.TRIANGLES},\n   * but can varying based on the specific geometry.\n   *\n   * @type PrimitiveType\n   *\n   * @default undefined\n   */\n  this.primitiveType = defaultValue(\n    options.primitiveType,\n    PrimitiveType.TRIANGLES\n  );\n\n  /**\n   * An optional bounding sphere that fully encloses the geometry.  This is\n   * commonly used for culling.\n   *\n   * @type BoundingSphere\n   *\n   * @default undefined\n   */\n  this.boundingSphere = options.boundingSphere;\n\n  /**\n   * @private\n   */\n  this.geometryType = defaultValue(options.geometryType, GeometryType.NONE);\n\n  /**\n   * @private\n   */\n  this.boundingSphereCV = options.boundingSphereCV;\n\n  /**\n   * Used for computing the bounding sphere for geometry using the applyOffset vertex attribute\n   * @private\n   */\n  this.offsetAttribute = options.offsetAttribute;\n}\n\n/**\n * Computes the number of vertices in a geometry.  The runtime is linear with\n * respect to the number of attributes in a vertex, not the number of vertices.\n *\n * @param {Geometry} geometry The geometry.\n * @returns {Number} The number of vertices in the geometry.\n *\n * @example\n * var numVertices = Cesium.Geometry.computeNumberOfVertices(geometry);\n */\nGeometry.computeNumberOfVertices = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"geometry\", geometry);\n  //>>includeEnd('debug');\n\n  var numberOfVertices = -1;\n  for (var property in geometry.attributes) {\n    if (\n      geometry.attributes.hasOwnProperty(property) &&\n      defined(geometry.attributes[property]) &&\n      defined(geometry.attributes[property].values)\n    ) {\n      var attribute = geometry.attributes[property];\n      var num = attribute.values.length / attribute.componentsPerAttribute;\n      //>>includeStart('debug', pragmas.debug);\n      if (numberOfVertices !== num && numberOfVertices !== -1) {\n        throw new DeveloperError(\n          \"All attribute lists must have the same number of attributes.\"\n        );\n      }\n      //>>includeEnd('debug');\n      numberOfVertices = num;\n    }\n  }\n\n  return numberOfVertices;\n};\n\nvar rectangleCenterScratch = new Cartographic();\nvar enuCenterScratch = new Cartesian3();\nvar fixedFrameToEnuScratch = new Matrix4();\nvar boundingRectanglePointsCartographicScratch = [\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n];\nvar boundingRectanglePointsEnuScratch = [\n  new Cartesian2(),\n  new Cartesian2(),\n  new Cartesian2(),\n];\nvar points2DScratch = [new Cartesian2(), new Cartesian2(), new Cartesian2()];\nvar pointEnuScratch = new Cartesian3();\nvar enuRotationScratch = new Quaternion();\nvar enuRotationMatrixScratch = new Matrix4();\nvar rotation2DScratch = new Matrix2();\n\n/**\n * For remapping texture coordinates when rendering GroundPrimitives with materials.\n * GroundPrimitive texture coordinates are computed to align with the cartographic coordinate system on the globe.\n * However, EllipseGeometry, RectangleGeometry, and PolygonGeometry all bake rotations to per-vertex texture coordinates\n * using different strategies.\n *\n * This method is used by EllipseGeometry and PolygonGeometry to approximate the same visual effect.\n * We encapsulate rotation and scale by computing a \"transformed\" texture coordinate system and computing\n * a set of reference points from which \"cartographic\" texture coordinates can be remapped to the \"transformed\"\n * system using distances to lines in 2D.\n *\n * This approximation becomes less accurate as the covered area increases, especially for GroundPrimitives near the poles,\n * but is generally reasonable for polygons and ellipses around the size of USA states.\n *\n * RectangleGeometry has its own version of this method that computes remapping coordinates using cartographic space\n * as an intermediary instead of local ENU, which is more accurate for large-area rectangles.\n *\n * @param {Cartesian3[]} positions Array of positions outlining the geometry\n * @param {Number} stRotation Texture coordinate rotation.\n * @param {Ellipsoid} ellipsoid Ellipsoid for projecting and generating local vectors.\n * @param {Rectangle} boundingRectangle Bounding rectangle around the positions.\n * @returns {Number[]} An array of 6 numbers specifying [minimum point, u extent, v extent] as points in the \"cartographic\" system.\n * @private\n */\nGeometry._textureCoordinateRotationPoints = function (\n  positions,\n  stRotation,\n  ellipsoid,\n  boundingRectangle\n) {\n  var i;\n\n  // Create a local east-north-up coordinate system centered on the polygon's bounding rectangle.\n  // Project the southwest, northwest, and southeast corners of the bounding rectangle into the plane of ENU as 2D points.\n  // These are the equivalents of (0,0), (0,1), and (1,0) in the texture coordiante system computed in ShadowVolumeAppearanceFS,\n  // aka \"ENU texture space.\"\n  var rectangleCenter = Rectangle.center(\n    boundingRectangle,\n    rectangleCenterScratch\n  );\n  var enuCenter = Cartographic.toCartesian(\n    rectangleCenter,\n    ellipsoid,\n    enuCenterScratch\n  );\n  var enuToFixedFrame = Transforms.eastNorthUpToFixedFrame(\n    enuCenter,\n    ellipsoid,\n    fixedFrameToEnuScratch\n  );\n  var fixedFrameToEnu = Matrix4.inverse(\n    enuToFixedFrame,\n    fixedFrameToEnuScratch\n  );\n\n  var boundingPointsEnu = boundingRectanglePointsEnuScratch;\n  var boundingPointsCarto = boundingRectanglePointsCartographicScratch;\n\n  boundingPointsCarto[0].longitude = boundingRectangle.west;\n  boundingPointsCarto[0].latitude = boundingRectangle.south;\n\n  boundingPointsCarto[1].longitude = boundingRectangle.west;\n  boundingPointsCarto[1].latitude = boundingRectangle.north;\n\n  boundingPointsCarto[2].longitude = boundingRectangle.east;\n  boundingPointsCarto[2].latitude = boundingRectangle.south;\n\n  var posEnu = pointEnuScratch;\n\n  for (i = 0; i < 3; i++) {\n    Cartographic.toCartesian(boundingPointsCarto[i], ellipsoid, posEnu);\n    posEnu = Matrix4.multiplyByPointAsVector(fixedFrameToEnu, posEnu, posEnu);\n    boundingPointsEnu[i].x = posEnu.x;\n    boundingPointsEnu[i].y = posEnu.y;\n  }\n\n  // Rotate each point in the polygon around the up vector in the ENU by -stRotation and project into ENU as 2D.\n  // Compute the bounding box of these rotated points in the 2D ENU plane.\n  // Rotate the corners back by stRotation, then compute their equivalents in the ENU texture space using the corners computed earlier.\n  var rotation = Quaternion.fromAxisAngle(\n    Cartesian3.UNIT_Z,\n    -stRotation,\n    enuRotationScratch\n  );\n  var textureMatrix = Matrix3.fromQuaternion(\n    rotation,\n    enuRotationMatrixScratch\n  );\n\n  var positionsLength = positions.length;\n  var enuMinX = Number.POSITIVE_INFINITY;\n  var enuMinY = Number.POSITIVE_INFINITY;\n  var enuMaxX = Number.NEGATIVE_INFINITY;\n  var enuMaxY = Number.NEGATIVE_INFINITY;\n  for (i = 0; i < positionsLength; i++) {\n    posEnu = Matrix4.multiplyByPointAsVector(\n      fixedFrameToEnu,\n      positions[i],\n      posEnu\n    );\n    posEnu = Matrix3.multiplyByVector(textureMatrix, posEnu, posEnu);\n\n    enuMinX = Math.min(enuMinX, posEnu.x);\n    enuMinY = Math.min(enuMinY, posEnu.y);\n    enuMaxX = Math.max(enuMaxX, posEnu.x);\n    enuMaxY = Math.max(enuMaxY, posEnu.y);\n  }\n\n  var toDesiredInComputed = Matrix2.fromRotation(stRotation, rotation2DScratch);\n\n  var points2D = points2DScratch;\n  points2D[0].x = enuMinX;\n  points2D[0].y = enuMinY;\n\n  points2D[1].x = enuMinX;\n  points2D[1].y = enuMaxY;\n\n  points2D[2].x = enuMaxX;\n  points2D[2].y = enuMinY;\n\n  var boundingEnuMin = boundingPointsEnu[0];\n  var boundingPointsWidth = boundingPointsEnu[2].x - boundingEnuMin.x;\n  var boundingPointsHeight = boundingPointsEnu[1].y - boundingEnuMin.y;\n\n  for (i = 0; i < 3; i++) {\n    var point2D = points2D[i];\n    // rotate back\n    Matrix2.multiplyByVector(toDesiredInComputed, point2D, point2D);\n\n    // Convert point into east-north texture coordinate space\n    point2D.x = (point2D.x - boundingEnuMin.x) / boundingPointsWidth;\n    point2D.y = (point2D.y - boundingEnuMin.y) / boundingPointsHeight;\n  }\n\n  var minXYCorner = points2D[0];\n  var maxYCorner = points2D[1];\n  var maxXCorner = points2D[2];\n  var result = new Array(6);\n  Cartesian2.pack(minXYCorner, result);\n  Cartesian2.pack(maxYCorner, result, 2);\n  Cartesian2.pack(maxXCorner, result, 4);\n\n  return result;\n};\nexport default Geometry;\n","import defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Values and type information for geometry attributes.  A {@link Geometry}\n * generally contains one or more attributes.  All attributes together form\n * the geometry's vertices.\n *\n * @alias GeometryAttribute\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {ComponentDatatype} [options.componentDatatype] The datatype of each component in the attribute, e.g., individual elements in values.\n * @param {Number} [options.componentsPerAttribute] A number between 1 and 4 that defines the number of components in an attributes.\n * @param {Boolean} [options.normalize=false] When <code>true</code> and <code>componentDatatype</code> is an integer format, indicate that the components should be mapped to the range [0, 1] (unsigned) or [-1, 1] (signed) when they are accessed as floating-point for rendering.\n * @param {number[]|Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} [options.values] The values for the attributes stored in a typed array.\n *\n * @exception {DeveloperError} options.componentsPerAttribute must be between 1 and 4.\n *\n *\n * @example\n * var geometry = new Cesium.Geometry({\n *   attributes : {\n *     position : new Cesium.GeometryAttribute({\n *       componentDatatype : Cesium.ComponentDatatype.FLOAT,\n *       componentsPerAttribute : 3,\n *       values : new Float32Array([\n *         0.0, 0.0, 0.0,\n *         7500000.0, 0.0, 0.0,\n *         0.0, 7500000.0, 0.0\n *       ])\n *     })\n *   },\n *   primitiveType : Cesium.PrimitiveType.LINE_LOOP\n * });\n *\n * @see Geometry\n */\nfunction GeometryAttribute(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.componentDatatype)) {\n    throw new DeveloperError(\"options.componentDatatype is required.\");\n  }\n  if (!defined(options.componentsPerAttribute)) {\n    throw new DeveloperError(\"options.componentsPerAttribute is required.\");\n  }\n  if (\n    options.componentsPerAttribute < 1 ||\n    options.componentsPerAttribute > 4\n  ) {\n    throw new DeveloperError(\n      \"options.componentsPerAttribute must be between 1 and 4.\"\n    );\n  }\n  if (!defined(options.values)) {\n    throw new DeveloperError(\"options.values is required.\");\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * The datatype of each component in the attribute, e.g., individual elements in\n   * {@link GeometryAttribute#values}.\n   *\n   * @type ComponentDatatype\n   *\n   * @default undefined\n   */\n  this.componentDatatype = options.componentDatatype;\n\n  /**\n   * A number between 1 and 4 that defines the number of components in an attributes.\n   * For example, a position attribute with x, y, and z components would have 3 as\n   * shown in the code example.\n   *\n   * @type Number\n   *\n   * @default undefined\n   *\n   * @example\n   * attribute.componentDatatype = Cesium.ComponentDatatype.FLOAT;\n   * attribute.componentsPerAttribute = 3;\n   * attribute.values = new Float32Array([\n   *   0.0, 0.0, 0.0,\n   *   7500000.0, 0.0, 0.0,\n   *   0.0, 7500000.0, 0.0\n   * ]);\n   */\n  this.componentsPerAttribute = options.componentsPerAttribute;\n\n  /**\n   * When <code>true</code> and <code>componentDatatype</code> is an integer format,\n   * indicate that the components should be mapped to the range [0, 1] (unsigned)\n   * or [-1, 1] (signed) when they are accessed as floating-point for rendering.\n   * <p>\n   * This is commonly used when storing colors using {@link ComponentDatatype.UNSIGNED_BYTE}.\n   * </p>\n   *\n   * @type Boolean\n   *\n   * @default false\n   *\n   * @example\n   * attribute.componentDatatype = Cesium.ComponentDatatype.UNSIGNED_BYTE;\n   * attribute.componentsPerAttribute = 4;\n   * attribute.normalize = true;\n   * attribute.values = new Uint8Array([\n   *   Cesium.Color.floatToByte(color.red),\n   *   Cesium.Color.floatToByte(color.green),\n   *   Cesium.Color.floatToByte(color.blue),\n   *   Cesium.Color.floatToByte(color.alpha)\n   * ]);\n   */\n  this.normalize = defaultValue(options.normalize, false);\n\n  /**\n   * The values for the attributes stored in a typed array.  In the code example,\n   * every three elements in <code>values</code> defines one attributes since\n   * <code>componentsPerAttribute</code> is 3.\n   *\n   * @type {number[]|Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array}\n   *\n   * @default undefined\n   *\n   * @example\n   * attribute.componentDatatype = Cesium.ComponentDatatype.FLOAT;\n   * attribute.componentsPerAttribute = 3;\n   * attribute.values = new Float32Array([\n   *   0.0, 0.0, 0.0,\n   *   7500000.0, 0.0, 0.0,\n   *   0.0, 7500000.0, 0.0\n   * ]);\n   */\n  this.values = options.values;\n}\nexport default GeometryAttribute;\n"],"names":["Object","freeze","NONE","TRIANGLES","LINES","POLYLINES","Matrix2","column0Row0","column1Row0","column0Row1","column1Row1","this","defaultValue","packedLength","pack","value","array","startingIndex","Check","typeOf","object","defined","unpack","result","clone","matrix","fromArray","fromColumnMajorArray","values","fromRowMajorArray","fromScale","scale","x","y","fromUniformScale","number","fromRotation","angle","cosAngle","Math","cos","sinAngle","sin","toArray","getElementIndex","column","row","greaterThanOrEquals","lessThanOrEquals","getColumn","index","startIndex","setColumn","cartesian","getRow","setRow","scratchColumn","Cartesian2","getScale","magnitude","fromElements","scratchScale","getMaximumScale","maximumComponent","multiply","left","right","add","subtract","multiplyByVector","multiplyByScalar","scalar","multiplyByScale","negate","transpose","abs","equals","equalsArray","offset","equalsEpsilon","epsilon","IDENTITY","ZERO","COLUMN0ROW0","COLUMN0ROW1","COLUMN1ROW0","COLUMN1ROW1","defineProperties","prototype","length","get","toString","PrimitiveType","POINTS","WebGLConstants","LINE_LOOP","LINE_STRIP","TRIANGLE_STRIP","TRIANGLE_FAN","validate","primitiveType","Geometry","options","EMPTY_OBJECT","attributes","indices","boundingSphere","geometryType","GeometryType","boundingSphereCV","offsetAttribute","computeNumberOfVertices","geometry","property","numberOfVertices","hasOwnProperty","attribute","num","componentsPerAttribute","DeveloperError","rectangleCenterScratch","Cartographic","enuCenterScratch","Cartesian3","fixedFrameToEnuScratch","Matrix4","boundingRectanglePointsCartographicScratch","boundingRectanglePointsEnuScratch","points2DScratch","pointEnuScratch","enuRotationScratch","Quaternion","enuRotationMatrixScratch","rotation2DScratch","_textureCoordinateRotationPoints","positions","stRotation","ellipsoid","boundingRectangle","rectangleCenter","Rectangle","center","enuCenter","toCartesian","enuToFixedFrame","Transforms","eastNorthUpToFixedFrame","fixedFrameToEnu","inverse","boundingPointsEnu","boundingPointsCarto","longitude","west","latitude","south","north","east","posEnu","i","multiplyByPointAsVector","rotation","fromAxisAngle","UNIT_Z","textureMatrix","Matrix3","fromQuaternion","positionsLength","enuMinX","Number","POSITIVE_INFINITY","enuMinY","enuMaxX","NEGATIVE_INFINITY","enuMaxY","min","max","toDesiredInComputed","points2D","boundingEnuMin","boundingPointsWidth","boundingPointsHeight","point2D","minXYCorner","maxYCorner","maxXCorner","Array","componentDatatype","normalize"],"mappings":"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"}