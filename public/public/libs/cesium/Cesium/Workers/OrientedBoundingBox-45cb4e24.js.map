{"version":3,"file":"OrientedBoundingBox-45cb4e24.js","sources":["../../../../Source/Core/OrientedBoundingBox.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport Intersect from \"./Intersect.js\";\nimport Interval from \"./Interval.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Plane from \"./Plane.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * Creates an instance of an OrientedBoundingBox.\n * An OrientedBoundingBox of some object is a closed and convex cuboid. It can provide a tighter bounding volume than {@link BoundingSphere} or {@link AxisAlignedBoundingBox} in many cases.\n * @alias OrientedBoundingBox\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the box.\n * @param {Matrix3} [halfAxes=Matrix3.ZERO] The three orthogonal half-axes of the bounding box.\n *                                          Equivalently, the transformation matrix, to rotate and scale a 0x0x0\n *                                          cube centered at the origin.\n *\n *\n * @example\n * // Create an OrientedBoundingBox using a transformation matrix, a position where the box will be translated, and a scale.\n * var center = new Cesium.Cartesian3(1.0, 0.0, 0.0);\n * var halfAxes = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(1.0, 3.0, 2.0), new Cesium.Matrix3());\n *\n * var obb = new Cesium.OrientedBoundingBox(center, halfAxes);\n *\n * @see BoundingSphere\n * @see BoundingRectangle\n */\nfunction OrientedBoundingBox(center, halfAxes) {\n  /**\n   * The center of the box.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));\n  /**\n   * The transformation matrix, to rotate the box to the right position.\n   * @type {Matrix3}\n   * @default {@link Matrix3.ZERO}\n   */\n  this.halfAxes = Matrix3.clone(defaultValue(halfAxes, Matrix3.ZERO));\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nOrientedBoundingBox.packedLength =\n  Cartesian3.packedLength + Matrix3.packedLength;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {OrientedBoundingBox} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nOrientedBoundingBox.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value.center, array, startingIndex);\n  Matrix3.pack(value.halfAxes, array, startingIndex + Cartesian3.packedLength);\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {OrientedBoundingBox} [result] The object into which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n */\nOrientedBoundingBox.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  Cartesian3.unpack(array, startingIndex, result.center);\n  Matrix3.unpack(\n    array,\n    startingIndex + Cartesian3.packedLength,\n    result.halfAxes\n  );\n  return result;\n};\n\nvar scratchCartesian1 = new Cartesian3();\nvar scratchCartesian2 = new Cartesian3();\nvar scratchCartesian3 = new Cartesian3();\nvar scratchCartesian4 = new Cartesian3();\nvar scratchCartesian5 = new Cartesian3();\nvar scratchCartesian6 = new Cartesian3();\nvar scratchCovarianceResult = new Matrix3();\nvar scratchEigenResult = {\n  unitary: new Matrix3(),\n  diagonal: new Matrix3(),\n};\n\n/**\n * Computes an instance of an OrientedBoundingBox of the given positions.\n * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).\n * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf\n *\n * @param {Cartesian3[]} [positions] List of {@link Cartesian3} points that the bounding box will enclose.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n *\n * @example\n * // Compute an object oriented bounding box enclosing two points.\n * var box = Cesium.OrientedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\n */\nOrientedBoundingBox.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.halfAxes = Matrix3.ZERO;\n    result.center = Cartesian3.ZERO;\n    return result;\n  }\n\n  var i;\n  var length = positions.length;\n\n  var meanPoint = Cartesian3.clone(positions[0], scratchCartesian1);\n  for (i = 1; i < length; i++) {\n    Cartesian3.add(meanPoint, positions[i], meanPoint);\n  }\n  var invLength = 1.0 / length;\n  Cartesian3.multiplyByScalar(meanPoint, invLength, meanPoint);\n\n  var exx = 0.0;\n  var exy = 0.0;\n  var exz = 0.0;\n  var eyy = 0.0;\n  var eyz = 0.0;\n  var ezz = 0.0;\n  var p;\n\n  for (i = 0; i < length; i++) {\n    p = Cartesian3.subtract(positions[i], meanPoint, scratchCartesian2);\n    exx += p.x * p.x;\n    exy += p.x * p.y;\n    exz += p.x * p.z;\n    eyy += p.y * p.y;\n    eyz += p.y * p.z;\n    ezz += p.z * p.z;\n  }\n\n  exx *= invLength;\n  exy *= invLength;\n  exz *= invLength;\n  eyy *= invLength;\n  eyz *= invLength;\n  ezz *= invLength;\n\n  var covarianceMatrix = scratchCovarianceResult;\n  covarianceMatrix[0] = exx;\n  covarianceMatrix[1] = exy;\n  covarianceMatrix[2] = exz;\n  covarianceMatrix[3] = exy;\n  covarianceMatrix[4] = eyy;\n  covarianceMatrix[5] = eyz;\n  covarianceMatrix[6] = exz;\n  covarianceMatrix[7] = eyz;\n  covarianceMatrix[8] = ezz;\n\n  var eigenDecomposition = Matrix3.computeEigenDecomposition(\n    covarianceMatrix,\n    scratchEigenResult\n  );\n  var rotation = Matrix3.clone(eigenDecomposition.unitary, result.halfAxes);\n\n  var v1 = Matrix3.getColumn(rotation, 0, scratchCartesian4);\n  var v2 = Matrix3.getColumn(rotation, 1, scratchCartesian5);\n  var v3 = Matrix3.getColumn(rotation, 2, scratchCartesian6);\n\n  var u1 = -Number.MAX_VALUE;\n  var u2 = -Number.MAX_VALUE;\n  var u3 = -Number.MAX_VALUE;\n  var l1 = Number.MAX_VALUE;\n  var l2 = Number.MAX_VALUE;\n  var l3 = Number.MAX_VALUE;\n\n  for (i = 0; i < length; i++) {\n    p = positions[i];\n    u1 = Math.max(Cartesian3.dot(v1, p), u1);\n    u2 = Math.max(Cartesian3.dot(v2, p), u2);\n    u3 = Math.max(Cartesian3.dot(v3, p), u3);\n\n    l1 = Math.min(Cartesian3.dot(v1, p), l1);\n    l2 = Math.min(Cartesian3.dot(v2, p), l2);\n    l3 = Math.min(Cartesian3.dot(v3, p), l3);\n  }\n\n  v1 = Cartesian3.multiplyByScalar(v1, 0.5 * (l1 + u1), v1);\n  v2 = Cartesian3.multiplyByScalar(v2, 0.5 * (l2 + u2), v2);\n  v3 = Cartesian3.multiplyByScalar(v3, 0.5 * (l3 + u3), v3);\n\n  var center = Cartesian3.add(v1, v2, result.center);\n  Cartesian3.add(center, v3, center);\n\n  var scale = scratchCartesian3;\n  scale.x = u1 - l1;\n  scale.y = u2 - l2;\n  scale.z = u3 - l3;\n  Cartesian3.multiplyByScalar(scale, 0.5, scale);\n  Matrix3.multiplyByScale(result.halfAxes, scale, result.halfAxes);\n\n  return result;\n};\n\nvar scratchOffset = new Cartesian3();\nvar scratchScale = new Cartesian3();\nfunction fromPlaneExtents(\n  planeOrigin,\n  planeXAxis,\n  planeYAxis,\n  planeZAxis,\n  minimumX,\n  maximumX,\n  minimumY,\n  maximumY,\n  minimumZ,\n  maximumZ,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(minimumX) ||\n    !defined(maximumX) ||\n    !defined(minimumY) ||\n    !defined(maximumY) ||\n    !defined(minimumZ) ||\n    !defined(maximumZ)\n  ) {\n    throw new DeveloperError(\n      \"all extents (minimum/maximum X/Y/Z) are required.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  var halfAxes = result.halfAxes;\n  Matrix3.setColumn(halfAxes, 0, planeXAxis, halfAxes);\n  Matrix3.setColumn(halfAxes, 1, planeYAxis, halfAxes);\n  Matrix3.setColumn(halfAxes, 2, planeZAxis, halfAxes);\n\n  var centerOffset = scratchOffset;\n  centerOffset.x = (minimumX + maximumX) / 2.0;\n  centerOffset.y = (minimumY + maximumY) / 2.0;\n  centerOffset.z = (minimumZ + maximumZ) / 2.0;\n\n  var scale = scratchScale;\n  scale.x = (maximumX - minimumX) / 2.0;\n  scale.y = (maximumY - minimumY) / 2.0;\n  scale.z = (maximumZ - minimumZ) / 2.0;\n\n  var center = result.center;\n  centerOffset = Matrix3.multiplyByVector(halfAxes, centerOffset, centerOffset);\n  Cartesian3.add(planeOrigin, centerOffset, center);\n  Matrix3.multiplyByScale(halfAxes, scale, halfAxes);\n\n  return result;\n}\n\nvar scratchRectangleCenterCartographic = new Cartographic();\nvar scratchRectangleCenter = new Cartesian3();\nvar scratchPerimeterCartographicNC = new Cartographic();\nvar scratchPerimeterCartographicNW = new Cartographic();\nvar scratchPerimeterCartographicCW = new Cartographic();\nvar scratchPerimeterCartographicSW = new Cartographic();\nvar scratchPerimeterCartographicSC = new Cartographic();\nvar scratchPerimeterCartesianNC = new Cartesian3();\nvar scratchPerimeterCartesianNW = new Cartesian3();\nvar scratchPerimeterCartesianCW = new Cartesian3();\nvar scratchPerimeterCartesianSW = new Cartesian3();\nvar scratchPerimeterCartesianSC = new Cartesian3();\nvar scratchPerimeterProjectedNC = new Cartesian2();\nvar scratchPerimeterProjectedNW = new Cartesian2();\nvar scratchPerimeterProjectedCW = new Cartesian2();\nvar scratchPerimeterProjectedSW = new Cartesian2();\nvar scratchPerimeterProjectedSC = new Cartesian2();\n\nvar scratchPlaneOrigin = new Cartesian3();\nvar scratchPlaneNormal = new Cartesian3();\nvar scratchPlaneXAxis = new Cartesian3();\nvar scratchHorizonCartesian = new Cartesian3();\nvar scratchHorizonProjected = new Cartesian2();\nvar scratchMaxY = new Cartesian3();\nvar scratchMinY = new Cartesian3();\nvar scratchZ = new Cartesian3();\nvar scratchPlane = new Plane(Cartesian3.UNIT_X, 0.0);\n\n/**\n * Computes an OrientedBoundingBox that bounds a {@link Rectangle} on the surface of an {@link Ellipsoid}.\n * There are no guarantees about the orientation of the bounding box.\n *\n * @param {Rectangle} rectangle The cartographic rectangle on the surface of the ellipsoid.\n * @param {Number} [minimumHeight=0.0] The minimum height (elevation) within the tile.\n * @param {Number} [maximumHeight=0.0] The maximum height (elevation) within the tile.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle is defined.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.\n *\n * @exception {DeveloperError} rectangle.width must be between 0 and pi.\n * @exception {DeveloperError} rectangle.height must be between 0 and pi.\n * @exception {DeveloperError} ellipsoid must be an ellipsoid of revolution (<code>radii.x == radii.y</code>)\n */\nOrientedBoundingBox.fromRectangle = function (\n  rectangle,\n  minimumHeight,\n  maximumHeight,\n  ellipsoid,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required\");\n  }\n  if (rectangle.width < 0.0 || rectangle.width > CesiumMath.TWO_PI) {\n    throw new DeveloperError(\"Rectangle width must be between 0 and 2*pi\");\n  }\n  if (rectangle.height < 0.0 || rectangle.height > CesiumMath.PI) {\n    throw new DeveloperError(\"Rectangle height must be between 0 and pi\");\n  }\n  if (\n    defined(ellipsoid) &&\n    !CesiumMath.equalsEpsilon(\n      ellipsoid.radii.x,\n      ellipsoid.radii.y,\n      CesiumMath.EPSILON15\n    )\n  ) {\n    throw new DeveloperError(\n      \"Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  minimumHeight = defaultValue(minimumHeight, 0.0);\n  maximumHeight = defaultValue(maximumHeight, 0.0);\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  var minX, maxX, minY, maxY, minZ, maxZ, plane;\n\n  if (rectangle.width <= CesiumMath.PI) {\n    // The bounding box will be aligned with the tangent plane at the center of the rectangle.\n    var tangentPointCartographic = Rectangle.center(\n      rectangle,\n      scratchRectangleCenterCartographic\n    );\n    var tangentPoint = ellipsoid.cartographicToCartesian(\n      tangentPointCartographic,\n      scratchRectangleCenter\n    );\n    var tangentPlane = new EllipsoidTangentPlane(tangentPoint, ellipsoid);\n    plane = tangentPlane.plane;\n\n    // If the rectangle spans the equator, CW is instead aligned with the equator (because it sticks out the farthest at the equator).\n    var lonCenter = tangentPointCartographic.longitude;\n    var latCenter =\n      rectangle.south < 0.0 && rectangle.north > 0.0\n        ? 0.0\n        : tangentPointCartographic.latitude;\n\n    // Compute XY extents using the rectangle at maximum height\n    var perimeterCartographicNC = Cartographic.fromRadians(\n      lonCenter,\n      rectangle.north,\n      maximumHeight,\n      scratchPerimeterCartographicNC\n    );\n    var perimeterCartographicNW = Cartographic.fromRadians(\n      rectangle.west,\n      rectangle.north,\n      maximumHeight,\n      scratchPerimeterCartographicNW\n    );\n    var perimeterCartographicCW = Cartographic.fromRadians(\n      rectangle.west,\n      latCenter,\n      maximumHeight,\n      scratchPerimeterCartographicCW\n    );\n    var perimeterCartographicSW = Cartographic.fromRadians(\n      rectangle.west,\n      rectangle.south,\n      maximumHeight,\n      scratchPerimeterCartographicSW\n    );\n    var perimeterCartographicSC = Cartographic.fromRadians(\n      lonCenter,\n      rectangle.south,\n      maximumHeight,\n      scratchPerimeterCartographicSC\n    );\n\n    var perimeterCartesianNC = ellipsoid.cartographicToCartesian(\n      perimeterCartographicNC,\n      scratchPerimeterCartesianNC\n    );\n    var perimeterCartesianNW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicNW,\n      scratchPerimeterCartesianNW\n    );\n    var perimeterCartesianCW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicCW,\n      scratchPerimeterCartesianCW\n    );\n    var perimeterCartesianSW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicSW,\n      scratchPerimeterCartesianSW\n    );\n    var perimeterCartesianSC = ellipsoid.cartographicToCartesian(\n      perimeterCartographicSC,\n      scratchPerimeterCartesianSC\n    );\n\n    var perimeterProjectedNC = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianNC,\n      scratchPerimeterProjectedNC\n    );\n    var perimeterProjectedNW = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianNW,\n      scratchPerimeterProjectedNW\n    );\n    var perimeterProjectedCW = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianCW,\n      scratchPerimeterProjectedCW\n    );\n    var perimeterProjectedSW = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianSW,\n      scratchPerimeterProjectedSW\n    );\n    var perimeterProjectedSC = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianSC,\n      scratchPerimeterProjectedSC\n    );\n\n    minX = Math.min(\n      perimeterProjectedNW.x,\n      perimeterProjectedCW.x,\n      perimeterProjectedSW.x\n    );\n    maxX = -minX; // symmetrical\n\n    maxY = Math.max(perimeterProjectedNW.y, perimeterProjectedNC.y);\n    minY = Math.min(perimeterProjectedSW.y, perimeterProjectedSC.y);\n\n    // Compute minimum Z using the rectangle at minimum height, since it will be deeper than the maximum height\n    perimeterCartographicNW.height = perimeterCartographicSW.height = minimumHeight;\n    perimeterCartesianNW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicNW,\n      scratchPerimeterCartesianNW\n    );\n    perimeterCartesianSW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicSW,\n      scratchPerimeterCartesianSW\n    );\n\n    minZ = Math.min(\n      Plane.getPointDistance(plane, perimeterCartesianNW),\n      Plane.getPointDistance(plane, perimeterCartesianSW)\n    );\n    maxZ = maximumHeight; // Since the tangent plane touches the surface at height = 0, this is okay\n\n    return fromPlaneExtents(\n      tangentPlane.origin,\n      tangentPlane.xAxis,\n      tangentPlane.yAxis,\n      tangentPlane.zAxis,\n      minX,\n      maxX,\n      minY,\n      maxY,\n      minZ,\n      maxZ,\n      result\n    );\n  }\n\n  // Handle the case where rectangle width is greater than PI (wraps around more than half the ellipsoid).\n  var fullyAboveEquator = rectangle.south > 0.0;\n  var fullyBelowEquator = rectangle.north < 0.0;\n  var latitudeNearestToEquator = fullyAboveEquator\n    ? rectangle.south\n    : fullyBelowEquator\n    ? rectangle.north\n    : 0.0;\n  var centerLongitude = Rectangle.center(\n    rectangle,\n    scratchRectangleCenterCartographic\n  ).longitude;\n\n  // Plane is located at the rectangle's center longitude and the rectangle's latitude that is closest to the equator. It rotates around the Z axis.\n  // This results in a better fit than the obb approach for smaller rectangles, which orients with the rectangle's center normal.\n  var planeOrigin = Cartesian3.fromRadians(\n    centerLongitude,\n    latitudeNearestToEquator,\n    maximumHeight,\n    ellipsoid,\n    scratchPlaneOrigin\n  );\n  planeOrigin.z = 0.0; // center the plane on the equator to simpify plane normal calculation\n  var isPole =\n    Math.abs(planeOrigin.x) < CesiumMath.EPSILON10 &&\n    Math.abs(planeOrigin.y) < CesiumMath.EPSILON10;\n  var planeNormal = !isPole\n    ? Cartesian3.normalize(planeOrigin, scratchPlaneNormal)\n    : Cartesian3.UNIT_X;\n  var planeYAxis = Cartesian3.UNIT_Z;\n  var planeXAxis = Cartesian3.cross(planeNormal, planeYAxis, scratchPlaneXAxis);\n  plane = Plane.fromPointNormal(planeOrigin, planeNormal, scratchPlane);\n\n  // Get the horizon point relative to the center. This will be the farthest extent in the plane's X dimension.\n  var horizonCartesian = Cartesian3.fromRadians(\n    centerLongitude + CesiumMath.PI_OVER_TWO,\n    latitudeNearestToEquator,\n    maximumHeight,\n    ellipsoid,\n    scratchHorizonCartesian\n  );\n  maxX = Cartesian3.dot(\n    Plane.projectPointOntoPlane(\n      plane,\n      horizonCartesian,\n      scratchHorizonProjected\n    ),\n    planeXAxis\n  );\n  minX = -maxX; // symmetrical\n\n  // Get the min and max Y, using the height that will give the largest extent\n  maxY = Cartesian3.fromRadians(\n    0.0,\n    rectangle.north,\n    fullyBelowEquator ? minimumHeight : maximumHeight,\n    ellipsoid,\n    scratchMaxY\n  ).z;\n  minY = Cartesian3.fromRadians(\n    0.0,\n    rectangle.south,\n    fullyAboveEquator ? minimumHeight : maximumHeight,\n    ellipsoid,\n    scratchMinY\n  ).z;\n\n  var farZ = Cartesian3.fromRadians(\n    rectangle.east,\n    latitudeNearestToEquator,\n    maximumHeight,\n    ellipsoid,\n    scratchZ\n  );\n  minZ = Plane.getPointDistance(plane, farZ);\n  maxZ = 0.0; // plane origin starts at maxZ already\n\n  // min and max are local to the plane axes\n  return fromPlaneExtents(\n    planeOrigin,\n    planeXAxis,\n    planeYAxis,\n    planeNormal,\n    minX,\n    maxX,\n    minY,\n    maxY,\n    minZ,\n    maxZ,\n    result\n  );\n};\n\n/**\n * Duplicates a OrientedBoundingBox instance.\n *\n * @param {OrientedBoundingBox} box The bounding box to duplicate.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\n */\nOrientedBoundingBox.clone = function (box, result) {\n  if (!defined(box)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new OrientedBoundingBox(box.center, box.halfAxes);\n  }\n\n  Cartesian3.clone(box.center, result.center);\n  Matrix3.clone(box.halfAxes, result.halfAxes);\n\n  return result;\n};\n\n/**\n * Determines which side of a plane the oriented bounding box is located.\n *\n * @param {OrientedBoundingBox} box The oriented bounding box to test.\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nOrientedBoundingBox.intersectPlane = function (box, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n\n  if (!defined(plane)) {\n    throw new DeveloperError(\"plane is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var center = box.center;\n  var normal = plane.normal;\n  var halfAxes = box.halfAxes;\n  var normalX = normal.x,\n    normalY = normal.y,\n    normalZ = normal.z;\n  // plane is used as if it is its normal; the first three components are assumed to be normalized\n  var radEffective =\n    Math.abs(\n      normalX * halfAxes[Matrix3.COLUMN0ROW0] +\n        normalY * halfAxes[Matrix3.COLUMN0ROW1] +\n        normalZ * halfAxes[Matrix3.COLUMN0ROW2]\n    ) +\n    Math.abs(\n      normalX * halfAxes[Matrix3.COLUMN1ROW0] +\n        normalY * halfAxes[Matrix3.COLUMN1ROW1] +\n        normalZ * halfAxes[Matrix3.COLUMN1ROW2]\n    ) +\n    Math.abs(\n      normalX * halfAxes[Matrix3.COLUMN2ROW0] +\n        normalY * halfAxes[Matrix3.COLUMN2ROW1] +\n        normalZ * halfAxes[Matrix3.COLUMN2ROW2]\n    );\n  var distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;\n\n  if (distanceToPlane <= -radEffective) {\n    // The entire box is on the negative side of the plane normal\n    return Intersect.OUTSIDE;\n  } else if (distanceToPlane >= radEffective) {\n    // The entire box is on the positive side of the plane normal\n    return Intersect.INSIDE;\n  }\n  return Intersect.INTERSECTING;\n};\n\nvar scratchCartesianU = new Cartesian3();\nvar scratchCartesianV = new Cartesian3();\nvar scratchCartesianW = new Cartesian3();\nvar scratchPPrime = new Cartesian3();\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\n *\n * @param {OrientedBoundingBox} box The box.\n * @param {Cartesian3} cartesian The point\n * @returns {Number} The estimated distance squared from the bounding sphere to the point.\n *\n * @example\n * // Sort bounding boxes from back to front\n * boxes.sort(function(a, b) {\n *     return Cesium.OrientedBoundingBox.distanceSquaredTo(b, camera.positionWC) - Cesium.OrientedBoundingBox.distanceSquaredTo(a, camera.positionWC);\n * });\n */\nOrientedBoundingBox.distanceSquaredTo = function (box, cartesian) {\n  // See Geometric Tools for Computer Graphics 10.4.2\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var offset = Cartesian3.subtract(cartesian, box.center, scratchOffset);\n\n  var halfAxes = box.halfAxes;\n  var u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\n  var v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\n  var w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\n\n  var uHalf = Cartesian3.magnitude(u);\n  var vHalf = Cartesian3.magnitude(v);\n  var wHalf = Cartesian3.magnitude(w);\n\n  Cartesian3.normalize(u, u);\n  Cartesian3.normalize(v, v);\n  Cartesian3.normalize(w, w);\n\n  var pPrime = scratchPPrime;\n  pPrime.x = Cartesian3.dot(offset, u);\n  pPrime.y = Cartesian3.dot(offset, v);\n  pPrime.z = Cartesian3.dot(offset, w);\n\n  var distanceSquared = 0.0;\n  var d;\n\n  if (pPrime.x < -uHalf) {\n    d = pPrime.x + uHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.x > uHalf) {\n    d = pPrime.x - uHalf;\n    distanceSquared += d * d;\n  }\n\n  if (pPrime.y < -vHalf) {\n    d = pPrime.y + vHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.y > vHalf) {\n    d = pPrime.y - vHalf;\n    distanceSquared += d * d;\n  }\n\n  if (pPrime.z < -wHalf) {\n    d = pPrime.z + wHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.z > wHalf) {\n    d = pPrime.z - wHalf;\n    distanceSquared += d * d;\n  }\n\n  return distanceSquared;\n};\n\nvar scratchCorner = new Cartesian3();\nvar scratchToCenter = new Cartesian3();\n\n/**\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding box.\n *\n * @param {OrientedBoundingBox} box The bounding box to calculate the distance to.\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\n */\nOrientedBoundingBox.computePlaneDistances = function (\n  box,\n  position,\n  direction,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Interval();\n  }\n\n  var minDist = Number.POSITIVE_INFINITY;\n  var maxDist = Number.NEGATIVE_INFINITY;\n\n  var center = box.center;\n  var halfAxes = box.halfAxes;\n\n  var u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\n  var v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\n  var w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\n\n  // project first corner\n  var corner = Cartesian3.add(u, v, scratchCorner);\n  Cartesian3.add(corner, w, corner);\n  Cartesian3.add(corner, center, corner);\n\n  var toCenter = Cartesian3.subtract(corner, position, scratchToCenter);\n  var mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project second corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project third corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project fourth corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project fifth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project sixth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project seventh corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project eighth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  result.start = minDist;\n  result.stop = maxDist;\n  return result;\n};\n\nvar scratchBoundingSphere = new BoundingSphere();\n\n/**\n * Determines whether or not a bounding box is hidden from view by the occluder.\n *\n * @param {OrientedBoundingBox} box The bounding box surrounding the occludee object.\n * @param {Occluder} occluder The occluder.\n * @returns {Boolean} <code>true</code> if the box is not visible; otherwise <code>false</code>.\n */\nOrientedBoundingBox.isOccluded = function (box, occluder) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n  if (!defined(occluder)) {\n    throw new DeveloperError(\"occluder is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var sphere = BoundingSphere.fromOrientedBoundingBox(\n    box,\n    scratchBoundingSphere\n  );\n\n  return !occluder.isBoundingSphereVisible(sphere);\n};\n\n/**\n * Determines which side of a plane the oriented bounding box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nOrientedBoundingBox.prototype.intersectPlane = function (plane) {\n  return OrientedBoundingBox.intersectPlane(this, plane);\n};\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\n *\n * @param {Cartesian3} cartesian The point\n * @returns {Number} The estimated distance squared from the bounding sphere to the point.\n *\n * @example\n * // Sort bounding boxes from back to front\n * boxes.sort(function(a, b) {\n *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\n * });\n */\nOrientedBoundingBox.prototype.distanceSquaredTo = function (cartesian) {\n  return OrientedBoundingBox.distanceSquaredTo(this, cartesian);\n};\n\n/**\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding box.\n *\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\n */\nOrientedBoundingBox.prototype.computePlaneDistances = function (\n  position,\n  direction,\n  result\n) {\n  return OrientedBoundingBox.computePlaneDistances(\n    this,\n    position,\n    direction,\n    result\n  );\n};\n\n/**\n * Determines whether or not a bounding box is hidden from view by the occluder.\n *\n * @param {Occluder} occluder The occluder.\n * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n */\nOrientedBoundingBox.prototype.isOccluded = function (occluder) {\n  return OrientedBoundingBox.isOccluded(this, occluder);\n};\n\n/**\n * Compares the provided OrientedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrientedBoundingBox} left The first OrientedBoundingBox.\n * @param {OrientedBoundingBox} right The second OrientedBoundingBox.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nOrientedBoundingBox.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Cartesian3.equals(left.center, right.center) &&\n      Matrix3.equals(left.halfAxes, right.halfAxes))\n  );\n};\n\n/**\n * Duplicates this OrientedBoundingBox instance.\n *\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n */\nOrientedBoundingBox.prototype.clone = function (result) {\n  return OrientedBoundingBox.clone(this, result);\n};\n\n/**\n * Compares this OrientedBoundingBox against the provided OrientedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrientedBoundingBox} [right] The right hand side OrientedBoundingBox.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nOrientedBoundingBox.prototype.equals = function (right) {\n  return OrientedBoundingBox.equals(this, right);\n};\nexport default OrientedBoundingBox;\n"],"names":["OrientedBoundingBox","center","halfAxes","this","Cartesian3","clone","defaultValue","ZERO","Matrix3","packedLength","pack","value","array","startingIndex","Check","typeOf","object","defined","unpack","result","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchCartesian4","scratchCartesian5","scratchCartesian6","scratchCovarianceResult","scratchEigenResult","unitary","diagonal","fromPoints","positions","length","meanPoint","i","add","invLength","multiplyByScalar","p","exx","exy","exz","eyy","eyz","ezz","subtract","x","y","z","covarianceMatrix","eigenDecomposition","computeEigenDecomposition","rotation","v1","getColumn","v2","v3","u1","Number","MAX_VALUE","u2","u3","l1","l2","l3","Math","max","dot","min","scale","multiplyByScale","scratchOffset","scratchScale","fromPlaneExtents","planeOrigin","planeXAxis","planeYAxis","planeZAxis","minimumX","maximumX","minimumY","maximumY","minimumZ","maximumZ","DeveloperError","setColumn","centerOffset","multiplyByVector","scratchRectangleCenterCartographic","Cartographic","scratchRectangleCenter","scratchPerimeterCartographicNC","scratchPerimeterCartographicNW","scratchPerimeterCartographicCW","scratchPerimeterCartographicSW","scratchPerimeterCartographicSC","scratchPerimeterCartesianNC","scratchPerimeterCartesianNW","scratchPerimeterCartesianCW","scratchPerimeterCartesianSW","scratchPerimeterCartesianSC","scratchPerimeterProjectedNC","Cartesian2","scratchPerimeterProjectedNW","scratchPerimeterProjectedCW","scratchPerimeterProjectedSW","scratchPerimeterProjectedSC","scratchPlaneOrigin","scratchPlaneNormal","scratchPlaneXAxis","scratchHorizonCartesian","scratchHorizonProjected","scratchMaxY","scratchMinY","scratchZ","scratchPlane","Plane","UNIT_X","fromRectangle","rectangle","minimumHeight","maximumHeight","ellipsoid","width","CesiumMath","TWO_PI","height","PI","equalsEpsilon","radii","EPSILON15","Ellipsoid","WGS84","tangentPointCartographic","Rectangle","tangentPoint","cartographicToCartesian","tangentPlane","EllipsoidTangentPlane","plane","lonCenter","longitude","latCenter","south","north","latitude","perimeterCartographicNC","fromRadians","perimeterCartographicNW","west","perimeterCartographicCW","perimeterCartographicSW","perimeterCartographicSC","perimeterCartesianNC","perimeterCartesianNW","perimeterCartesianCW","perimeterCartesianSW","perimeterCartesianSC","perimeterProjectedNC","projectPointToNearestOnPlane","perimeterProjectedNW","perimeterProjectedCW","perimeterProjectedSW","perimeterProjectedSC","maxX","minX","maxY","minY","minZ","getPointDistance","origin","xAxis","yAxis","zAxis","fullyAboveEquator","fullyBelowEquator","latitudeNearestToEquator","centerLongitude","planeNormal","abs","EPSILON10","normalize","UNIT_Z","cross","fromPointNormal","horizonCartesian","PI_OVER_TWO","projectPointOntoPlane","farZ","east","box","intersectPlane","normal","normalX","normalY","normalZ","radEffective","COLUMN0ROW0","COLUMN0ROW1","COLUMN0ROW2","COLUMN1ROW0","COLUMN1ROW1","COLUMN1ROW2","COLUMN2ROW0","COLUMN2ROW1","COLUMN2ROW2","distanceToPlane","distance","Intersect","OUTSIDE","INSIDE","INTERSECTING","scratchCartesianU","scratchCartesianV","scratchCartesianW","scratchPPrime","distanceSquaredTo","cartesian","offset","u","v","w","uHalf","magnitude","vHalf","wHalf","pPrime","d","distanceSquared","scratchCorner","scratchToCenter","computePlaneDistances","position","direction","Interval","minDist","POSITIVE_INFINITY","maxDist","NEGATIVE_INFINITY","corner","toCenter","mag","start","stop","scratchBoundingSphere","BoundingSphere","isOccluded","occluder","sphere","fromOrientedBoundingBox","isBoundingSphereVisible","prototype","equals","left","right"],"mappings":"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"}