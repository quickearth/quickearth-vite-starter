{"version":3,"file":"createBoxOutlineGeometry.js","sources":["../../../../Source/Core/BoxOutlineGeometry.js","../../../../Source/WorkersES6/createBoxOutlineGeometry.js"],"sourcesContent":["import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nvar diffScratch = new Cartesian3();\n\n/**\n * A description of the outline of a cube centered at the origin.\n *\n * @alias BoxOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3} options.minimum The minimum x, y, and z coordinates of the box.\n * @param {Cartesian3} options.maximum The maximum x, y, and z coordinates of the box.\n *\n * @see BoxOutlineGeometry.fromDimensions\n * @see BoxOutlineGeometry.createGeometry\n * @see Packable\n *\n * @example\n * var box = new Cesium.BoxOutlineGeometry({\n *   maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0),\n *   minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0)\n * });\n * var geometry = Cesium.BoxOutlineGeometry.createGeometry(box);\n */\nfunction BoxOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var min = options.minimum;\n  var max = options.maximum;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"min\", min);\n  Check.typeOf.object(\"max\", max);\n  if (\n    defined(options.offsetAttribute) &&\n    options.offsetAttribute === GeometryOffsetAttribute.TOP\n  ) {\n    throw new DeveloperError(\n      \"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._min = Cartesian3.clone(min);\n  this._max = Cartesian3.clone(max);\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createBoxOutlineGeometry\";\n}\n\n/**\n * Creates an outline of a cube centered at the origin given its dimensions.\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3} options.dimensions The width, depth, and height of the box stored in the x, y, and z coordinates of the <code>Cartesian3</code>, respectively.\n * @returns {BoxOutlineGeometry}\n *\n * @exception {DeveloperError} All dimensions components must be greater than or equal to zero.\n *\n *\n * @example\n * var box = Cesium.BoxOutlineGeometry.fromDimensions({\n *   dimensions : new Cesium.Cartesian3(500000.0, 500000.0, 500000.0)\n * });\n * var geometry = Cesium.BoxOutlineGeometry.createGeometry(box);\n *\n * @see BoxOutlineGeometry.createGeometry\n */\nBoxOutlineGeometry.fromDimensions = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var dimensions = options.dimensions;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"dimensions\", dimensions);\n  Check.typeOf.number.greaterThanOrEquals(\"dimensions.x\", dimensions.x, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"dimensions.y\", dimensions.y, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"dimensions.z\", dimensions.z, 0);\n  //>>includeEnd('debug');\n\n  var corner = Cartesian3.multiplyByScalar(dimensions, 0.5, new Cartesian3());\n\n  return new BoxOutlineGeometry({\n    minimum: Cartesian3.negate(corner, new Cartesian3()),\n    maximum: corner,\n    offsetAttribute: options.offsetAttribute,\n  });\n};\n\n/**\n * Creates an outline of a cube from the dimensions of an AxisAlignedBoundingBox.\n *\n * @param {AxisAlignedBoundingBox} boundingBox A description of the AxisAlignedBoundingBox.\n * @returns {BoxOutlineGeometry}\n *\n *\n *\n * @example\n * var aabb = Cesium.AxisAlignedBoundingBox.fromPoints(Cesium.Cartesian3.fromDegreesArray([\n *      -72.0, 40.0,\n *      -70.0, 35.0,\n *      -75.0, 30.0,\n *      -70.0, 30.0,\n *      -68.0, 40.0\n * ]));\n * var box = Cesium.BoxOutlineGeometry.fromAxisAlignedBoundingBox(aabb);\n *\n *  @see BoxOutlineGeometry.createGeometry\n */\nBoxOutlineGeometry.fromAxisAlignedBoundingBox = function (boundingBox) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"boundindBox\", boundingBox);\n  //>>includeEnd('debug');\n\n  return new BoxOutlineGeometry({\n    minimum: boundingBox.minimum,\n    maximum: boundingBox.maximum,\n  });\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nBoxOutlineGeometry.packedLength = 2 * Cartesian3.packedLength + 1;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {BoxOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nBoxOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value._min, array, startingIndex);\n  Cartesian3.pack(value._max, array, startingIndex + Cartesian3.packedLength);\n  array[startingIndex + Cartesian3.packedLength * 2] = defaultValue(\n    value._offsetAttribute,\n    -1\n  );\n\n  return array;\n};\n\nvar scratchMin = new Cartesian3();\nvar scratchMax = new Cartesian3();\nvar scratchOptions = {\n  minimum: scratchMin,\n  maximum: scratchMax,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {BoxOutlineGeometry} [result] The object into which to store the result.\n * @returns {BoxOutlineGeometry} The modified result parameter or a new BoxOutlineGeometry instance if one was not provided.\n */\nBoxOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var min = Cartesian3.unpack(array, startingIndex, scratchMin);\n  var max = Cartesian3.unpack(\n    array,\n    startingIndex + Cartesian3.packedLength,\n    scratchMax\n  );\n  var offsetAttribute = array[startingIndex + Cartesian3.packedLength * 2];\n\n  if (!defined(result)) {\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new BoxOutlineGeometry(scratchOptions);\n  }\n\n  result._min = Cartesian3.clone(min, result._min);\n  result._max = Cartesian3.clone(max, result._max);\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of a box, including its vertices, indices, and a bounding sphere.\n *\n * @param {BoxOutlineGeometry} boxGeometry A description of the box outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nBoxOutlineGeometry.createGeometry = function (boxGeometry) {\n  var min = boxGeometry._min;\n  var max = boxGeometry._max;\n\n  if (Cartesian3.equals(min, max)) {\n    return;\n  }\n\n  var attributes = new GeometryAttributes();\n  var indices = new Uint16Array(12 * 2);\n  var positions = new Float64Array(8 * 3);\n\n  positions[0] = min.x;\n  positions[1] = min.y;\n  positions[2] = min.z;\n  positions[3] = max.x;\n  positions[4] = min.y;\n  positions[5] = min.z;\n  positions[6] = max.x;\n  positions[7] = max.y;\n  positions[8] = min.z;\n  positions[9] = min.x;\n  positions[10] = max.y;\n  positions[11] = min.z;\n\n  positions[12] = min.x;\n  positions[13] = min.y;\n  positions[14] = max.z;\n  positions[15] = max.x;\n  positions[16] = min.y;\n  positions[17] = max.z;\n  positions[18] = max.x;\n  positions[19] = max.y;\n  positions[20] = max.z;\n  positions[21] = min.x;\n  positions[22] = max.y;\n  positions[23] = max.z;\n\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positions,\n  });\n\n  // top\n  indices[0] = 4;\n  indices[1] = 5;\n  indices[2] = 5;\n  indices[3] = 6;\n  indices[4] = 6;\n  indices[5] = 7;\n  indices[6] = 7;\n  indices[7] = 4;\n\n  // bottom\n  indices[8] = 0;\n  indices[9] = 1;\n  indices[10] = 1;\n  indices[11] = 2;\n  indices[12] = 2;\n  indices[13] = 3;\n  indices[14] = 3;\n  indices[15] = 0;\n\n  // left\n  indices[16] = 0;\n  indices[17] = 4;\n  indices[18] = 1;\n  indices[19] = 5;\n\n  //right\n  indices[20] = 2;\n  indices[21] = 6;\n  indices[22] = 3;\n  indices[23] = 7;\n\n  var diff = Cartesian3.subtract(max, min, diffScratch);\n  var radius = Cartesian3.magnitude(diff) * 0.5;\n\n  if (defined(boxGeometry._offsetAttribute)) {\n    var length = positions.length;\n    var applyOffset = new Uint8Array(length / 3);\n    var offsetValue =\n      boxGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n    arrayFill(applyOffset, offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: new BoundingSphere(Cartesian3.ZERO, radius),\n    offsetAttribute: boxGeometry._offsetAttribute,\n  });\n};\nexport default BoxOutlineGeometry;\n","import BoxOutlineGeometry from \"../Core/BoxOutlineGeometry.js\";\nimport defined from \"../Core/defined.js\";\n\nfunction createBoxOutlineGeometry(boxGeometry, offset) {\n  if (defined(offset)) {\n    boxGeometry = BoxOutlineGeometry.unpack(boxGeometry, offset);\n  }\n  return BoxOutlineGeometry.createGeometry(boxGeometry);\n}\nexport default createBoxOutlineGeometry;\n"],"names":["diffScratch","Cartesian3","BoxOutlineGeometry","options","min","defaultValue","EMPTY_OBJECT","minimum","max","maximum","Check","typeOf","object","defined","offsetAttribute","GeometryOffsetAttribute","TOP","DeveloperError","this","_min","clone","_max","_offsetAttribute","_workerName","fromDimensions","dimensions","number","greaterThanOrEquals","x","y","z","corner","multiplyByScalar","negate","fromAxisAlignedBoundingBox","boundingBox","packedLength","pack","value","array","startingIndex","scratchMin","scratchMax","scratchOptions","undefined","unpack","result","createGeometry","boxGeometry","equals","attributes","GeometryAttributes","indices","Uint16Array","positions","Float64Array","position","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","diff","subtract","radius","magnitude","length","applyOffset","Uint8Array","offsetValue","NONE","arrayFill","UNSIGNED_BYTE","Geometry","primitiveType","PrimitiveType","LINES","boundingSphere","BoundingSphere","ZERO","offset"],"mappings":"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"}