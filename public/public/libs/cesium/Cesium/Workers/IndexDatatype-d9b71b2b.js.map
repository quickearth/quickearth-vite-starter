{"version":3,"file":"IndexDatatype-d9b71b2b.js","sources":["../../../../Source/Core/IndexDatatype.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport WebGLConstants from \"./WebGLConstants.js\";\n\n/**\n * Constants for WebGL index datatypes.  These corresponds to the\n * <code>type</code> parameter of {@link http://www.khronos.org/opengles/sdk/docs/man/xhtml/glDrawElements.xml|drawElements}.\n *\n * @enum {Number}\n */\nvar IndexDatatype = {\n  /**\n   * 8-bit unsigned byte corresponding to <code>UNSIGNED_BYTE</code> and the type\n   * of an element in <code>Uint8Array</code>.\n   *\n   * @type {Number}\n   * @constant\n   */\n  UNSIGNED_BYTE: WebGLConstants.UNSIGNED_BYTE,\n\n  /**\n   * 16-bit unsigned short corresponding to <code>UNSIGNED_SHORT</code> and the type\n   * of an element in <code>Uint16Array</code>.\n   *\n   * @type {Number}\n   * @constant\n   */\n  UNSIGNED_SHORT: WebGLConstants.UNSIGNED_SHORT,\n\n  /**\n   * 32-bit unsigned int corresponding to <code>UNSIGNED_INT</code> and the type\n   * of an element in <code>Uint32Array</code>.\n   *\n   * @type {Number}\n   * @constant\n   */\n  UNSIGNED_INT: WebGLConstants.UNSIGNED_INT,\n};\n\n/**\n * Returns the size, in bytes, of the corresponding datatype.\n *\n * @param {IndexDatatype} indexDatatype The index datatype to get the size of.\n * @returns {Number} The size in bytes.\n *\n * @example\n * // Returns 2\n * var size = Cesium.IndexDatatype.getSizeInBytes(Cesium.IndexDatatype.UNSIGNED_SHORT);\n */\nIndexDatatype.getSizeInBytes = function (indexDatatype) {\n  switch (indexDatatype) {\n    case IndexDatatype.UNSIGNED_BYTE:\n      return Uint8Array.BYTES_PER_ELEMENT;\n    case IndexDatatype.UNSIGNED_SHORT:\n      return Uint16Array.BYTES_PER_ELEMENT;\n    case IndexDatatype.UNSIGNED_INT:\n      return Uint32Array.BYTES_PER_ELEMENT;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(\n    \"indexDatatype is required and must be a valid IndexDatatype constant.\"\n  );\n  //>>includeEnd('debug');\n};\n\n/**\n * Gets the datatype with a given size in bytes.\n *\n * @param {Number} sizeInBytes The size of a single index in bytes.\n * @returns {IndexDatatype} The index datatype with the given size.\n */\nIndexDatatype.fromSizeInBytes = function (sizeInBytes) {\n  switch (sizeInBytes) {\n    case 2:\n      return IndexDatatype.UNSIGNED_SHORT;\n    case 4:\n      return IndexDatatype.UNSIGNED_INT;\n    case 1:\n      return IndexDatatype.UNSIGNED_BYTE;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\n        \"Size in bytes cannot be mapped to an IndexDatatype\"\n      );\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Validates that the provided index datatype is a valid {@link IndexDatatype}.\n *\n * @param {IndexDatatype} indexDatatype The index datatype to validate.\n * @returns {Boolean} <code>true</code> if the provided index datatype is a valid value; otherwise, <code>false</code>.\n *\n * @example\n * if (!Cesium.IndexDatatype.validate(indexDatatype)) {\n *   throw new Cesium.DeveloperError('indexDatatype must be a valid value.');\n * }\n */\nIndexDatatype.validate = function (indexDatatype) {\n  return (\n    defined(indexDatatype) &&\n    (indexDatatype === IndexDatatype.UNSIGNED_BYTE ||\n      indexDatatype === IndexDatatype.UNSIGNED_SHORT ||\n      indexDatatype === IndexDatatype.UNSIGNED_INT)\n  );\n};\n\n/**\n * Creates a typed array that will store indices, using either <code><Uint16Array</code>\n * or <code>Uint32Array</code> depending on the number of vertices.\n *\n * @param {Number} numberOfVertices Number of vertices that the indices will reference.\n * @param {Number|Array} indicesLengthOrArray Passed through to the typed array constructor.\n * @returns {Uint16Array|Uint32Array} A <code>Uint16Array</code> or <code>Uint32Array</code> constructed with <code>indicesLengthOrArray</code>.\n *\n * @example\n * this.indices = Cesium.IndexDatatype.createTypedArray(positions.length / 3, numberOfIndices);\n */\nIndexDatatype.createTypedArray = function (\n  numberOfVertices,\n  indicesLengthOrArray\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(numberOfVertices)) {\n    throw new DeveloperError(\"numberOfVertices is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES) {\n    return new Uint32Array(indicesLengthOrArray);\n  }\n\n  return new Uint16Array(indicesLengthOrArray);\n};\n\n/**\n * Creates a typed array from a source array buffer.  The resulting typed array will store indices, using either <code><Uint16Array</code>\n * or <code>Uint32Array</code> depending on the number of vertices.\n *\n * @param {Number} numberOfVertices Number of vertices that the indices will reference.\n * @param {ArrayBuffer} sourceArray Passed through to the typed array constructor.\n * @param {Number} byteOffset Passed through to the typed array constructor.\n * @param {Number} length Passed through to the typed array constructor.\n * @returns {Uint16Array|Uint32Array} A <code>Uint16Array</code> or <code>Uint32Array</code> constructed with <code>sourceArray</code>, <code>byteOffset</code>, and <code>length</code>.\n *\n */\nIndexDatatype.createTypedArrayFromArrayBuffer = function (\n  numberOfVertices,\n  sourceArray,\n  byteOffset,\n  length\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(numberOfVertices)) {\n    throw new DeveloperError(\"numberOfVertices is required.\");\n  }\n  if (!defined(sourceArray)) {\n    throw new DeveloperError(\"sourceArray is required.\");\n  }\n  if (!defined(byteOffset)) {\n    throw new DeveloperError(\"byteOffset is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES) {\n    return new Uint32Array(sourceArray, byteOffset, length);\n  }\n\n  return new Uint16Array(sourceArray, byteOffset, length);\n};\nexport default Object.freeze(IndexDatatype);\n"],"names":["IndexDatatype","UNSIGNED_BYTE","WebGLConstants","UNSIGNED_SHORT","UNSIGNED_INT","getSizeInBytes","indexDatatype","Uint8Array","BYTES_PER_ELEMENT","Uint16Array","Uint32Array","DeveloperError","fromSizeInBytes","sizeInBytes","validate","defined","createTypedArray","numberOfVertices","indicesLengthOrArray","CesiumMath","SIXTY_FOUR_KILOBYTES","createTypedArrayFromArrayBuffer","sourceArray","byteOffset","length","Object","freeze"],"mappings":"uIAWA,IAAIA,EAAgB,CAQlBC,cAAeC,iBAAeD,cAS9BE,eAAgBD,iBAAeC,eAS/BC,aAAcF,iBAAeE,aAa/BC,eAA+B,SAAUC,GACvC,OAAQA,GACN,KAAKN,EAAcC,cACjB,OAAOM,WAAWC,kBACpB,KAAKR,EAAcG,eACjB,OAAOM,YAAYD,kBACrB,KAAKR,EAAcI,aACjB,OAAOM,YAAYF,kBAIvB,MAAM,IAAIG,iBACR,0EAWJC,gBAAgC,SAAUC,GACxC,OAAQA,GACN,KAAK,EACH,OAAOb,EAAcG,eACvB,KAAK,EACH,OAAOH,EAAcI,aACvB,KAAK,EACH,OAAOJ,EAAcC,cAEvB,QACE,MAAM,IAAIU,iBACR,wDAiBRG,SAAyB,SAAUR,GACjC,OACES,UAAQT,KACPA,IAAkBN,EAAcC,eAC/BK,IAAkBN,EAAcG,gBAChCG,IAAkBN,EAAcI,eAetCY,iBAAiC,SAC/BC,EACAC,GAGA,IAAKH,UAAQE,GACX,MAAM,IAAIN,iBAAe,iCAI3B,OACS,IADLM,GAAoBE,aAAWC,qBACtBV,YAGFD,aAHcS,IAiB3BG,gCAAgD,SAC9CJ,EACAK,EACAC,EACAC,GAGA,IAAKT,UAAQE,GACX,MAAM,IAAIN,iBAAe,iCAE3B,IAAKI,UAAQO,GACX,MAAM,IAAIX,iBAAe,4BAE3B,IAAKI,UAAQQ,GACX,MAAM,IAAIZ,iBAAe,2BAI3B,OACS,IADLM,GAAoBE,aAAWC,qBACtBV,YAGFD,aAHca,EAAaC,EAAYC,OAKrCC,OAAOC,OAAO1B"}