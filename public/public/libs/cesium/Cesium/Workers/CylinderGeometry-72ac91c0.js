define(["exports","./GeometryOffsetAttribute-6fce6185","./Transforms-b2c3e401","./Cartesian2-e9bb1bb3","./ComponentDatatype-b3120730","./CylinderGeometryLibrary-2189d3bf","./when-208fe5b0","./Check-5e798bbf","./GeometryAttribute-dddfbf98","./GeometryAttributes-b0b294d8","./IndexDatatype-4d4b60a0","./Math-56f06cd5","./VertexFormat-9eeda9f8"],function(e,L,P,k,M,z,N,u,I,U,S,q,f){"use strict";var B=new k.Cartesian2,Y=new k.Cartesian3,Z=new k.Cartesian3,J=new k.Cartesian3,W=new k.Cartesian3;function d(e){var t=(e=N.defaultValue(e,N.defaultValue.EMPTY_OBJECT)).length,r=e.topRadius,o=e.bottomRadius,a=N.defaultValue(e.vertexFormat,f.VertexFormat.DEFAULT),n=N.defaultValue(e.slices,128);if(!N.defined(t))throw new u.DeveloperError("options.length must be defined.");if(!N.defined(r))throw new u.DeveloperError("options.topRadius must be defined.");if(!N.defined(o))throw new u.DeveloperError("options.bottomRadius must be defined.");if(n<3)throw new u.DeveloperError("options.slices must be greater than or equal to 3.");if(N.defined(e.offsetAttribute)&&e.offsetAttribute===L.GeometryOffsetAttribute.TOP)throw new u.DeveloperError("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._length=t,this._topRadius=r,this._bottomRadius=o,this._vertexFormat=f.VertexFormat.clone(a),this._slices=n,this._offsetAttribute=e.offsetAttribute,this._workerName="createCylinderGeometry"}d.packedLength=f.VertexFormat.packedLength+5,d.pack=function(e,t,r){if(!N.defined(e))throw new u.DeveloperError("value is required");if(!N.defined(t))throw new u.DeveloperError("array is required");return r=N.defaultValue(r,0),f.VertexFormat.pack(e._vertexFormat,t,r),r+=f.VertexFormat.packedLength,t[r++]=e._length,t[r++]=e._topRadius,t[r++]=e._bottomRadius,t[r++]=e._slices,t[r]=N.defaultValue(e._offsetAttribute,-1),t};var t,m=new f.VertexFormat,p={vertexFormat:m,length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,offsetAttribute:void 0};d.unpack=function(e,t,r){if(!N.defined(e))throw new u.DeveloperError("array is required");t=N.defaultValue(t,0);var o=f.VertexFormat.unpack(e,t,m);t+=f.VertexFormat.packedLength;var a=e[t++],n=e[t++],i=e[t++],s=e[t++],t=e[t];return N.defined(r)?(r._vertexFormat=f.VertexFormat.clone(o,r._vertexFormat),r._length=a,r._topRadius=n,r._bottomRadius=i,r._slices=s,r._offsetAttribute=-1===t?void 0:t,r):(p.length=a,p.topRadius=n,p.bottomRadius=i,p.slices=s,p.offsetAttribute=-1===t?void 0:t,new d(p))},d.createGeometry=function(e){var t=e._length,r=e._topRadius,o=e._bottomRadius,a=e._vertexFormat,n=e._slices;if(!(t<=0||r<0||o<0||0===r&&0===o)){var i=n+n,s=n+i,u=i+i,f=z.CylinderGeometryLibrary.computePositions(t,r,o,n,!0),d=a.st?new Float32Array(2*u):void 0,m=a.normal?new Float32Array(3*u):void 0,p=a.tangent?new Float32Array(3*u):void 0,b=a.bitangent?new Float32Array(3*u):void 0,l=a.normal||a.tangent||a.bitangent;if(l){var y=a.tangent||a.bitangent,c=0,v=0,A=0,h=Math.atan2(o-r,t),w=Y;w.z=Math.sin(h);for(var g=Math.cos(h),x=J,_=Z,C=0;C<n;C++){var F=C/n*q.CesiumMath.TWO_PI,D=g*Math.cos(F),F=g*Math.sin(F);l&&(w.x=D,w.y=F,y&&(x=k.Cartesian3.normalize(k.Cartesian3.cross(k.Cartesian3.UNIT_Z,w,x),x)),a.normal&&(m[c++]=w.x,m[c++]=w.y,m[c++]=w.z,m[c++]=w.x,m[c++]=w.y,m[c++]=w.z),a.tangent&&(p[v++]=x.x,p[v++]=x.y,p[v++]=x.z,p[v++]=x.x,p[v++]=x.y,p[v++]=x.z),a.bitangent&&(_=k.Cartesian3.normalize(k.Cartesian3.cross(w,x,_),_),b[A++]=_.x,b[A++]=_.y,b[A++]=_.z,b[A++]=_.x,b[A++]=_.y,b[A++]=_.z))}for(C=0;C<n;C++)a.normal&&(m[c++]=0,m[c++]=0,m[c++]=-1),a.tangent&&(p[v++]=1,p[v++]=0,p[v++]=0),a.bitangent&&(b[A++]=0,b[A++]=-1,b[A++]=0);for(C=0;C<n;C++)a.normal&&(m[c++]=0,m[c++]=0,m[c++]=1),a.tangent&&(p[v++]=1,p[v++]=0,p[v++]=0),a.bitangent&&(b[A++]=0,b[A++]=1,b[A++]=0)}var G=S.IndexDatatype.createTypedArray(u,12*n-12),R=0,O=0;for(C=0;C<n-1;C++)G[R++]=O,G[R++]=O+2,G[R++]=O+3,G[R++]=O,G[R++]=O+3,G[R++]=O+1,O+=2;for(G[R++]=i-2,G[R++]=0,G[R++]=1,G[R++]=i-2,G[R++]=1,G[R++]=i-1,C=1;C<n-1;C++)G[R++]=i+C+1,G[R++]=i+C,G[R++]=i;for(C=1;C<n-1;C++)G[R++]=s,G[R++]=s+C,G[R++]=s+C+1;var T=0;if(a.st){var V=Math.max(r,o);for(C=0;C<u;C++){var E=k.Cartesian3.fromArray(f,3*C,W);d[T++]=(E.x+V)/(2*V),d[T++]=(E.y+V)/(2*V)}}h=new U.GeometryAttributes;a.position&&(h.position=new I.GeometryAttribute({componentDatatype:M.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:f})),a.normal&&(h.normal=new I.GeometryAttribute({componentDatatype:M.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:m})),a.tangent&&(h.tangent=new I.GeometryAttribute({componentDatatype:M.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:p})),a.bitangent&&(h.bitangent=new I.GeometryAttribute({componentDatatype:M.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:b})),a.st&&(h.st=new I.GeometryAttribute({componentDatatype:M.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:d})),B.x=.5*t,B.y=Math.max(o,r);o=new P.BoundingSphere(k.Cartesian3.ZERO,k.Cartesian2.magnitude(B));return N.defined(e._offsetAttribute)&&(t=f.length,r=new Uint8Array(t/3),t=e._offsetAttribute===L.GeometryOffsetAttribute.NONE?0:1,L.arrayFill(r,t),h.applyOffset=new I.GeometryAttribute({componentDatatype:M.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})),new I.Geometry({attributes:h,indices:G,primitiveType:I.PrimitiveType.TRIANGLES,boundingSphere:o,offsetAttribute:e._offsetAttribute})}},d.getUnitCylinder=function(){return t=!N.defined(t)?d.createGeometry(new d({topRadius:1,bottomRadius:1,length:1,vertexFormat:f.VertexFormat.POSITION_ONLY})):t},e.CylinderGeometry=d});
//# sourceMappingURL=CylinderGeometry-72ac91c0.js.map
