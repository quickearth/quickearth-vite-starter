define(["exports","./GeometryOffsetAttribute-d63c288d","./Transforms-f1816abc","./Cartesian2-716c2715","./ComponentDatatype-549ec0d3","./CylinderGeometryLibrary-dc335e31","./when-208fe5b0","./Check-d18af7c4","./GeometryAttribute-0ee94cf1","./GeometryAttributes-b0b294d8","./IndexDatatype-d9b71b2b","./Math-3ba16bed","./VertexFormat-24041ad5"],function(t,L,P,k,M,z,N,u,I,U,S,q,d){"use strict";var B=new k.Cartesian2,Y=new k.Cartesian3,Z=new k.Cartesian3,J=new k.Cartesian3,W=new k.Cartesian3;function m(t){var e=(t=N.defaultValue(t,N.defaultValue.EMPTY_OBJECT)).length,r=t.topRadius,o=t.bottomRadius,a=N.defaultValue(t.vertexFormat,d.VertexFormat.DEFAULT),n=N.defaultValue(t.slices,128);if(!N.defined(e))throw new u.DeveloperError("options.length must be defined.");if(!N.defined(r))throw new u.DeveloperError("options.topRadius must be defined.");if(!N.defined(o))throw new u.DeveloperError("options.bottomRadius must be defined.");if(n<3)throw new u.DeveloperError("options.slices must be greater than or equal to 3.");if(N.defined(t.offsetAttribute)&&t.offsetAttribute===L.GeometryOffsetAttribute.TOP)throw new u.DeveloperError("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._length=e,this._topRadius=r,this._bottomRadius=o,this._vertexFormat=d.VertexFormat.clone(a),this._slices=n,this._offsetAttribute=t.offsetAttribute,this._workerName="createCylinderGeometry"}m.packedLength=d.VertexFormat.packedLength+5,m.pack=function(t,e,r){if(!N.defined(t))throw new u.DeveloperError("value is required");if(!N.defined(e))throw new u.DeveloperError("array is required");return r=N.defaultValue(r,0),d.VertexFormat.pack(t._vertexFormat,e,r),r+=d.VertexFormat.packedLength,e[r++]=t._length,e[r++]=t._topRadius,e[r++]=t._bottomRadius,e[r++]=t._slices,e[r]=N.defaultValue(t._offsetAttribute,-1),e};var e,f=new d.VertexFormat,p={vertexFormat:f,length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,offsetAttribute:void 0};m.unpack=function(t,e,r){if(!N.defined(t))throw new u.DeveloperError("array is required");e=N.defaultValue(e,0);var o=d.VertexFormat.unpack(t,e,f);e+=d.VertexFormat.packedLength;var a=t[e++],n=t[e++],i=t[e++],s=t[e++],e=t[e];return N.defined(r)?(r._vertexFormat=d.VertexFormat.clone(o,r._vertexFormat),r._length=a,r._topRadius=n,r._bottomRadius=i,r._slices=s,r._offsetAttribute=-1===e?void 0:e,r):(p.length=a,p.topRadius=n,p.bottomRadius=i,p.slices=s,p.offsetAttribute=-1===e?void 0:e,new m(p))},m.createGeometry=function(t){var e=t._length,r=t._topRadius,o=t._bottomRadius,a=t._vertexFormat,n=t._slices;if(!(e<=0||r<0||o<0||0===r&&0===o)){var i=n+n,s=n+i,u=i+i,d=z.CylinderGeometryLibrary.computePositions(e,r,o,n,!0),m=a.st?new Float32Array(2*u):void 0,f=a.normal?new Float32Array(3*u):void 0,p=a.tangent?new Float32Array(3*u):void 0,l=a.bitangent?new Float32Array(3*u):void 0,b=a.normal||a.tangent||a.bitangent;if(b){var y=a.tangent||a.bitangent,c=0,v=0,A=0,h=Math.atan2(o-r,e),w=Y;w.z=Math.sin(h);for(var g=Math.cos(h),x=J,_=Z,C=0;C<n;C++){var F=C/n*q.CesiumMath.TWO_PI,D=g*Math.cos(F),F=g*Math.sin(F);b&&(w.x=D,w.y=F,y&&(x=k.Cartesian3.normalize(k.Cartesian3.cross(k.Cartesian3.UNIT_Z,w,x),x)),a.normal&&(f[c++]=w.x,f[c++]=w.y,f[c++]=w.z,f[c++]=w.x,f[c++]=w.y,f[c++]=w.z),a.tangent&&(p[v++]=x.x,p[v++]=x.y,p[v++]=x.z,p[v++]=x.x,p[v++]=x.y,p[v++]=x.z),a.bitangent&&(_=k.Cartesian3.normalize(k.Cartesian3.cross(w,x,_),_),l[A++]=_.x,l[A++]=_.y,l[A++]=_.z,l[A++]=_.x,l[A++]=_.y,l[A++]=_.z))}for(C=0;C<n;C++)a.normal&&(f[c++]=0,f[c++]=0,f[c++]=-1),a.tangent&&(p[v++]=1,p[v++]=0,p[v++]=0),a.bitangent&&(l[A++]=0,l[A++]=-1,l[A++]=0);for(C=0;C<n;C++)a.normal&&(f[c++]=0,f[c++]=0,f[c++]=1),a.tangent&&(p[v++]=1,p[v++]=0,p[v++]=0),a.bitangent&&(l[A++]=0,l[A++]=1,l[A++]=0)}var G=S.IndexDatatype.createTypedArray(u,12*n-12),R=0,O=0;for(C=0;C<n-1;C++)G[R++]=O,G[R++]=O+2,G[R++]=O+3,G[R++]=O,G[R++]=O+3,G[R++]=O+1,O+=2;for(G[R++]=i-2,G[R++]=0,G[R++]=1,G[R++]=i-2,G[R++]=1,G[R++]=i-1,C=1;C<n-1;C++)G[R++]=i+C+1,G[R++]=i+C,G[R++]=i;for(C=1;C<n-1;C++)G[R++]=s,G[R++]=s+C,G[R++]=s+C+1;var T=0;if(a.st){var V=Math.max(r,o);for(C=0;C<u;C++){var E=k.Cartesian3.fromArray(d,3*C,W);m[T++]=(E.x+V)/(2*V),m[T++]=(E.y+V)/(2*V)}}h=new U.GeometryAttributes;a.position&&(h.position=new I.GeometryAttribute({componentDatatype:M.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:d})),a.normal&&(h.normal=new I.GeometryAttribute({componentDatatype:M.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:f})),a.tangent&&(h.tangent=new I.GeometryAttribute({componentDatatype:M.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:p})),a.bitangent&&(h.bitangent=new I.GeometryAttribute({componentDatatype:M.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:l})),a.st&&(h.st=new I.GeometryAttribute({componentDatatype:M.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:m})),B.x=.5*e,B.y=Math.max(o,r);o=new P.BoundingSphere(k.Cartesian3.ZERO,k.Cartesian2.magnitude(B));return N.defined(t._offsetAttribute)&&(e=d.length,r=new Uint8Array(e/3),e=t._offsetAttribute===L.GeometryOffsetAttribute.NONE?0:1,L.arrayFill(r,e),h.applyOffset=new I.GeometryAttribute({componentDatatype:M.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})),new I.Geometry({attributes:h,indices:G,primitiveType:I.PrimitiveType.TRIANGLES,boundingSphere:o,offsetAttribute:t._offsetAttribute})}},m.getUnitCylinder=function(){return e=!N.defined(e)?m.createGeometry(new m({topRadius:1,bottomRadius:1,length:1,vertexFormat:d.VertexFormat.POSITION_ONLY})):e},t.CylinderGeometry=m});
//# sourceMappingURL=CylinderGeometry-c2bdf3e4.js.map
