{"version":3,"file":"createVectorTileGeometries.js","sources":["../../../../Source/Scene/Vector3DTileBatch.js","../../../../Source/WorkersES6/createVectorTileGeometries.js"],"sourcesContent":["/**\n * Describes a renderable batch of geometry.\n *\n * @alias Vector3DTileBatch\n * @constructor\n *\n * @param {Object} options An object with the following properties:\n * @param {Number} options.offset The offset of the batch into the indices buffer.\n * @param {Number} options.count The number of indices in the batch.\n * @param {Color} options.color The color of the geometry in the batch.\n * @param {Number[]} options.batchIds An array where each element is the batch id of the geometry in the batch.\n *\n * @private\n */\nfunction Vector3DTileBatch(options) {\n  /**\n   * The offset of the batch into the indices buffer.\n   * @type {Number}\n   */\n  this.offset = options.offset;\n  /**\n   * The number of indices in the batch.\n   * @type {Number}\n   */\n  this.count = options.count;\n  /**\n   * The color of the geometry in the batch.\n   * @type {Color}\n   */\n  this.color = options.color;\n  /**\n   * An array where each element is the batch id of the geometry in the batch.\n   * @type {Number[]}\n   */\n  this.batchIds = options.batchIds;\n}\nexport default Vector3DTileBatch;\n","import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport BoxGeometry from \"../Core/BoxGeometry.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport CylinderGeometry from \"../Core/CylinderGeometry.js\";\nimport defined from \"../Core/defined.js\";\nimport EllipsoidGeometry from \"../Core/EllipsoidGeometry.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Vector3DTileBatch from \"../Scene/Vector3DTileBatch.js\";\nimport createTaskProcessorWorker from \"./createTaskProcessorWorker.js\";\n\nvar scratchCartesian = new Cartesian3();\n\nvar packedBoxLength = Matrix4.packedLength + Cartesian3.packedLength;\nvar packedCylinderLength = Matrix4.packedLength + 2;\nvar packedEllipsoidLength = Matrix4.packedLength + Cartesian3.packedLength;\nvar packedSphereLength = Cartesian3.packedLength + 1;\n\nvar scratchModelMatrixAndBV = {\n  modelMatrix: new Matrix4(),\n  boundingVolume: new BoundingSphere(),\n};\n\nfunction boxModelMatrixAndBoundingVolume(boxes, index) {\n  var boxIndex = index * packedBoxLength;\n\n  var dimensions = Cartesian3.unpack(boxes, boxIndex, scratchCartesian);\n  boxIndex += Cartesian3.packedLength;\n\n  var boxModelMatrix = Matrix4.unpack(\n    boxes,\n    boxIndex,\n    scratchModelMatrixAndBV.modelMatrix\n  );\n  Matrix4.multiplyByScale(boxModelMatrix, dimensions, boxModelMatrix);\n\n  var boundingVolume = scratchModelMatrixAndBV.boundingVolume;\n  Cartesian3.clone(Cartesian3.ZERO, boundingVolume.center);\n  boundingVolume.radius = Math.sqrt(3.0);\n\n  return scratchModelMatrixAndBV;\n}\n\nfunction cylinderModelMatrixAndBoundingVolume(cylinders, index) {\n  var cylinderIndex = index * packedCylinderLength;\n\n  var cylinderRadius = cylinders[cylinderIndex++];\n  var length = cylinders[cylinderIndex++];\n  var scale = Cartesian3.fromElements(\n    cylinderRadius,\n    cylinderRadius,\n    length,\n    scratchCartesian\n  );\n\n  var cylinderModelMatrix = Matrix4.unpack(\n    cylinders,\n    cylinderIndex,\n    scratchModelMatrixAndBV.modelMatrix\n  );\n  Matrix4.multiplyByScale(cylinderModelMatrix, scale, cylinderModelMatrix);\n\n  var boundingVolume = scratchModelMatrixAndBV.boundingVolume;\n  Cartesian3.clone(Cartesian3.ZERO, boundingVolume.center);\n  boundingVolume.radius = Math.sqrt(2.0);\n\n  return scratchModelMatrixAndBV;\n}\n\nfunction ellipsoidModelMatrixAndBoundingVolume(ellipsoids, index) {\n  var ellipsoidIndex = index * packedEllipsoidLength;\n\n  var radii = Cartesian3.unpack(ellipsoids, ellipsoidIndex, scratchCartesian);\n  ellipsoidIndex += Cartesian3.packedLength;\n\n  var ellipsoidModelMatrix = Matrix4.unpack(\n    ellipsoids,\n    ellipsoidIndex,\n    scratchModelMatrixAndBV.modelMatrix\n  );\n  Matrix4.multiplyByScale(ellipsoidModelMatrix, radii, ellipsoidModelMatrix);\n\n  var boundingVolume = scratchModelMatrixAndBV.boundingVolume;\n  Cartesian3.clone(Cartesian3.ZERO, boundingVolume.center);\n  boundingVolume.radius = 1.0;\n\n  return scratchModelMatrixAndBV;\n}\n\nfunction sphereModelMatrixAndBoundingVolume(spheres, index) {\n  var sphereIndex = index * packedSphereLength;\n\n  var sphereRadius = spheres[sphereIndex++];\n\n  var sphereTranslation = Cartesian3.unpack(\n    spheres,\n    sphereIndex,\n    scratchCartesian\n  );\n  var sphereModelMatrix = Matrix4.fromTranslation(\n    sphereTranslation,\n    scratchModelMatrixAndBV.modelMatrix\n  );\n  Matrix4.multiplyByUniformScale(\n    sphereModelMatrix,\n    sphereRadius,\n    sphereModelMatrix\n  );\n\n  var boundingVolume = scratchModelMatrixAndBV.boundingVolume;\n  Cartesian3.clone(Cartesian3.ZERO, boundingVolume.center);\n  boundingVolume.radius = 1.0;\n\n  return scratchModelMatrixAndBV;\n}\n\nvar scratchPosition = new Cartesian3();\n\nfunction createPrimitive(\n  options,\n  primitive,\n  primitiveBatchIds,\n  geometry,\n  getModelMatrixAndBoundingVolume\n) {\n  if (!defined(primitive)) {\n    return;\n  }\n\n  var numberOfPrimitives = primitiveBatchIds.length;\n  var geometryPositions = geometry.attributes.position.values;\n  var geometryIndices = geometry.indices;\n\n  var positions = options.positions;\n  var vertexBatchIds = options.vertexBatchIds;\n  var indices = options.indices;\n\n  var batchIds = options.batchIds;\n  var batchTableColors = options.batchTableColors;\n  var batchedIndices = options.batchedIndices;\n  var indexOffsets = options.indexOffsets;\n  var indexCounts = options.indexCounts;\n  var boundingVolumes = options.boundingVolumes;\n\n  var modelMatrix = options.modelMatrix;\n  var center = options.center;\n\n  var positionOffset = options.positionOffset;\n  var batchIdIndex = options.batchIdIndex;\n  var indexOffset = options.indexOffset;\n  var batchedIndicesOffset = options.batchedIndicesOffset;\n\n  for (var i = 0; i < numberOfPrimitives; ++i) {\n    var primitiveModelMatrixAndBV = getModelMatrixAndBoundingVolume(\n      primitive,\n      i\n    );\n    var primitiveModelMatrix = primitiveModelMatrixAndBV.modelMatrix;\n    Matrix4.multiply(modelMatrix, primitiveModelMatrix, primitiveModelMatrix);\n\n    var batchId = primitiveBatchIds[i];\n\n    var positionsLength = geometryPositions.length;\n    for (var j = 0; j < positionsLength; j += 3) {\n      var position = Cartesian3.unpack(geometryPositions, j, scratchPosition);\n      Matrix4.multiplyByPoint(primitiveModelMatrix, position, position);\n      Cartesian3.subtract(position, center, position);\n\n      Cartesian3.pack(position, positions, positionOffset * 3 + j);\n      vertexBatchIds[batchIdIndex++] = batchId;\n    }\n\n    var indicesLength = geometryIndices.length;\n    for (var k = 0; k < indicesLength; ++k) {\n      indices[indexOffset + k] = geometryIndices[k] + positionOffset;\n    }\n\n    var offset = i + batchedIndicesOffset;\n    batchedIndices[offset] = new Vector3DTileBatch({\n      offset: indexOffset,\n      count: indicesLength,\n      color: Color.fromRgba(batchTableColors[batchId]),\n      batchIds: [batchId],\n    });\n    batchIds[offset] = batchId;\n    indexOffsets[offset] = indexOffset;\n    indexCounts[offset] = indicesLength;\n    boundingVolumes[offset] = BoundingSphere.transform(\n      primitiveModelMatrixAndBV.boundingVolume,\n      primitiveModelMatrix\n    );\n\n    positionOffset += positionsLength / 3;\n    indexOffset += indicesLength;\n  }\n\n  options.positionOffset = positionOffset;\n  options.batchIdIndex = batchIdIndex;\n  options.indexOffset = indexOffset;\n  options.batchedIndicesOffset += numberOfPrimitives;\n}\n\nvar scratchCenter = new Cartesian3();\nvar scratchMatrix4 = new Matrix4();\n\nfunction unpackBuffer(buffer) {\n  var packedBuffer = new Float64Array(buffer);\n\n  var offset = 0;\n  Cartesian3.unpack(packedBuffer, offset, scratchCenter);\n  offset += Cartesian3.packedLength;\n\n  Matrix4.unpack(packedBuffer, offset, scratchMatrix4);\n}\n\nfunction packedBatchedIndicesLength(batchedIndices) {\n  var length = batchedIndices.length;\n  var count = 0;\n  for (var i = 0; i < length; ++i) {\n    count += Color.packedLength + 3 + batchedIndices[i].batchIds.length;\n  }\n  return count;\n}\n\nfunction packBuffer(indicesBytesPerElement, batchedIndices, boundingVolumes) {\n  var numBVs = boundingVolumes.length;\n  var length =\n    1 +\n    1 +\n    numBVs * BoundingSphere.packedLength +\n    1 +\n    packedBatchedIndicesLength(batchedIndices);\n\n  var packedBuffer = new Float64Array(length);\n\n  var offset = 0;\n  packedBuffer[offset++] = indicesBytesPerElement;\n  packedBuffer[offset++] = numBVs;\n\n  for (var i = 0; i < numBVs; ++i) {\n    BoundingSphere.pack(boundingVolumes[i], packedBuffer, offset);\n    offset += BoundingSphere.packedLength;\n  }\n\n  var indicesLength = batchedIndices.length;\n  packedBuffer[offset++] = indicesLength;\n\n  for (var j = 0; j < indicesLength; ++j) {\n    var batchedIndex = batchedIndices[j];\n\n    Color.pack(batchedIndex.color, packedBuffer, offset);\n    offset += Color.packedLength;\n\n    packedBuffer[offset++] = batchedIndex.offset;\n    packedBuffer[offset++] = batchedIndex.count;\n\n    var batchIds = batchedIndex.batchIds;\n    var batchIdsLength = batchIds.length;\n    packedBuffer[offset++] = batchIdsLength;\n\n    for (var k = 0; k < batchIdsLength; ++k) {\n      packedBuffer[offset++] = batchIds[k];\n    }\n  }\n\n  return packedBuffer;\n}\n\nfunction createVectorTileGeometries(parameters, transferableObjects) {\n  var boxes = defined(parameters.boxes)\n    ? new Float32Array(parameters.boxes)\n    : undefined;\n  var boxBatchIds = defined(parameters.boxBatchIds)\n    ? new Uint16Array(parameters.boxBatchIds)\n    : undefined;\n  var cylinders = defined(parameters.cylinders)\n    ? new Float32Array(parameters.cylinders)\n    : undefined;\n  var cylinderBatchIds = defined(parameters.cylinderBatchIds)\n    ? new Uint16Array(parameters.cylinderBatchIds)\n    : undefined;\n  var ellipsoids = defined(parameters.ellipsoids)\n    ? new Float32Array(parameters.ellipsoids)\n    : undefined;\n  var ellipsoidBatchIds = defined(parameters.ellipsoidBatchIds)\n    ? new Uint16Array(parameters.ellipsoidBatchIds)\n    : undefined;\n  var spheres = defined(parameters.spheres)\n    ? new Float32Array(parameters.spheres)\n    : undefined;\n  var sphereBatchIds = defined(parameters.sphereBatchIds)\n    ? new Uint16Array(parameters.sphereBatchIds)\n    : undefined;\n\n  var numberOfBoxes = defined(boxes) ? boxBatchIds.length : 0;\n  var numberOfCylinders = defined(cylinders) ? cylinderBatchIds.length : 0;\n  var numberOfEllipsoids = defined(ellipsoids) ? ellipsoidBatchIds.length : 0;\n  var numberOfSpheres = defined(spheres) ? sphereBatchIds.length : 0;\n\n  var boxGeometry = BoxGeometry.getUnitBox();\n  var cylinderGeometry = CylinderGeometry.getUnitCylinder();\n  var ellipsoidGeometry = EllipsoidGeometry.getUnitEllipsoid();\n\n  var boxPositions = boxGeometry.attributes.position.values;\n  var cylinderPositions = cylinderGeometry.attributes.position.values;\n  var ellipsoidPositions = ellipsoidGeometry.attributes.position.values;\n\n  var numberOfPositions = boxPositions.length * numberOfBoxes;\n  numberOfPositions += cylinderPositions.length * numberOfCylinders;\n  numberOfPositions +=\n    ellipsoidPositions.length * (numberOfEllipsoids + numberOfSpheres);\n\n  var boxIndices = boxGeometry.indices;\n  var cylinderIndices = cylinderGeometry.indices;\n  var ellipsoidIndices = ellipsoidGeometry.indices;\n\n  var numberOfIndices = boxIndices.length * numberOfBoxes;\n  numberOfIndices += cylinderIndices.length * numberOfCylinders;\n  numberOfIndices +=\n    ellipsoidIndices.length * (numberOfEllipsoids + numberOfSpheres);\n\n  var positions = new Float32Array(numberOfPositions);\n  var vertexBatchIds = new Uint16Array(numberOfPositions / 3);\n  var indices = IndexDatatype.createTypedArray(\n    numberOfPositions / 3,\n    numberOfIndices\n  );\n\n  var numberOfGeometries =\n    numberOfBoxes + numberOfCylinders + numberOfEllipsoids + numberOfSpheres;\n  var batchIds = new Uint16Array(numberOfGeometries);\n  var batchedIndices = new Array(numberOfGeometries);\n  var indexOffsets = new Uint32Array(numberOfGeometries);\n  var indexCounts = new Uint32Array(numberOfGeometries);\n  var boundingVolumes = new Array(numberOfGeometries);\n\n  unpackBuffer(parameters.packedBuffer);\n\n  var options = {\n    batchTableColors: new Uint32Array(parameters.batchTableColors),\n    positions: positions,\n    vertexBatchIds: vertexBatchIds,\n    indices: indices,\n    batchIds: batchIds,\n    batchedIndices: batchedIndices,\n    indexOffsets: indexOffsets,\n    indexCounts: indexCounts,\n    boundingVolumes: boundingVolumes,\n    positionOffset: 0,\n    batchIdIndex: 0,\n    indexOffset: 0,\n    batchedIndicesOffset: 0,\n    modelMatrix: scratchMatrix4,\n    center: scratchCenter,\n  };\n\n  createPrimitive(\n    options,\n    boxes,\n    boxBatchIds,\n    boxGeometry,\n    boxModelMatrixAndBoundingVolume\n  );\n  createPrimitive(\n    options,\n    cylinders,\n    cylinderBatchIds,\n    cylinderGeometry,\n    cylinderModelMatrixAndBoundingVolume\n  );\n  createPrimitive(\n    options,\n    ellipsoids,\n    ellipsoidBatchIds,\n    ellipsoidGeometry,\n    ellipsoidModelMatrixAndBoundingVolume\n  );\n  createPrimitive(\n    options,\n    spheres,\n    sphereBatchIds,\n    ellipsoidGeometry,\n    sphereModelMatrixAndBoundingVolume\n  );\n\n  var packedBuffer = packBuffer(\n    indices.BYTES_PER_ELEMENT,\n    batchedIndices,\n    boundingVolumes\n  );\n  transferableObjects.push(\n    positions.buffer,\n    vertexBatchIds.buffer,\n    indices.buffer\n  );\n  transferableObjects.push(\n    batchIds.buffer,\n    indexOffsets.buffer,\n    indexCounts.buffer\n  );\n  transferableObjects.push(packedBuffer.buffer);\n\n  return {\n    positions: positions.buffer,\n    vertexBatchIds: vertexBatchIds.buffer,\n    indices: indices.buffer,\n    indexOffsets: indexOffsets.buffer,\n    indexCounts: indexCounts.buffer,\n    batchIds: batchIds.buffer,\n    packedBuffer: packedBuffer.buffer,\n  };\n}\nexport default createTaskProcessorWorker(createVectorTileGeometries);\n"],"names":["Vector3DTileBatch","options","this","offset","count","color","batchIds","scratchCartesian","Cartesian3","packedBoxLength","Matrix4","packedLength","packedCylinderLength","packedEllipsoidLength","packedSphereLength","scratchModelMatrixAndBV","modelMatrix","boundingVolume","BoundingSphere","boxModelMatrixAndBoundingVolume","boxes","index","boxIndex","dimensions","unpack","boxModelMatrix","multiplyByScale","clone","ZERO","center","radius","Math","sqrt","cylinderModelMatrixAndBoundingVolume","cylinders","cylinderIndex","cylinderRadius","length","scale","fromElements","cylinderModelMatrix","ellipsoidModelMatrixAndBoundingVolume","ellipsoids","ellipsoidIndex","radii","ellipsoidModelMatrix","sphereModelMatrixAndBoundingVolume","spheres","sphereIndex","sphereRadius","sphereTranslation","sphereModelMatrix","fromTranslation","multiplyByUniformScale","scratchPosition","createPrimitive","primitive","primitiveBatchIds","geometry","getModelMatrixAndBoundingVolume","defined","numberOfPrimitives","geometryPositions","attributes","position","values","geometryIndices","indices","positions","vertexBatchIds","batchTableColors","batchedIndices","indexOffsets","indexCounts","boundingVolumes","positionOffset","batchIdIndex","indexOffset","batchedIndicesOffset","i","primitiveModelMatrixAndBV","primitiveModelMatrix","multiply","batchId","positionsLength","j","multiplyByPoint","subtract","pack","indicesLength","k","Color","fromRgba","transform","scratchCenter","scratchMatrix4","packBuffer","indicesBytesPerElement","numBVs","packedBatchedIndicesLength","packedBuffer","Float64Array","batchedIndex","batchIdsLength","createTaskProcessorWorker","parameters","transferableObjects","Float32Array","undefined","boxBatchIds","Uint16Array","cylinderBatchIds","ellipsoidBatchIds","sphereBatchIds","numberOfBoxes","numberOfCylinders","numberOfEllipsoids","numberOfSpheres","boxGeometry","BoxGeometry","getUnitBox","cylinderGeometry","CylinderGeometry","getUnitCylinder","ellipsoidGeometry","EllipsoidGeometry","getUnitEllipsoid","boxPositions","cylinderPositions","ellipsoidPositions","numberOfPositions","boxIndices","cylinderIndices","ellipsoidIndices","numberOfIndices","IndexDatatype","createTypedArray","numberOfGeometries","Array","Uint32Array","buffer","BYTES_PER_ELEMENT","push"],"mappings":"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"}