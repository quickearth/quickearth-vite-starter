{"version":3,"file":"createVectorTileClampedPolylines.js","sources":["../../../../Source/WorkersES6/createVectorTileClampedPolylines.js"],"sourcesContent":["import AttributeCompression from \"../Core/AttributeCompression.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport createTaskProcessorWorker from \"./createTaskProcessorWorker.js\";\n\nvar MAX_SHORT = 32767;\nvar MITER_BREAK = Math.cos(CesiumMath.toRadians(150.0));\n\nvar scratchBVCartographic = new Cartographic();\nvar scratchEncodedPosition = new Cartesian3();\n\nfunction decodePositionsToRtc(\n  uBuffer,\n  vBuffer,\n  heightBuffer,\n  rectangle,\n  minimumHeight,\n  maximumHeight,\n  ellipsoid,\n  center\n) {\n  var positionsLength = uBuffer.length;\n  var decodedPositions = new Float32Array(positionsLength * 3);\n  for (var i = 0; i < positionsLength; ++i) {\n    var u = uBuffer[i];\n    var v = vBuffer[i];\n    var h = heightBuffer[i];\n\n    var lon = CesiumMath.lerp(rectangle.west, rectangle.east, u / MAX_SHORT);\n    var lat = CesiumMath.lerp(rectangle.south, rectangle.north, v / MAX_SHORT);\n    var alt = CesiumMath.lerp(minimumHeight, maximumHeight, h / MAX_SHORT);\n\n    var cartographic = Cartographic.fromRadians(\n      lon,\n      lat,\n      alt,\n      scratchBVCartographic\n    );\n    var decodedPosition = ellipsoid.cartographicToCartesian(\n      cartographic,\n      scratchEncodedPosition\n    );\n    var rtc = Cartesian3.subtract(\n      decodedPosition,\n      center,\n      scratchEncodedPosition\n    );\n    Cartesian3.pack(rtc, decodedPositions, i * 3);\n  }\n  return decodedPositions;\n}\n\nvar previousCompressedCartographicScratch = new Cartographic();\nvar currentCompressedCartographicScratch = new Cartographic();\nfunction removeDuplicates(uBuffer, vBuffer, heightBuffer, counts) {\n  var countsLength = counts.length;\n  var positionsLength = uBuffer.length;\n  var markRemoval = new Uint8Array(positionsLength);\n  var previous = previousCompressedCartographicScratch;\n  var current = currentCompressedCartographicScratch;\n  var offset = 0;\n  for (var i = 0; i < countsLength; i++) {\n    var count = counts[i];\n    var updatedCount = count;\n    for (var j = 1; j < count; j++) {\n      var index = offset + j;\n      var previousIndex = index - 1;\n      current.longitude = uBuffer[index];\n      current.latitude = vBuffer[index];\n      previous.longitude = uBuffer[previousIndex];\n      previous.latitude = vBuffer[previousIndex];\n\n      if (Cartographic.equals(current, previous)) {\n        updatedCount--;\n        markRemoval[previousIndex] = 1;\n      }\n    }\n    counts[i] = updatedCount;\n    offset += count;\n  }\n\n  var nextAvailableIndex = 0;\n  for (var k = 0; k < positionsLength; k++) {\n    if (markRemoval[k] !== 1) {\n      uBuffer[nextAvailableIndex] = uBuffer[k];\n      vBuffer[nextAvailableIndex] = vBuffer[k];\n      heightBuffer[nextAvailableIndex] = heightBuffer[k];\n      nextAvailableIndex++;\n    }\n  }\n}\n\nfunction VertexAttributesAndIndices(volumesCount) {\n  var vertexCount = volumesCount * 8;\n  var vec3Floats = vertexCount * 3;\n  var vec4Floats = vertexCount * 4;\n  this.startEllipsoidNormals = new Float32Array(vec3Floats);\n  this.endEllipsoidNormals = new Float32Array(vec3Floats);\n  this.startPositionAndHeights = new Float32Array(vec4Floats);\n  this.startFaceNormalAndVertexCornerIds = new Float32Array(vec4Floats);\n  this.endPositionAndHeights = new Float32Array(vec4Floats);\n  this.endFaceNormalAndHalfWidths = new Float32Array(vec4Floats);\n  this.vertexBatchIds = new Uint16Array(vertexCount);\n\n  this.indices = IndexDatatype.createTypedArray(vertexCount, 36 * volumesCount);\n\n  this.vec3Offset = 0;\n  this.vec4Offset = 0;\n  this.batchIdOffset = 0;\n  this.indexOffset = 0;\n\n  this.volumeStartIndex = 0;\n}\n\nvar towardCurrScratch = new Cartesian3();\nvar towardNextScratch = new Cartesian3();\nfunction computeMiteredNormal(\n  previousPosition,\n  position,\n  nextPosition,\n  ellipsoidSurfaceNormal,\n  result\n) {\n  var towardNext = Cartesian3.subtract(\n    nextPosition,\n    position,\n    towardNextScratch\n  );\n  var towardCurr = Cartesian3.subtract(\n    position,\n    previousPosition,\n    towardCurrScratch\n  );\n  Cartesian3.normalize(towardNext, towardNext);\n  Cartesian3.normalize(towardCurr, towardCurr);\n\n  if (Cartesian3.dot(towardNext, towardCurr) < MITER_BREAK) {\n    towardCurr = Cartesian3.multiplyByScalar(\n      towardCurr,\n      -1.0,\n      towardCurrScratch\n    );\n  }\n\n  Cartesian3.add(towardNext, towardCurr, result);\n  if (Cartesian3.equals(result, Cartesian3.ZERO)) {\n    result = Cartesian3.subtract(previousPosition, position);\n  }\n\n  // Make sure the normal is orthogonal to the ellipsoid surface normal\n  Cartesian3.cross(result, ellipsoidSurfaceNormal, result);\n  Cartesian3.cross(ellipsoidSurfaceNormal, result, result);\n  Cartesian3.normalize(result, result);\n  return result;\n}\n\n// Winding order is reversed so each segment's volume is inside-out\n//          3-----------7\n//         /|   left   /|\n//        / | 1       / |\n//       2-----------6  5  end\n//       | /         | /\n// start |/  right   |/\n//       0-----------4\n//\nvar REFERENCE_INDICES = [\n  0,\n  2,\n  6,\n  0,\n  6,\n  4, // right\n  0,\n  1,\n  3,\n  0,\n  3,\n  2, // start face\n  0,\n  4,\n  5,\n  0,\n  5,\n  1, // bottom\n  5,\n  3,\n  1,\n  5,\n  7,\n  3, // left\n  7,\n  5,\n  4,\n  7,\n  4,\n  6, // end face\n  7,\n  6,\n  2,\n  7,\n  2,\n  3, // top\n];\nvar REFERENCE_INDICES_LENGTH = REFERENCE_INDICES.length;\n\nvar positionScratch = new Cartesian3();\nvar scratchStartEllipsoidNormal = new Cartesian3();\nvar scratchStartFaceNormal = new Cartesian3();\nvar scratchEndEllipsoidNormal = new Cartesian3();\nvar scratchEndFaceNormal = new Cartesian3();\nVertexAttributesAndIndices.prototype.addVolume = function (\n  preStartRTC,\n  startRTC,\n  endRTC,\n  postEndRTC,\n  startHeight,\n  endHeight,\n  halfWidth,\n  batchId,\n  center,\n  ellipsoid\n) {\n  var position = Cartesian3.add(startRTC, center, positionScratch);\n  var startEllipsoidNormal = ellipsoid.geodeticSurfaceNormal(\n    position,\n    scratchStartEllipsoidNormal\n  );\n  position = Cartesian3.add(endRTC, center, positionScratch);\n  var endEllipsoidNormal = ellipsoid.geodeticSurfaceNormal(\n    position,\n    scratchEndEllipsoidNormal\n  );\n\n  var startFaceNormal = computeMiteredNormal(\n    preStartRTC,\n    startRTC,\n    endRTC,\n    startEllipsoidNormal,\n    scratchStartFaceNormal\n  );\n  var endFaceNormal = computeMiteredNormal(\n    postEndRTC,\n    endRTC,\n    startRTC,\n    endEllipsoidNormal,\n    scratchEndFaceNormal\n  );\n\n  var startEllipsoidNormals = this.startEllipsoidNormals;\n  var endEllipsoidNormals = this.endEllipsoidNormals;\n  var startPositionAndHeights = this.startPositionAndHeights;\n  var startFaceNormalAndVertexCornerIds = this\n    .startFaceNormalAndVertexCornerIds;\n  var endPositionAndHeights = this.endPositionAndHeights;\n  var endFaceNormalAndHalfWidths = this.endFaceNormalAndHalfWidths;\n  var vertexBatchIds = this.vertexBatchIds;\n\n  var batchIdOffset = this.batchIdOffset;\n  var vec3Offset = this.vec3Offset;\n  var vec4Offset = this.vec4Offset;\n\n  var i;\n  for (i = 0; i < 8; i++) {\n    Cartesian3.pack(startEllipsoidNormal, startEllipsoidNormals, vec3Offset);\n    Cartesian3.pack(endEllipsoidNormal, endEllipsoidNormals, vec3Offset);\n\n    Cartesian3.pack(startRTC, startPositionAndHeights, vec4Offset);\n    startPositionAndHeights[vec4Offset + 3] = startHeight;\n\n    Cartesian3.pack(endRTC, endPositionAndHeights, vec4Offset);\n    endPositionAndHeights[vec4Offset + 3] = endHeight;\n\n    Cartesian3.pack(\n      startFaceNormal,\n      startFaceNormalAndVertexCornerIds,\n      vec4Offset\n    );\n    startFaceNormalAndVertexCornerIds[vec4Offset + 3] = i;\n\n    Cartesian3.pack(endFaceNormal, endFaceNormalAndHalfWidths, vec4Offset);\n    endFaceNormalAndHalfWidths[vec4Offset + 3] = halfWidth;\n\n    vertexBatchIds[batchIdOffset++] = batchId;\n\n    vec3Offset += 3;\n    vec4Offset += 4;\n  }\n\n  this.batchIdOffset = batchIdOffset;\n  this.vec3Offset = vec3Offset;\n  this.vec4Offset = vec4Offset;\n  var indices = this.indices;\n  var volumeStartIndex = this.volumeStartIndex;\n\n  var indexOffset = this.indexOffset;\n  for (i = 0; i < REFERENCE_INDICES_LENGTH; i++) {\n    indices[indexOffset + i] = REFERENCE_INDICES[i] + volumeStartIndex;\n  }\n\n  this.volumeStartIndex += 8;\n  this.indexOffset += REFERENCE_INDICES_LENGTH;\n};\n\nvar scratchRectangle = new Rectangle();\nvar scratchEllipsoid = new Ellipsoid();\nvar scratchCenter = new Cartesian3();\n\nvar scratchPrev = new Cartesian3();\nvar scratchP0 = new Cartesian3();\nvar scratchP1 = new Cartesian3();\nvar scratchNext = new Cartesian3();\nfunction createVectorTileClampedPolylines(parameters, transferableObjects) {\n  var encodedPositions = new Uint16Array(parameters.positions);\n  var widths = new Uint16Array(parameters.widths);\n  var counts = new Uint32Array(parameters.counts);\n  var batchIds = new Uint16Array(parameters.batchIds);\n\n  // Unpack tile decoding parameters\n  var rectangle = scratchRectangle;\n  var ellipsoid = scratchEllipsoid;\n  var center = scratchCenter;\n  var packedBuffer = new Float64Array(parameters.packedBuffer);\n\n  var offset = 0;\n  var minimumHeight = packedBuffer[offset++];\n  var maximumHeight = packedBuffer[offset++];\n\n  Rectangle.unpack(packedBuffer, offset, rectangle);\n  offset += Rectangle.packedLength;\n\n  Ellipsoid.unpack(packedBuffer, offset, ellipsoid);\n  offset += Ellipsoid.packedLength;\n\n  Cartesian3.unpack(packedBuffer, offset, center);\n\n  var i;\n\n  // Unpack positions and generate volumes\n  var positionsLength = encodedPositions.length / 3;\n  var uBuffer = encodedPositions.subarray(0, positionsLength);\n  var vBuffer = encodedPositions.subarray(positionsLength, 2 * positionsLength);\n  var heightBuffer = encodedPositions.subarray(\n    2 * positionsLength,\n    3 * positionsLength\n  );\n  AttributeCompression.zigZagDeltaDecode(uBuffer, vBuffer, heightBuffer);\n\n  removeDuplicates(uBuffer, vBuffer, heightBuffer, counts);\n\n  // Figure out how many volumes and how many vertices there will be.\n  var countsLength = counts.length;\n  var volumesCount = 0;\n  for (i = 0; i < countsLength; i++) {\n    var polylinePositionCount = counts[i];\n    volumesCount += polylinePositionCount - 1;\n  }\n\n  var attribsAndIndices = new VertexAttributesAndIndices(volumesCount);\n\n  var positionsRTC = decodePositionsToRtc(\n    uBuffer,\n    vBuffer,\n    heightBuffer,\n    rectangle,\n    minimumHeight,\n    maximumHeight,\n    ellipsoid,\n    center\n  );\n\n  var currentPositionIndex = 0;\n  var currentHeightIndex = 0;\n  for (i = 0; i < countsLength; i++) {\n    var polylineVolumeCount = counts[i] - 1;\n    var halfWidth = widths[i] * 0.5;\n    var batchId = batchIds[i];\n    var volumeFirstPositionIndex = currentPositionIndex;\n    for (var j = 0; j < polylineVolumeCount; j++) {\n      var volumeStart = Cartesian3.unpack(\n        positionsRTC,\n        currentPositionIndex,\n        scratchP0\n      );\n      var volumeEnd = Cartesian3.unpack(\n        positionsRTC,\n        currentPositionIndex + 3,\n        scratchP1\n      );\n\n      var startHeight = heightBuffer[currentHeightIndex];\n      var endHeight = heightBuffer[currentHeightIndex + 1];\n      startHeight = CesiumMath.lerp(\n        minimumHeight,\n        maximumHeight,\n        startHeight / MAX_SHORT\n      );\n      endHeight = CesiumMath.lerp(\n        minimumHeight,\n        maximumHeight,\n        endHeight / MAX_SHORT\n      );\n\n      currentHeightIndex++;\n\n      var preStart = scratchPrev;\n      var postEnd = scratchNext;\n      if (j === 0) {\n        // Check if this volume is like a loop\n        var finalPositionIndex =\n          volumeFirstPositionIndex + polylineVolumeCount * 3;\n        var finalPosition = Cartesian3.unpack(\n          positionsRTC,\n          finalPositionIndex,\n          scratchPrev\n        );\n        if (Cartesian3.equals(finalPosition, volumeStart)) {\n          Cartesian3.unpack(positionsRTC, finalPositionIndex - 3, preStart);\n        } else {\n          var offsetPastStart = Cartesian3.subtract(\n            volumeStart,\n            volumeEnd,\n            scratchPrev\n          );\n          preStart = Cartesian3.add(offsetPastStart, volumeStart, scratchPrev);\n        }\n      } else {\n        Cartesian3.unpack(positionsRTC, currentPositionIndex - 3, preStart);\n      }\n\n      if (j === polylineVolumeCount - 1) {\n        // Check if this volume is like a loop\n        var firstPosition = Cartesian3.unpack(\n          positionsRTC,\n          volumeFirstPositionIndex,\n          scratchNext\n        );\n        if (Cartesian3.equals(firstPosition, volumeEnd)) {\n          Cartesian3.unpack(\n            positionsRTC,\n            volumeFirstPositionIndex + 3,\n            postEnd\n          );\n        } else {\n          var offsetPastEnd = Cartesian3.subtract(\n            volumeEnd,\n            volumeStart,\n            scratchNext\n          );\n          postEnd = Cartesian3.add(offsetPastEnd, volumeEnd, scratchNext);\n        }\n      } else {\n        Cartesian3.unpack(positionsRTC, currentPositionIndex + 6, postEnd);\n      }\n\n      attribsAndIndices.addVolume(\n        preStart,\n        volumeStart,\n        volumeEnd,\n        postEnd,\n        startHeight,\n        endHeight,\n        halfWidth,\n        batchId,\n        center,\n        ellipsoid\n      );\n\n      currentPositionIndex += 3;\n    }\n    currentPositionIndex += 3;\n    currentHeightIndex++;\n  }\n\n  var indices = attribsAndIndices.indices;\n\n  transferableObjects.push(attribsAndIndices.startEllipsoidNormals.buffer);\n  transferableObjects.push(attribsAndIndices.endEllipsoidNormals.buffer);\n  transferableObjects.push(attribsAndIndices.startPositionAndHeights.buffer);\n  transferableObjects.push(\n    attribsAndIndices.startFaceNormalAndVertexCornerIds.buffer\n  );\n  transferableObjects.push(attribsAndIndices.endPositionAndHeights.buffer);\n  transferableObjects.push(attribsAndIndices.endFaceNormalAndHalfWidths.buffer);\n  transferableObjects.push(attribsAndIndices.vertexBatchIds.buffer);\n  transferableObjects.push(indices.buffer);\n\n  return {\n    indexDatatype:\n      indices.BYTES_PER_ELEMENT === 2\n        ? IndexDatatype.UNSIGNED_SHORT\n        : IndexDatatype.UNSIGNED_INT,\n    startEllipsoidNormals: attribsAndIndices.startEllipsoidNormals.buffer,\n    endEllipsoidNormals: attribsAndIndices.endEllipsoidNormals.buffer,\n    startPositionAndHeights: attribsAndIndices.startPositionAndHeights.buffer,\n    startFaceNormalAndVertexCornerIds:\n      attribsAndIndices.startFaceNormalAndVertexCornerIds.buffer,\n    endPositionAndHeights: attribsAndIndices.endPositionAndHeights.buffer,\n    endFaceNormalAndHalfWidths:\n      attribsAndIndices.endFaceNormalAndHalfWidths.buffer,\n    vertexBatchIds: attribsAndIndices.vertexBatchIds.buffer,\n    indices: indices.buffer,\n  };\n}\nexport default createTaskProcessorWorker(createVectorTileClampedPolylines);\n"],"names":["MAX_SHORT","MITER_BREAK","Math","cos","CesiumMath","toRadians","scratchBVCartographic","Cartographic","scratchEncodedPosition","Cartesian3","previousCompressedCartographicScratch","currentCompressedCartographicScratch","VertexAttributesAndIndices","volumesCount","vertexCount","vec3Floats","vec4Floats","this","startEllipsoidNormals","Float32Array","endEllipsoidNormals","startPositionAndHeights","startFaceNormalAndVertexCornerIds","endPositionAndHeights","endFaceNormalAndHalfWidths","vertexBatchIds","Uint16Array","indices","IndexDatatype","createTypedArray","vec3Offset","vec4Offset","batchIdOffset","indexOffset","volumeStartIndex","towardCurrScratch","towardNextScratch","computeMiteredNormal","previousPosition","position","nextPosition","ellipsoidSurfaceNormal","result","towardNext","subtract","towardCurr","normalize","dot","multiplyByScalar","add","equals","ZERO","cross","REFERENCE_INDICES","REFERENCE_INDICES_LENGTH","length","positionScratch","scratchStartEllipsoidNormal","scratchStartFaceNormal","scratchEndEllipsoidNormal","scratchEndFaceNormal","prototype","addVolume","preStartRTC","startRTC","endRTC","postEndRTC","startHeight","endHeight","halfWidth","batchId","center","ellipsoid","startEllipsoidNormal","geodeticSurfaceNormal","endEllipsoidNormal","startFaceNormal","endFaceNormal","i","pack","scratchRectangle","Rectangle","scratchEllipsoid","Ellipsoid","scratchCenter","scratchPrev","scratchP0","scratchP1","scratchNext","createTaskProcessorWorker","parameters","transferableObjects","encodedPositions","positions","widths","counts","Uint32Array","batchIds","rectangle","packedBuffer","Float64Array","offset","minimumHeight","maximumHeight","unpack","packedLength","positionsLength","uBuffer","subarray","vBuffer","heightBuffer","AttributeCompression","zigZagDeltaDecode","countsLength","markRemoval","Uint8Array","previous","current","count","updatedCount","j","index","previousIndex","longitude","latitude","nextAvailableIndex","k","removeDuplicates","attribsAndIndices","positionsRTC","decodedPositions","u","v","h","lon","lerp","west","east","lat","south","north","alt","cartographic","fromRadians","decodedPosition","cartographicToCartesian","rtc","decodePositionsToRtc","currentPositionIndex","currentHeightIndex","polylineVolumeCount","volumeFirstPositionIndex","volumeStart","volumeEnd","finalPositionIndex","finalPosition","offsetPastEnd","preStart","postEnd","offsetPastStart","firstPosition","push","buffer","indexDatatype","BYTES_PER_ELEMENT","UNSIGNED_SHORT","UNSIGNED_INT"],"mappings":"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"}