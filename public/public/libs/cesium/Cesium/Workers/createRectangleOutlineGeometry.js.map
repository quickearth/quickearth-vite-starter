{"version":3,"file":"createRectangleOutlineGeometry.js","sources":["../../../../Source/Core/RectangleOutlineGeometry.js","../../../../Source/WorkersES6/createRectangleOutlineGeometry.js"],"sourcesContent":["import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport RectangleGeometryLibrary from \"./RectangleGeometryLibrary.js\";\n\nvar bottomBoundingSphere = new BoundingSphere();\nvar topBoundingSphere = new BoundingSphere();\nvar positionScratch = new Cartesian3();\nvar rectangleScratch = new Rectangle();\n\nfunction constructRectangle(geometry, computedOptions) {\n  var ellipsoid = geometry._ellipsoid;\n  var height = computedOptions.height;\n  var width = computedOptions.width;\n  var northCap = computedOptions.northCap;\n  var southCap = computedOptions.southCap;\n\n  var rowHeight = height;\n  var widthMultiplier = 2;\n  var size = 0;\n  var corners = 4;\n  if (northCap) {\n    widthMultiplier -= 1;\n    rowHeight -= 1;\n    size += 1;\n    corners -= 2;\n  }\n  if (southCap) {\n    widthMultiplier -= 1;\n    rowHeight -= 1;\n    size += 1;\n    corners -= 2;\n  }\n  size += widthMultiplier * width + 2 * rowHeight - corners;\n\n  var positions = new Float64Array(size * 3);\n\n  var posIndex = 0;\n  var row = 0;\n  var col;\n  var position = positionScratch;\n  if (northCap) {\n    RectangleGeometryLibrary.computePosition(\n      computedOptions,\n      ellipsoid,\n      false,\n      row,\n      0,\n      position\n    );\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n  } else {\n    for (col = 0; col < width; col++) {\n      RectangleGeometryLibrary.computePosition(\n        computedOptions,\n        ellipsoid,\n        false,\n        row,\n        col,\n        position\n      );\n      positions[posIndex++] = position.x;\n      positions[posIndex++] = position.y;\n      positions[posIndex++] = position.z;\n    }\n  }\n\n  col = width - 1;\n  for (row = 1; row < height; row++) {\n    RectangleGeometryLibrary.computePosition(\n      computedOptions,\n      ellipsoid,\n      false,\n      row,\n      col,\n      position\n    );\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n  }\n\n  row = height - 1;\n  if (!southCap) {\n    // if southCap is true, we dont need to add any more points because the south pole point was added by the iteration above\n    for (col = width - 2; col >= 0; col--) {\n      RectangleGeometryLibrary.computePosition(\n        computedOptions,\n        ellipsoid,\n        false,\n        row,\n        col,\n        position\n      );\n      positions[posIndex++] = position.x;\n      positions[posIndex++] = position.y;\n      positions[posIndex++] = position.z;\n    }\n  }\n\n  col = 0;\n  for (row = height - 2; row > 0; row--) {\n    RectangleGeometryLibrary.computePosition(\n      computedOptions,\n      ellipsoid,\n      false,\n      row,\n      col,\n      position\n    );\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n  }\n\n  var indicesSize = (positions.length / 3) * 2;\n  var indices = IndexDatatype.createTypedArray(\n    positions.length / 3,\n    indicesSize\n  );\n\n  var index = 0;\n  for (var i = 0; i < positions.length / 3 - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n  }\n  indices[index++] = positions.length / 3 - 1;\n  indices[index++] = 0;\n\n  var geo = new Geometry({\n    attributes: new GeometryAttributes(),\n    primitiveType: PrimitiveType.LINES,\n  });\n\n  geo.attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positions,\n  });\n  geo.indices = indices;\n\n  return geo;\n}\n\nfunction constructExtrudedRectangle(rectangleGeometry, computedOptions) {\n  var surfaceHeight = rectangleGeometry._surfaceHeight;\n  var extrudedHeight = rectangleGeometry._extrudedHeight;\n  var ellipsoid = rectangleGeometry._ellipsoid;\n  var minHeight = extrudedHeight;\n  var maxHeight = surfaceHeight;\n  var geo = constructRectangle(rectangleGeometry, computedOptions);\n\n  var height = computedOptions.height;\n  var width = computedOptions.width;\n\n  var topPositions = PolygonPipeline.scaleToGeodeticHeight(\n    geo.attributes.position.values,\n    maxHeight,\n    ellipsoid,\n    false\n  );\n  var length = topPositions.length;\n  var positions = new Float64Array(length * 2);\n  positions.set(topPositions);\n  var bottomPositions = PolygonPipeline.scaleToGeodeticHeight(\n    geo.attributes.position.values,\n    minHeight,\n    ellipsoid\n  );\n  positions.set(bottomPositions, length);\n  geo.attributes.position.values = positions;\n\n  var northCap = computedOptions.northCap;\n  var southCap = computedOptions.southCap;\n  var corners = 4;\n  if (northCap) {\n    corners -= 1;\n  }\n  if (southCap) {\n    corners -= 1;\n  }\n\n  var indicesSize = (positions.length / 3 + corners) * 2;\n  var indices = IndexDatatype.createTypedArray(\n    positions.length / 3,\n    indicesSize\n  );\n  length = positions.length / 6;\n  var index = 0;\n  for (var i = 0; i < length - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n    indices[index++] = i + length;\n    indices[index++] = i + length + 1;\n  }\n  indices[index++] = length - 1;\n  indices[index++] = 0;\n  indices[index++] = length + length - 1;\n  indices[index++] = length;\n\n  indices[index++] = 0;\n  indices[index++] = length;\n\n  var bottomCorner;\n  if (northCap) {\n    bottomCorner = height - 1;\n  } else {\n    var topRightCorner = width - 1;\n    indices[index++] = topRightCorner;\n    indices[index++] = topRightCorner + length;\n    bottomCorner = width + height - 2;\n  }\n\n  indices[index++] = bottomCorner;\n  indices[index++] = bottomCorner + length;\n\n  if (!southCap) {\n    var bottomLeftCorner = width + bottomCorner - 1;\n    indices[index++] = bottomLeftCorner;\n    indices[index] = bottomLeftCorner + length;\n  }\n\n  geo.indices = indices;\n\n  return geo;\n}\n\n/**\n * A description of the outline of a a cartographic rectangle on an ellipsoid centered at the origin.\n *\n * @alias RectangleOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Number} [options.height=0.0] The distance in meters between the rectangle and the ellipsoid surface.\n * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\n * @param {Number} [options.extrudedHeight] The distance in meters between the rectangle's extruded face and the ellipsoid surface.\n *\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>options.rectangle.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>options.rectangle.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>options.rectangle.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be greater than <code>rectangle.south</code>.\n *\n * @see RectangleOutlineGeometry#createGeometry\n *\n * @example\n * var rectangle = new Cesium.RectangleOutlineGeometry({\n *   ellipsoid : Cesium.Ellipsoid.WGS84,\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n *   height : 10000.0\n * });\n * var geometry = Cesium.RectangleOutlineGeometry.createGeometry(rectangle);\n */\nfunction RectangleOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var rectangle = options.rectangle;\n  var granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var rotation = defaultValue(options.rotation, 0.0);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required.\");\n  }\n  Rectangle.validate(rectangle);\n  if (rectangle.north < rectangle.south) {\n    throw new DeveloperError(\n      \"options.rectangle.north must be greater than options.rectangle.south\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var height = defaultValue(options.height, 0.0);\n  var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  this._rectangle = Rectangle.clone(rectangle);\n  this._granularity = granularity;\n  this._ellipsoid = ellipsoid;\n  this._surfaceHeight = Math.max(height, extrudedHeight);\n  this._rotation = rotation;\n  this._extrudedHeight = Math.min(height, extrudedHeight);\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createRectangleOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nRectangleOutlineGeometry.packedLength =\n  Rectangle.packedLength + Ellipsoid.packedLength + 5;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {RectangleOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nRectangleOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Rectangle.pack(value._rectangle, array, startingIndex);\n  startingIndex += Rectangle.packedLength;\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._surfaceHeight;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nvar scratchRectangle = new Rectangle();\nvar scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nvar scratchOptions = {\n  rectangle: scratchRectangle,\n  ellipsoid: scratchEllipsoid,\n  granularity: undefined,\n  height: undefined,\n  rotation: undefined,\n  extrudedHeight: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {RectangleOutlineGeometry} [result] The object into which to store the result.\n * @returns {RectangleOutlineGeometry} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nRectangleOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var rectangle = Rectangle.unpack(array, startingIndex, scratchRectangle);\n  startingIndex += Rectangle.packedLength;\n\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  var granularity = array[startingIndex++];\n  var height = array[startingIndex++];\n  var rotation = array[startingIndex++];\n  var extrudedHeight = array[startingIndex++];\n  var offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.granularity = granularity;\n    scratchOptions.height = height;\n    scratchOptions.rotation = rotation;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n\n    return new RectangleOutlineGeometry(scratchOptions);\n  }\n\n  result._rectangle = Rectangle.clone(rectangle, result._rectangle);\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._surfaceHeight = height;\n  result._rotation = rotation;\n  result._extrudedHeight = extrudedHeight;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\nvar nwScratch = new Cartographic();\n/**\n * Computes the geometric representation of an outline of a rectangle, including its vertices, indices, and a bounding sphere.\n *\n * @param {RectangleOutlineGeometry} rectangleGeometry A description of the rectangle outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n *\n * @exception {DeveloperError} Rotated rectangle is invalid.\n */\nRectangleOutlineGeometry.createGeometry = function (rectangleGeometry) {\n  var rectangle = rectangleGeometry._rectangle;\n  var ellipsoid = rectangleGeometry._ellipsoid;\n  var computedOptions = RectangleGeometryLibrary.computeOptions(\n    rectangle,\n    rectangleGeometry._granularity,\n    rectangleGeometry._rotation,\n    0,\n    rectangleScratch,\n    nwScratch\n  );\n\n  var geometry;\n  var boundingSphere;\n\n  if (\n    CesiumMath.equalsEpsilon(\n      rectangle.north,\n      rectangle.south,\n      CesiumMath.EPSILON10\n    ) ||\n    CesiumMath.equalsEpsilon(\n      rectangle.east,\n      rectangle.west,\n      CesiumMath.EPSILON10\n    )\n  ) {\n    return undefined;\n  }\n\n  var surfaceHeight = rectangleGeometry._surfaceHeight;\n  var extrudedHeight = rectangleGeometry._extrudedHeight;\n  var extrude = !CesiumMath.equalsEpsilon(\n    surfaceHeight,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2\n  );\n  var offsetValue;\n  if (extrude) {\n    geometry = constructExtrudedRectangle(rectangleGeometry, computedOptions);\n    if (defined(rectangleGeometry._offsetAttribute)) {\n      var size = geometry.attributes.position.values.length / 3;\n      var offsetAttribute = new Uint8Array(size);\n      if (rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.TOP) {\n        offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n      } else {\n        offsetValue =\n          rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n            ? 0\n            : 1;\n        offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n      }\n\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: offsetAttribute,\n      });\n    }\n    var topBS = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      surfaceHeight,\n      topBoundingSphere\n    );\n    var bottomBS = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      extrudedHeight,\n      bottomBoundingSphere\n    );\n    boundingSphere = BoundingSphere.union(topBS, bottomBS);\n  } else {\n    geometry = constructRectangle(rectangleGeometry, computedOptions);\n    geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n      geometry.attributes.position.values,\n      surfaceHeight,\n      ellipsoid,\n      false\n    );\n\n    if (defined(rectangleGeometry._offsetAttribute)) {\n      var length = geometry.attributes.position.values.length;\n      var applyOffset = new Uint8Array(length / 3);\n      offsetValue =\n        rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      arrayFill(applyOffset, offsetValue);\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n\n    boundingSphere = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      surfaceHeight\n    );\n  }\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: rectangleGeometry._offsetAttribute,\n  });\n};\nexport default RectangleOutlineGeometry;\n","import defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport RectangleOutlineGeometry from \"../Core/RectangleOutlineGeometry.js\";\n\nfunction createRectangleOutlineGeometry(rectangleGeometry, offset) {\n  if (defined(offset)) {\n    rectangleGeometry = RectangleOutlineGeometry.unpack(\n      rectangleGeometry,\n      offset\n    );\n  }\n  rectangleGeometry._ellipsoid = Ellipsoid.clone(rectangleGeometry._ellipsoid);\n  rectangleGeometry._rectangle = Rectangle.clone(rectangleGeometry._rectangle);\n  return RectangleOutlineGeometry.createGeometry(rectangleGeometry);\n}\nexport default createRectangleOutlineGeometry;\n"],"names":["bottomBoundingSphere","BoundingSphere","topBoundingSphere","positionScratch","Cartesian3","rectangleScratch","Rectangle","constructRectangle","geometry","computedOptions","ellipsoid","_ellipsoid","height","width","northCap","southCap","rowHeight","widthMultiplier","size","corners","col","positions","Float64Array","posIndex","row","position","RectangleGeometryLibrary","computePosition","x","y","z","indicesSize","length","indices","IndexDatatype","createTypedArray","index","i","geo","Geometry","attributes","GeometryAttributes","primitiveType","PrimitiveType","LINES","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","RectangleOutlineGeometry","options","rectangle","defaultValue","EMPTY_OBJECT","granularity","CesiumMath","RADIANS_PER_DEGREE","Ellipsoid","WGS84","rotation","defined","DeveloperError","validate","north","south","extrudedHeight","this","_rectangle","clone","_granularity","_surfaceHeight","Math","max","_rotation","_extrudedHeight","min","_offsetAttribute","offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","scratchRectangle","scratchEllipsoid","UNIT_SPHERE","scratchOptions","undefined","unpack","result","nwScratch","Cartographic","createGeometry","rectangleGeometry","computeOptions","equalsEpsilon","EPSILON10","east","west","topBS","offsetValue","surfaceHeight","boundingSphere","EPSILON2","minHeight","maxHeight","topPositions","PolygonPipeline","scaleToGeodeticHeight","set","bottomPositions","bottomCorner","topRightCorner","bottomLeftCorner","constructExtrudedRectangle","Uint8Array","GeometryOffsetAttribute","TOP","arrayFill","NONE","applyOffset","UNSIGNED_BYTE","fromRectangle3D","bottomBS","union","offset"],"mappings":"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"}