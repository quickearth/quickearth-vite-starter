{"version":3,"file":"FrustumGeometry-aec504d2.js","sources":["../../../../Source/Core/CullingVolume.js","../../../../Source/Core/OrthographicOffCenterFrustum.js","../../../../Source/Core/OrthographicFrustum.js","../../../../Source/Core/PerspectiveOffCenterFrustum.js","../../../../Source/Core/PerspectiveFrustum.js","../../../../Source/Core/FrustumGeometry.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Intersect from \"./Intersect.js\";\nimport Plane from \"./Plane.js\";\n\n/**\n * The culling volume defined by planes.\n *\n * @alias CullingVolume\n * @constructor\n *\n * @param {Cartesian4[]} [planes] An array of clipping planes.\n */\nfunction CullingVolume(planes) {\n  /**\n   * Each plane is represented by a Cartesian4 object, where the x, y, and z components\n   * define the unit vector normal to the plane, and the w component is the distance of the\n   * plane from the origin.\n   * @type {Cartesian4[]}\n   * @default []\n   */\n  this.planes = defaultValue(planes, []);\n}\n\nvar faces = [new Cartesian3(), new Cartesian3(), new Cartesian3()];\nCartesian3.clone(Cartesian3.UNIT_X, faces[0]);\nCartesian3.clone(Cartesian3.UNIT_Y, faces[1]);\nCartesian3.clone(Cartesian3.UNIT_Z, faces[2]);\n\nvar scratchPlaneCenter = new Cartesian3();\nvar scratchPlaneNormal = new Cartesian3();\nvar scratchPlane = new Plane(new Cartesian3(1.0, 0.0, 0.0), 0.0);\n\n/**\n * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.\n * The planes are aligned to the x, y, and z axes in world coordinates.\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere used to create the culling volume.\n * @param {CullingVolume} [result] The object onto which to store the result.\n * @returns {CullingVolume} The culling volume created from the bounding sphere.\n */\nCullingVolume.fromBoundingSphere = function (boundingSphere, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new CullingVolume();\n  }\n\n  var length = faces.length;\n  var planes = result.planes;\n  planes.length = 2 * length;\n\n  var center = boundingSphere.center;\n  var radius = boundingSphere.radius;\n\n  var planeIndex = 0;\n\n  for (var i = 0; i < length; ++i) {\n    var faceNormal = faces[i];\n\n    var plane0 = planes[planeIndex];\n    var plane1 = planes[planeIndex + 1];\n\n    if (!defined(plane0)) {\n      plane0 = planes[planeIndex] = new Cartesian4();\n    }\n    if (!defined(plane1)) {\n      plane1 = planes[planeIndex + 1] = new Cartesian4();\n    }\n\n    Cartesian3.multiplyByScalar(faceNormal, -radius, scratchPlaneCenter);\n    Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);\n\n    plane0.x = faceNormal.x;\n    plane0.y = faceNormal.y;\n    plane0.z = faceNormal.z;\n    plane0.w = -Cartesian3.dot(faceNormal, scratchPlaneCenter);\n\n    Cartesian3.multiplyByScalar(faceNormal, radius, scratchPlaneCenter);\n    Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);\n\n    plane1.x = -faceNormal.x;\n    plane1.y = -faceNormal.y;\n    plane1.z = -faceNormal.z;\n    plane1.w = -Cartesian3.dot(\n      Cartesian3.negate(faceNormal, scratchPlaneNormal),\n      scratchPlaneCenter\n    );\n\n    planeIndex += 2;\n  }\n\n  return result;\n};\n\n/**\n * Determines whether a bounding volume intersects the culling volume.\n *\n * @param {Object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.\n * @returns {Intersect}  Intersect.OUTSIDE, Intersect.INTERSECTING, or Intersect.INSIDE.\n */\nCullingVolume.prototype.computeVisibility = function (boundingVolume) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingVolume)) {\n    throw new DeveloperError(\"boundingVolume is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var planes = this.planes;\n  var intersecting = false;\n  for (var k = 0, len = planes.length; k < len; ++k) {\n    var result = boundingVolume.intersectPlane(\n      Plane.fromCartesian4(planes[k], scratchPlane)\n    );\n    if (result === Intersect.OUTSIDE) {\n      return Intersect.OUTSIDE;\n    } else if (result === Intersect.INTERSECTING) {\n      intersecting = true;\n    }\n  }\n\n  return intersecting ? Intersect.INTERSECTING : Intersect.INSIDE;\n};\n\n/**\n * Determines whether a bounding volume intersects the culling volume.\n *\n * @param {Object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.\n * @param {Number} parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling\n *                                 volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then\n *                                 the parent (and therefore this) volume is completely inside plane[planeIndex]\n *                                 and that plane check can be skipped.\n * @returns {Number} A plane mask as described above (which can be applied to this boundingVolume's children).\n *\n * @private\n */\nCullingVolume.prototype.computeVisibilityWithPlaneMask = function (\n  boundingVolume,\n  parentPlaneMask\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingVolume)) {\n    throw new DeveloperError(\"boundingVolume is required.\");\n  }\n  if (!defined(parentPlaneMask)) {\n    throw new DeveloperError(\"parentPlaneMask is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (\n    parentPlaneMask === CullingVolume.MASK_OUTSIDE ||\n    parentPlaneMask === CullingVolume.MASK_INSIDE\n  ) {\n    // parent is completely outside or completely inside, so this child is as well.\n    return parentPlaneMask;\n  }\n\n  // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\n  // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\n  var mask = CullingVolume.MASK_INSIDE;\n\n  var planes = this.planes;\n  for (var k = 0, len = planes.length; k < len; ++k) {\n    // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\n    var flag = k < 31 ? 1 << k : 0;\n    if (k < 31 && (parentPlaneMask & flag) === 0) {\n      // boundingVolume is known to be INSIDE this plane.\n      continue;\n    }\n\n    var result = boundingVolume.intersectPlane(\n      Plane.fromCartesian4(planes[k], scratchPlane)\n    );\n    if (result === Intersect.OUTSIDE) {\n      return CullingVolume.MASK_OUTSIDE;\n    } else if (result === Intersect.INTERSECTING) {\n      mask |= flag;\n    }\n  }\n\n  return mask;\n};\n\n/**\n * For plane masks (as used in {@link CullingVolume#computeVisibilityWithPlaneMask}), this special value\n * represents the case where the object bounding volume is entirely outside the culling volume.\n *\n * @type {Number}\n * @private\n */\nCullingVolume.MASK_OUTSIDE = 0xffffffff;\n\n/**\n * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n * represents the case where the object bounding volume is entirely inside the culling volume.\n *\n * @type {Number}\n * @private\n */\nCullingVolume.MASK_INSIDE = 0x00000000;\n\n/**\n * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n * represents the case where the object bounding volume (may) intersect all planes of the culling volume.\n *\n * @type {Number}\n * @private\n */\nCullingVolume.MASK_INDETERMINATE = 0x7fffffff;\nexport default CullingVolume;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport CullingVolume from \"./CullingVolume.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\n\n/**\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias OrthographicOffCenterFrustum\n * @constructor\n *\n * @param {Object} [options] An object with the following properties:\n * @param {Number} [options.left] The left clipping plane distance.\n * @param {Number} [options.right] The right clipping plane distance.\n * @param {Number} [options.top] The top clipping plane distance.\n * @param {Number} [options.bottom] The bottom clipping plane distance.\n * @param {Number} [options.near=1.0] The near clipping plane distance.\n * @param {Number} [options.far=500000000.0] The far clipping plane distance.\n *\n * @example\n * var maxRadii = ellipsoid.maximumRadius;\n *\n * var frustum = new Cesium.OrthographicOffCenterFrustum();\n * frustum.right = maxRadii * Cesium.Math.PI;\n * frustum.left = -c.frustum.right;\n * frustum.top = c.frustum.right * (canvas.clientHeight / canvas.clientWidth);\n * frustum.bottom = -c.frustum.top;\n * frustum.near = 0.01 * maxRadii;\n * frustum.far = 50.0 * maxRadii;\n */\nfunction OrthographicOffCenterFrustum(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The left clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.left = options.left;\n  this._left = undefined;\n\n  /**\n   * The right clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.right = options.right;\n  this._right = undefined;\n\n  /**\n   * The top clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.top = options.top;\n  this._top = undefined;\n\n  /**\n   * The bottom clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.bottom = options.bottom;\n  this._bottom = undefined;\n\n  /**\n   * The distance of the near plane.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.near = defaultValue(options.near, 1.0);\n  this._near = this.near;\n\n  /**\n   * The distance of the far plane.\n   * @type {Number}\n   * @default 500000000.0;\n   */\n  this.far = defaultValue(options.far, 500000000.0);\n  this._far = this.far;\n\n  this._cullingVolume = new CullingVolume();\n  this._orthographicMatrix = new Matrix4();\n}\n\nfunction update(frustum) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(frustum.right) ||\n    !defined(frustum.left) ||\n    !defined(frustum.top) ||\n    !defined(frustum.bottom) ||\n    !defined(frustum.near) ||\n    !defined(frustum.far)\n  ) {\n    throw new DeveloperError(\n      \"right, left, top, bottom, near, or far parameters are not set.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (\n    frustum.top !== frustum._top ||\n    frustum.bottom !== frustum._bottom ||\n    frustum.left !== frustum._left ||\n    frustum.right !== frustum._right ||\n    frustum.near !== frustum._near ||\n    frustum.far !== frustum._far\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    if (frustum.left > frustum.right) {\n      throw new DeveloperError(\"right must be greater than left.\");\n    }\n    if (frustum.bottom > frustum.top) {\n      throw new DeveloperError(\"top must be greater than bottom.\");\n    }\n    if (frustum.near <= 0 || frustum.near > frustum.far) {\n      throw new DeveloperError(\n        \"near must be greater than zero and less than far.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    frustum._left = frustum.left;\n    frustum._right = frustum.right;\n    frustum._top = frustum.top;\n    frustum._bottom = frustum.bottom;\n    frustum._near = frustum.near;\n    frustum._far = frustum.far;\n    frustum._orthographicMatrix = Matrix4.computeOrthographicOffCenter(\n      frustum.left,\n      frustum.right,\n      frustum.bottom,\n      frustum.top,\n      frustum.near,\n      frustum.far,\n      frustum._orthographicMatrix\n    );\n  }\n}\n\nObject.defineProperties(OrthographicOffCenterFrustum.prototype, {\n  /**\n   * Gets the orthographic projection matrix computed from the view frustum.\n   * @memberof OrthographicOffCenterFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   */\n  projectionMatrix: {\n    get: function () {\n      update(this);\n      return this._orthographicMatrix;\n    },\n  },\n});\n\nvar getPlanesRight = new Cartesian3();\nvar getPlanesNearCenter = new Cartesian3();\nvar getPlanesPoint = new Cartesian3();\nvar negateScratch = new Cartesian3();\n\n/**\n * Creates a culling volume for this frustum.\n *\n * @param {Cartesian3} position The eye position.\n * @param {Cartesian3} direction The view direction.\n * @param {Cartesian3} up The up direction.\n * @returns {CullingVolume} A culling volume at the given position and orientation.\n *\n * @example\n * // Check if a bounding volume intersects the frustum.\n * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * var intersect = cullingVolume.computeVisibility(boundingVolume);\n */\nOrthographicOffCenterFrustum.prototype.computeCullingVolume = function (\n  position,\n  direction,\n  up\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  }\n  if (!defined(up)) {\n    throw new DeveloperError(\"up is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var planes = this._cullingVolume.planes;\n  var t = this.top;\n  var b = this.bottom;\n  var r = this.right;\n  var l = this.left;\n  var n = this.near;\n  var f = this.far;\n\n  var right = Cartesian3.cross(direction, up, getPlanesRight);\n  Cartesian3.normalize(right, right);\n  var nearCenter = getPlanesNearCenter;\n  Cartesian3.multiplyByScalar(direction, n, nearCenter);\n  Cartesian3.add(position, nearCenter, nearCenter);\n\n  var point = getPlanesPoint;\n\n  // Left plane\n  Cartesian3.multiplyByScalar(right, l, point);\n  Cartesian3.add(nearCenter, point, point);\n\n  var plane = planes[0];\n  if (!defined(plane)) {\n    plane = planes[0] = new Cartesian4();\n  }\n  plane.x = right.x;\n  plane.y = right.y;\n  plane.z = right.z;\n  plane.w = -Cartesian3.dot(right, point);\n\n  // Right plane\n  Cartesian3.multiplyByScalar(right, r, point);\n  Cartesian3.add(nearCenter, point, point);\n\n  plane = planes[1];\n  if (!defined(plane)) {\n    plane = planes[1] = new Cartesian4();\n  }\n  plane.x = -right.x;\n  plane.y = -right.y;\n  plane.z = -right.z;\n  plane.w = -Cartesian3.dot(Cartesian3.negate(right, negateScratch), point);\n\n  // Bottom plane\n  Cartesian3.multiplyByScalar(up, b, point);\n  Cartesian3.add(nearCenter, point, point);\n\n  plane = planes[2];\n  if (!defined(plane)) {\n    plane = planes[2] = new Cartesian4();\n  }\n  plane.x = up.x;\n  plane.y = up.y;\n  plane.z = up.z;\n  plane.w = -Cartesian3.dot(up, point);\n\n  // Top plane\n  Cartesian3.multiplyByScalar(up, t, point);\n  Cartesian3.add(nearCenter, point, point);\n\n  plane = planes[3];\n  if (!defined(plane)) {\n    plane = planes[3] = new Cartesian4();\n  }\n  plane.x = -up.x;\n  plane.y = -up.y;\n  plane.z = -up.z;\n  plane.w = -Cartesian3.dot(Cartesian3.negate(up, negateScratch), point);\n\n  // Near plane\n  plane = planes[4];\n  if (!defined(plane)) {\n    plane = planes[4] = new Cartesian4();\n  }\n  plane.x = direction.x;\n  plane.y = direction.y;\n  plane.z = direction.z;\n  plane.w = -Cartesian3.dot(direction, nearCenter);\n\n  // Far plane\n  Cartesian3.multiplyByScalar(direction, f, point);\n  Cartesian3.add(position, point, point);\n\n  plane = planes[5];\n  if (!defined(plane)) {\n    plane = planes[5] = new Cartesian4();\n  }\n  plane.x = -direction.x;\n  plane.y = -direction.y;\n  plane.z = -direction.z;\n  plane.w = -Cartesian3.dot(Cartesian3.negate(direction, negateScratch), point);\n\n  return this._cullingVolume;\n};\n\n/**\n * Returns the pixel's width and height in meters.\n *\n * @param {Number} drawingBufferWidth The width of the drawing buffer.\n * @param {Number} drawingBufferHeight The height of the drawing buffer.\n * @param {Number} distance The distance to the near plane in meters.\n * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\n *\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n * @exception {DeveloperError} pixelRatio must be greater than zero.\n *\n * @example\n * // Example 1\n * // Get the width and height of a pixel.\n * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 0.0, scene.pixelRatio, new Cesium.Cartesian2());\n */\nOrthographicOffCenterFrustum.prototype.getPixelDimensions = function (\n  drawingBufferWidth,\n  drawingBufferHeight,\n  distance,\n  pixelRatio,\n  result\n) {\n  update(this);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(drawingBufferWidth) || !defined(drawingBufferHeight)) {\n    throw new DeveloperError(\n      \"Both drawingBufferWidth and drawingBufferHeight are required.\"\n    );\n  }\n  if (drawingBufferWidth <= 0) {\n    throw new DeveloperError(\"drawingBufferWidth must be greater than zero.\");\n  }\n  if (drawingBufferHeight <= 0) {\n    throw new DeveloperError(\"drawingBufferHeight must be greater than zero.\");\n  }\n  if (!defined(distance)) {\n    throw new DeveloperError(\"distance is required.\");\n  }\n  if (!defined(pixelRatio)) {\n    throw new DeveloperError(\"pixelRatio is required.\");\n  }\n  if (pixelRatio <= 0) {\n    throw new DeveloperError(\"pixelRatio must be greater than zero.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"A result object is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var frustumWidth = this.right - this.left;\n  var frustumHeight = this.top - this.bottom;\n  var pixelWidth = (pixelRatio * frustumWidth) / drawingBufferWidth;\n  var pixelHeight = (pixelRatio * frustumHeight) / drawingBufferHeight;\n\n  result.x = pixelWidth;\n  result.y = pixelHeight;\n  return result;\n};\n\n/**\n * Returns a duplicate of a OrthographicOffCenterFrustum instance.\n *\n * @param {OrthographicOffCenterFrustum} [result] The object onto which to store the result.\n * @returns {OrthographicOffCenterFrustum} The modified result parameter or a new OrthographicOffCenterFrustum instance if one was not provided.\n */\nOrthographicOffCenterFrustum.prototype.clone = function (result) {\n  if (!defined(result)) {\n    result = new OrthographicOffCenterFrustum();\n  }\n\n  result.left = this.left;\n  result.right = this.right;\n  result.top = this.top;\n  result.bottom = this.bottom;\n  result.near = this.near;\n  result.far = this.far;\n\n  // force update of clone to compute matrices\n  result._left = undefined;\n  result._right = undefined;\n  result._top = undefined;\n  result._bottom = undefined;\n  result._near = undefined;\n  result._far = undefined;\n\n  return result;\n};\n\n/**\n * Compares the provided OrthographicOffCenterFrustum componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrthographicOffCenterFrustum} [other] The right hand side OrthographicOffCenterFrustum.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nOrthographicOffCenterFrustum.prototype.equals = function (other) {\n  return (\n    defined(other) &&\n    other instanceof OrthographicOffCenterFrustum &&\n    this.right === other.right &&\n    this.left === other.left &&\n    this.top === other.top &&\n    this.bottom === other.bottom &&\n    this.near === other.near &&\n    this.far === other.far\n  );\n};\n\n/**\n * Compares the provided OrthographicOffCenterFrustum componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {OrthographicOffCenterFrustum} other The right hand side OrthographicOffCenterFrustum.\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\n */\nOrthographicOffCenterFrustum.prototype.equalsEpsilon = function (\n  other,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return (\n    other === this ||\n    (defined(other) &&\n      other instanceof OrthographicOffCenterFrustum &&\n      CesiumMath.equalsEpsilon(\n        this.right,\n        other.right,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.left,\n        other.left,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.top,\n        other.top,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.bottom,\n        other.bottom,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.near,\n        other.near,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.far,\n        other.far,\n        relativeEpsilon,\n        absoluteEpsilon\n      ))\n  );\n};\nexport default OrthographicOffCenterFrustum;\n","import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrthographicOffCenterFrustum from \"./OrthographicOffCenterFrustum.js\";\n\n/**\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias OrthographicFrustum\n * @constructor\n *\n * @param {Object} [options] An object with the following properties:\n * @param {Number} [options.width] The width of the frustum in meters.\n * @param {Number} [options.aspectRatio] The aspect ratio of the frustum's width to it's height.\n * @param {Number} [options.near=1.0] The distance of the near plane.\n * @param {Number} [options.far=500000000.0] The distance of the far plane.\n *\n * @example\n * var maxRadii = ellipsoid.maximumRadius;\n *\n * var frustum = new Cesium.OrthographicFrustum();\n * frustum.near = 0.01 * maxRadii;\n * frustum.far = 50.0 * maxRadii;\n */\nfunction OrthographicFrustum(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._offCenterFrustum = new OrthographicOffCenterFrustum();\n\n  /**\n   * The horizontal width of the frustum in meters.\n   * @type {Number}\n   * @default undefined\n   */\n  this.width = options.width;\n  this._width = undefined;\n\n  /**\n   * The aspect ratio of the frustum's width to it's height.\n   * @type {Number}\n   * @default undefined\n   */\n  this.aspectRatio = options.aspectRatio;\n  this._aspectRatio = undefined;\n\n  /**\n   * The distance of the near plane.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.near = defaultValue(options.near, 1.0);\n  this._near = this.near;\n\n  /**\n   * The distance of the far plane.\n   * @type {Number}\n   * @default 500000000.0;\n   */\n  this.far = defaultValue(options.far, 500000000.0);\n  this._far = this.far;\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nOrthographicFrustum.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {OrthographicFrustum} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nOrthographicFrustum.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.width;\n  array[startingIndex++] = value.aspectRatio;\n  array[startingIndex++] = value.near;\n  array[startingIndex] = value.far;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {OrthographicFrustum} [result] The object into which to store the result.\n * @returns {OrthographicFrustum} The modified result parameter or a new OrthographicFrustum instance if one was not provided.\n */\nOrthographicFrustum.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new OrthographicFrustum();\n  }\n\n  result.width = array[startingIndex++];\n  result.aspectRatio = array[startingIndex++];\n  result.near = array[startingIndex++];\n  result.far = array[startingIndex];\n\n  return result;\n};\n\nfunction update(frustum) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(frustum.width) ||\n    !defined(frustum.aspectRatio) ||\n    !defined(frustum.near) ||\n    !defined(frustum.far)\n  ) {\n    throw new DeveloperError(\n      \"width, aspectRatio, near, or far parameters are not set.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var f = frustum._offCenterFrustum;\n\n  if (\n    frustum.width !== frustum._width ||\n    frustum.aspectRatio !== frustum._aspectRatio ||\n    frustum.near !== frustum._near ||\n    frustum.far !== frustum._far\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    if (frustum.aspectRatio < 0) {\n      throw new DeveloperError(\"aspectRatio must be positive.\");\n    }\n    if (frustum.near < 0 || frustum.near > frustum.far) {\n      throw new DeveloperError(\n        \"near must be greater than zero and less than far.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    frustum._aspectRatio = frustum.aspectRatio;\n    frustum._width = frustum.width;\n    frustum._near = frustum.near;\n    frustum._far = frustum.far;\n\n    var ratio = 1.0 / frustum.aspectRatio;\n    f.right = frustum.width * 0.5;\n    f.left = -f.right;\n    f.top = ratio * f.right;\n    f.bottom = -f.top;\n    f.near = frustum.near;\n    f.far = frustum.far;\n  }\n}\n\nObject.defineProperties(OrthographicFrustum.prototype, {\n  /**\n   * Gets the orthographic projection matrix computed from the view frustum.\n   * @memberof OrthographicFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   */\n  projectionMatrix: {\n    get: function () {\n      update(this);\n      return this._offCenterFrustum.projectionMatrix;\n    },\n  },\n});\n\n/**\n * Creates a culling volume for this frustum.\n *\n * @param {Cartesian3} position The eye position.\n * @param {Cartesian3} direction The view direction.\n * @param {Cartesian3} up The up direction.\n * @returns {CullingVolume} A culling volume at the given position and orientation.\n *\n * @example\n * // Check if a bounding volume intersects the frustum.\n * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * var intersect = cullingVolume.computeVisibility(boundingVolume);\n */\nOrthographicFrustum.prototype.computeCullingVolume = function (\n  position,\n  direction,\n  up\n) {\n  update(this);\n  return this._offCenterFrustum.computeCullingVolume(position, direction, up);\n};\n\n/**\n * Returns the pixel's width and height in meters.\n *\n * @param {Number} drawingBufferWidth The width of the drawing buffer.\n * @param {Number} drawingBufferHeight The height of the drawing buffer.\n * @param {Number} distance The distance to the near plane in meters.\n * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\n *\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n * @exception {DeveloperError} pixelRatio must be greater than zero.\n *\n * @example\n * // Example 1\n * // Get the width and height of a pixel.\n * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 0.0, scene.pixelRatio, new Cesium.Cartesian2());\n */\nOrthographicFrustum.prototype.getPixelDimensions = function (\n  drawingBufferWidth,\n  drawingBufferHeight,\n  distance,\n  pixelRatio,\n  result\n) {\n  update(this);\n  return this._offCenterFrustum.getPixelDimensions(\n    drawingBufferWidth,\n    drawingBufferHeight,\n    distance,\n    pixelRatio,\n    result\n  );\n};\n\n/**\n * Returns a duplicate of a OrthographicFrustum instance.\n *\n * @param {OrthographicFrustum} [result] The object onto which to store the result.\n * @returns {OrthographicFrustum} The modified result parameter or a new OrthographicFrustum instance if one was not provided.\n */\nOrthographicFrustum.prototype.clone = function (result) {\n  if (!defined(result)) {\n    result = new OrthographicFrustum();\n  }\n\n  result.aspectRatio = this.aspectRatio;\n  result.width = this.width;\n  result.near = this.near;\n  result.far = this.far;\n\n  // force update of clone to compute matrices\n  result._aspectRatio = undefined;\n  result._width = undefined;\n  result._near = undefined;\n  result._far = undefined;\n\n  this._offCenterFrustum.clone(result._offCenterFrustum);\n\n  return result;\n};\n\n/**\n * Compares the provided OrthographicFrustum componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrthographicFrustum} [other] The right hand side OrthographicFrustum.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nOrthographicFrustum.prototype.equals = function (other) {\n  if (!defined(other) || !(other instanceof OrthographicFrustum)) {\n    return false;\n  }\n\n  update(this);\n  update(other);\n\n  return (\n    this.width === other.width &&\n    this.aspectRatio === other.aspectRatio &&\n    this._offCenterFrustum.equals(other._offCenterFrustum)\n  );\n};\n\n/**\n * Compares the provided OrthographicFrustum componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {OrthographicFrustum} other The right hand side OrthographicFrustum.\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\n */\nOrthographicFrustum.prototype.equalsEpsilon = function (\n  other,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  if (!defined(other) || !(other instanceof OrthographicFrustum)) {\n    return false;\n  }\n\n  update(this);\n  update(other);\n\n  return (\n    CesiumMath.equalsEpsilon(\n      this.width,\n      other.width,\n      relativeEpsilon,\n      absoluteEpsilon\n    ) &&\n    CesiumMath.equalsEpsilon(\n      this.aspectRatio,\n      other.aspectRatio,\n      relativeEpsilon,\n      absoluteEpsilon\n    ) &&\n    this._offCenterFrustum.equalsEpsilon(\n      other._offCenterFrustum,\n      relativeEpsilon,\n      absoluteEpsilon\n    )\n  );\n};\nexport default OrthographicFrustum;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport CullingVolume from \"./CullingVolume.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\n\n/**\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias PerspectiveOffCenterFrustum\n * @constructor\n *\n * @param {Object} [options] An object with the following properties:\n * @param {Number} [options.left] The left clipping plane distance.\n * @param {Number} [options.right] The right clipping plane distance.\n * @param {Number} [options.top] The top clipping plane distance.\n * @param {Number} [options.bottom] The bottom clipping plane distance.\n * @param {Number} [options.near=1.0] The near clipping plane distance.\n * @param {Number} [options.far=500000000.0] The far clipping plane distance.\n *\n * @example\n * var frustum = new Cesium.PerspectiveOffCenterFrustum({\n *     left : -1.0,\n *     right : 1.0,\n *     top : 1.0,\n *     bottom : -1.0,\n *     near : 1.0,\n *     far : 100.0\n * });\n *\n * @see PerspectiveFrustum\n */\nfunction PerspectiveOffCenterFrustum(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * Defines the left clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.left = options.left;\n  this._left = undefined;\n\n  /**\n   * Defines the right clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.right = options.right;\n  this._right = undefined;\n\n  /**\n   * Defines the top clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.top = options.top;\n  this._top = undefined;\n\n  /**\n   * Defines the bottom clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.bottom = options.bottom;\n  this._bottom = undefined;\n\n  /**\n   * The distance of the near plane.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.near = defaultValue(options.near, 1.0);\n  this._near = this.near;\n\n  /**\n   * The distance of the far plane.\n   * @type {Number}\n   * @default 500000000.0\n   */\n  this.far = defaultValue(options.far, 500000000.0);\n  this._far = this.far;\n\n  this._cullingVolume = new CullingVolume();\n  this._perspectiveMatrix = new Matrix4();\n  this._infinitePerspective = new Matrix4();\n}\n\nfunction update(frustum) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(frustum.right) ||\n    !defined(frustum.left) ||\n    !defined(frustum.top) ||\n    !defined(frustum.bottom) ||\n    !defined(frustum.near) ||\n    !defined(frustum.far)\n  ) {\n    throw new DeveloperError(\n      \"right, left, top, bottom, near, or far parameters are not set.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var t = frustum.top;\n  var b = frustum.bottom;\n  var r = frustum.right;\n  var l = frustum.left;\n  var n = frustum.near;\n  var f = frustum.far;\n\n  if (\n    t !== frustum._top ||\n    b !== frustum._bottom ||\n    l !== frustum._left ||\n    r !== frustum._right ||\n    n !== frustum._near ||\n    f !== frustum._far\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    if (frustum.near <= 0 || frustum.near > frustum.far) {\n      throw new DeveloperError(\n        \"near must be greater than zero and less than far.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    frustum._left = l;\n    frustum._right = r;\n    frustum._top = t;\n    frustum._bottom = b;\n    frustum._near = n;\n    frustum._far = f;\n    frustum._perspectiveMatrix = Matrix4.computePerspectiveOffCenter(\n      l,\n      r,\n      b,\n      t,\n      n,\n      f,\n      frustum._perspectiveMatrix\n    );\n    frustum._infinitePerspective = Matrix4.computeInfinitePerspectiveOffCenter(\n      l,\n      r,\n      b,\n      t,\n      n,\n      frustum._infinitePerspective\n    );\n  }\n}\n\nObject.defineProperties(PerspectiveOffCenterFrustum.prototype, {\n  /**\n   * Gets the perspective projection matrix computed from the view frustum.\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveOffCenterFrustum#infiniteProjectionMatrix\n   */\n  projectionMatrix: {\n    get: function () {\n      update(this);\n      return this._perspectiveMatrix;\n    },\n  },\n\n  /**\n   * Gets the perspective projection matrix computed from the view frustum with an infinite far plane.\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveOffCenterFrustum#projectionMatrix\n   */\n  infiniteProjectionMatrix: {\n    get: function () {\n      update(this);\n      return this._infinitePerspective;\n    },\n  },\n});\n\nvar getPlanesRight = new Cartesian3();\nvar getPlanesNearCenter = new Cartesian3();\nvar getPlanesFarCenter = new Cartesian3();\nvar getPlanesNormal = new Cartesian3();\n/**\n * Creates a culling volume for this frustum.\n *\n * @param {Cartesian3} position The eye position.\n * @param {Cartesian3} direction The view direction.\n * @param {Cartesian3} up The up direction.\n * @returns {CullingVolume} A culling volume at the given position and orientation.\n *\n * @example\n * // Check if a bounding volume intersects the frustum.\n * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * var intersect = cullingVolume.computeVisibility(boundingVolume);\n */\nPerspectiveOffCenterFrustum.prototype.computeCullingVolume = function (\n  position,\n  direction,\n  up\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  }\n\n  if (!defined(up)) {\n    throw new DeveloperError(\"up is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var planes = this._cullingVolume.planes;\n\n  var t = this.top;\n  var b = this.bottom;\n  var r = this.right;\n  var l = this.left;\n  var n = this.near;\n  var f = this.far;\n\n  var right = Cartesian3.cross(direction, up, getPlanesRight);\n\n  var nearCenter = getPlanesNearCenter;\n  Cartesian3.multiplyByScalar(direction, n, nearCenter);\n  Cartesian3.add(position, nearCenter, nearCenter);\n\n  var farCenter = getPlanesFarCenter;\n  Cartesian3.multiplyByScalar(direction, f, farCenter);\n  Cartesian3.add(position, farCenter, farCenter);\n\n  var normal = getPlanesNormal;\n\n  //Left plane computation\n  Cartesian3.multiplyByScalar(right, l, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.normalize(normal, normal);\n  Cartesian3.cross(normal, up, normal);\n  Cartesian3.normalize(normal, normal);\n\n  var plane = planes[0];\n  if (!defined(plane)) {\n    plane = planes[0] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position);\n\n  //Right plane computation\n  Cartesian3.multiplyByScalar(right, r, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.cross(up, normal, normal);\n  Cartesian3.normalize(normal, normal);\n\n  plane = planes[1];\n  if (!defined(plane)) {\n    plane = planes[1] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position);\n\n  //Bottom plane computation\n  Cartesian3.multiplyByScalar(up, b, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.cross(right, normal, normal);\n  Cartesian3.normalize(normal, normal);\n\n  plane = planes[2];\n  if (!defined(plane)) {\n    plane = planes[2] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position);\n\n  //Top plane computation\n  Cartesian3.multiplyByScalar(up, t, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.cross(normal, right, normal);\n  Cartesian3.normalize(normal, normal);\n\n  plane = planes[3];\n  if (!defined(plane)) {\n    plane = planes[3] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position);\n\n  //Near plane computation\n  plane = planes[4];\n  if (!defined(plane)) {\n    plane = planes[4] = new Cartesian4();\n  }\n  plane.x = direction.x;\n  plane.y = direction.y;\n  plane.z = direction.z;\n  plane.w = -Cartesian3.dot(direction, nearCenter);\n\n  //Far plane computation\n  Cartesian3.negate(direction, normal);\n\n  plane = planes[5];\n  if (!defined(plane)) {\n    plane = planes[5] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, farCenter);\n\n  return this._cullingVolume;\n};\n\n/**\n * Returns the pixel's width and height in meters.\n *\n * @param {Number} drawingBufferWidth The width of the drawing buffer.\n * @param {Number} drawingBufferHeight The height of the drawing buffer.\n * @param {Number} distance The distance to the near plane in meters.\n * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\n *\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n * @exception {DeveloperError} pixelRatio must be greater than zero.\n *\n * @example\n * // Example 1\n * // Get the width and height of a pixel.\n * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new Cesium.Cartesian2());\n *\n * @example\n * // Example 2\n * // Get the width and height of a pixel if the near plane was set to 'distance'.\n * // For example, get the size of a pixel of an image on a billboard.\n * var position = camera.position;\n * var direction = camera.direction;\n * var toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive\n * var toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector\n * var distance = Cesium.Cartesian3.magnitude(toCenterProj);\n * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, scene.pixelRatio, new Cesium.Cartesian2());\n */\nPerspectiveOffCenterFrustum.prototype.getPixelDimensions = function (\n  drawingBufferWidth,\n  drawingBufferHeight,\n  distance,\n  pixelRatio,\n  result\n) {\n  update(this);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(drawingBufferWidth) || !defined(drawingBufferHeight)) {\n    throw new DeveloperError(\n      \"Both drawingBufferWidth and drawingBufferHeight are required.\"\n    );\n  }\n  if (drawingBufferWidth <= 0) {\n    throw new DeveloperError(\"drawingBufferWidth must be greater than zero.\");\n  }\n  if (drawingBufferHeight <= 0) {\n    throw new DeveloperError(\"drawingBufferHeight must be greater than zero.\");\n  }\n  if (!defined(distance)) {\n    throw new DeveloperError(\"distance is required.\");\n  }\n  if (!defined(pixelRatio)) {\n    throw new DeveloperError(\"pixelRatio is required\");\n  }\n  if (pixelRatio <= 0) {\n    throw new DeveloperError(\"pixelRatio must be greater than zero.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"A result object is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var inverseNear = 1.0 / this.near;\n  var tanTheta = this.top * inverseNear;\n  var pixelHeight =\n    (2.0 * pixelRatio * distance * tanTheta) / drawingBufferHeight;\n  tanTheta = this.right * inverseNear;\n  var pixelWidth =\n    (2.0 * pixelRatio * distance * tanTheta) / drawingBufferWidth;\n\n  result.x = pixelWidth;\n  result.y = pixelHeight;\n  return result;\n};\n\n/**\n * Returns a duplicate of a PerspectiveOffCenterFrustum instance.\n *\n * @param {PerspectiveOffCenterFrustum} [result] The object onto which to store the result.\n * @returns {PerspectiveOffCenterFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\n */\nPerspectiveOffCenterFrustum.prototype.clone = function (result) {\n  if (!defined(result)) {\n    result = new PerspectiveOffCenterFrustum();\n  }\n\n  result.right = this.right;\n  result.left = this.left;\n  result.top = this.top;\n  result.bottom = this.bottom;\n  result.near = this.near;\n  result.far = this.far;\n\n  // force update of clone to compute matrices\n  result._left = undefined;\n  result._right = undefined;\n  result._top = undefined;\n  result._bottom = undefined;\n  result._near = undefined;\n  result._far = undefined;\n\n  return result;\n};\n\n/**\n * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {PerspectiveOffCenterFrustum} [other] The right hand side PerspectiveOffCenterFrustum.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nPerspectiveOffCenterFrustum.prototype.equals = function (other) {\n  return (\n    defined(other) &&\n    other instanceof PerspectiveOffCenterFrustum &&\n    this.right === other.right &&\n    this.left === other.left &&\n    this.top === other.top &&\n    this.bottom === other.bottom &&\n    this.near === other.near &&\n    this.far === other.far\n  );\n};\n\n/**\n * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {PerspectiveOffCenterFrustum} other The right hand side PerspectiveOffCenterFrustum.\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\n */\nPerspectiveOffCenterFrustum.prototype.equalsEpsilon = function (\n  other,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return (\n    other === this ||\n    (defined(other) &&\n      other instanceof PerspectiveOffCenterFrustum &&\n      CesiumMath.equalsEpsilon(\n        this.right,\n        other.right,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.left,\n        other.left,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.top,\n        other.top,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.bottom,\n        other.bottom,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.near,\n        other.near,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.far,\n        other.far,\n        relativeEpsilon,\n        absoluteEpsilon\n      ))\n  );\n};\nexport default PerspectiveOffCenterFrustum;\n","import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport PerspectiveOffCenterFrustum from \"./PerspectiveOffCenterFrustum.js\";\n\n/**\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias PerspectiveFrustum\n * @constructor\n *\n * @param {Object} [options] An object with the following properties:\n * @param {Number} [options.fov] The angle of the field of view (FOV), in radians.\n * @param {Number} [options.aspectRatio] The aspect ratio of the frustum's width to it's height.\n * @param {Number} [options.near=1.0] The distance of the near plane.\n * @param {Number} [options.far=500000000.0] The distance of the far plane.\n * @param {Number} [options.xOffset=0.0] The offset in the x direction.\n * @param {Number} [options.yOffset=0.0] The offset in the y direction.\n *\n * @example\n * var frustum = new Cesium.PerspectiveFrustum({\n *     fov : Cesium.Math.PI_OVER_THREE,\n *     aspectRatio : canvas.clientWidth / canvas.clientHeight\n *     near : 1.0,\n *     far : 1000.0\n * });\n *\n * @see PerspectiveOffCenterFrustum\n */\nfunction PerspectiveFrustum(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._offCenterFrustum = new PerspectiveOffCenterFrustum();\n\n  /**\n   * The angle of the field of view (FOV), in radians.  This angle will be used\n   * as the horizontal FOV if the width is greater than the height, otherwise\n   * it will be the vertical FOV.\n   * @type {Number}\n   * @default undefined\n   */\n  this.fov = options.fov;\n  this._fov = undefined;\n  this._fovy = undefined;\n\n  this._sseDenominator = undefined;\n\n  /**\n   * The aspect ratio of the frustum's width to it's height.\n   * @type {Number}\n   * @default undefined\n   */\n  this.aspectRatio = options.aspectRatio;\n  this._aspectRatio = undefined;\n\n  /**\n   * The distance of the near plane.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.near = defaultValue(options.near, 1.0);\n  this._near = this.near;\n\n  /**\n   * The distance of the far plane.\n   * @type {Number}\n   * @default 500000000.0\n   */\n  this.far = defaultValue(options.far, 500000000.0);\n  this._far = this.far;\n\n  /**\n   * Offsets the frustum in the x direction.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.xOffset = defaultValue(options.xOffset, 0.0);\n  this._xOffset = this.xOffset;\n\n  /**\n   * Offsets the frustum in the y direction.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.yOffset = defaultValue(options.yOffset, 0.0);\n  this._yOffset = this.yOffset;\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nPerspectiveFrustum.packedLength = 6;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PerspectiveFrustum} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nPerspectiveFrustum.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.fov;\n  array[startingIndex++] = value.aspectRatio;\n  array[startingIndex++] = value.near;\n  array[startingIndex++] = value.far;\n  array[startingIndex++] = value.xOffset;\n  array[startingIndex] = value.yOffset;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PerspectiveFrustum} [result] The object into which to store the result.\n * @returns {PerspectiveFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\n */\nPerspectiveFrustum.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new PerspectiveFrustum();\n  }\n\n  result.fov = array[startingIndex++];\n  result.aspectRatio = array[startingIndex++];\n  result.near = array[startingIndex++];\n  result.far = array[startingIndex++];\n  result.xOffset = array[startingIndex++];\n  result.yOffset = array[startingIndex];\n\n  return result;\n};\n\nfunction update(frustum) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(frustum.fov) ||\n    !defined(frustum.aspectRatio) ||\n    !defined(frustum.near) ||\n    !defined(frustum.far)\n  ) {\n    throw new DeveloperError(\n      \"fov, aspectRatio, near, or far parameters are not set.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var f = frustum._offCenterFrustum;\n\n  if (\n    frustum.fov !== frustum._fov ||\n    frustum.aspectRatio !== frustum._aspectRatio ||\n    frustum.near !== frustum._near ||\n    frustum.far !== frustum._far ||\n    frustum.xOffset !== frustum._xOffset ||\n    frustum.yOffset !== frustum._yOffset\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    if (frustum.fov < 0 || frustum.fov >= Math.PI) {\n      throw new DeveloperError(\"fov must be in the range [0, PI).\");\n    }\n\n    if (frustum.aspectRatio < 0) {\n      throw new DeveloperError(\"aspectRatio must be positive.\");\n    }\n\n    if (frustum.near < 0 || frustum.near > frustum.far) {\n      throw new DeveloperError(\n        \"near must be greater than zero and less than far.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    frustum._aspectRatio = frustum.aspectRatio;\n    frustum._fov = frustum.fov;\n    frustum._fovy =\n      frustum.aspectRatio <= 1\n        ? frustum.fov\n        : Math.atan(Math.tan(frustum.fov * 0.5) / frustum.aspectRatio) * 2.0;\n    frustum._near = frustum.near;\n    frustum._far = frustum.far;\n    frustum._sseDenominator = 2.0 * Math.tan(0.5 * frustum._fovy);\n    frustum._xOffset = frustum.xOffset;\n    frustum._yOffset = frustum.yOffset;\n\n    f.top = frustum.near * Math.tan(0.5 * frustum._fovy);\n    f.bottom = -f.top;\n    f.right = frustum.aspectRatio * f.top;\n    f.left = -f.right;\n    f.near = frustum.near;\n    f.far = frustum.far;\n\n    f.right += frustum.xOffset;\n    f.left += frustum.xOffset;\n    f.top += frustum.yOffset;\n    f.bottom += frustum.yOffset;\n  }\n}\n\nObject.defineProperties(PerspectiveFrustum.prototype, {\n  /**\n   * Gets the perspective projection matrix computed from the view frustum.\n   * @memberof PerspectiveFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveFrustum#infiniteProjectionMatrix\n   */\n  projectionMatrix: {\n    get: function () {\n      update(this);\n      return this._offCenterFrustum.projectionMatrix;\n    },\n  },\n\n  /**\n   * The perspective projection matrix computed from the view frustum with an infinite far plane.\n   * @memberof PerspectiveFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveFrustum#projectionMatrix\n   */\n  infiniteProjectionMatrix: {\n    get: function () {\n      update(this);\n      return this._offCenterFrustum.infiniteProjectionMatrix;\n    },\n  },\n\n  /**\n   * Gets the angle of the vertical field of view, in radians.\n   * @memberof PerspectiveFrustum.prototype\n   * @type {Number}\n   * @readonly\n   * @default undefined\n   */\n  fovy: {\n    get: function () {\n      update(this);\n      return this._fovy;\n    },\n  },\n\n  /**\n   * @readonly\n   * @private\n   */\n  sseDenominator: {\n    get: function () {\n      update(this);\n      return this._sseDenominator;\n    },\n  },\n});\n\n/**\n * Creates a culling volume for this frustum.\n *\n * @param {Cartesian3} position The eye position.\n * @param {Cartesian3} direction The view direction.\n * @param {Cartesian3} up The up direction.\n * @returns {CullingVolume} A culling volume at the given position and orientation.\n *\n * @example\n * // Check if a bounding volume intersects the frustum.\n * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * var intersect = cullingVolume.computeVisibility(boundingVolume);\n */\nPerspectiveFrustum.prototype.computeCullingVolume = function (\n  position,\n  direction,\n  up\n) {\n  update(this);\n  return this._offCenterFrustum.computeCullingVolume(position, direction, up);\n};\n\n/**\n * Returns the pixel's width and height in meters.\n *\n * @param {Number} drawingBufferWidth The width of the drawing buffer.\n * @param {Number} drawingBufferHeight The height of the drawing buffer.\n * @param {Number} distance The distance to the near plane in meters.\n * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\n *\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n * @exception {DeveloperError} pixelRatio must be greater than zero.\n *\n * @example\n * // Example 1\n * // Get the width and height of a pixel.\n * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new Cesium.Cartesian2());\n *\n * @example\n * // Example 2\n * // Get the width and height of a pixel if the near plane was set to 'distance'.\n * // For example, get the size of a pixel of an image on a billboard.\n * var position = camera.position;\n * var direction = camera.direction;\n * var toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive\n * var toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector\n * var distance = Cesium.Cartesian3.magnitude(toCenterProj);\n * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, scene.pixelRatio, new Cesium.Cartesian2());\n */\nPerspectiveFrustum.prototype.getPixelDimensions = function (\n  drawingBufferWidth,\n  drawingBufferHeight,\n  distance,\n  pixelRatio,\n  result\n) {\n  update(this);\n  return this._offCenterFrustum.getPixelDimensions(\n    drawingBufferWidth,\n    drawingBufferHeight,\n    distance,\n    pixelRatio,\n    result\n  );\n};\n\n/**\n * Returns a duplicate of a PerspectiveFrustum instance.\n *\n * @param {PerspectiveFrustum} [result] The object onto which to store the result.\n * @returns {PerspectiveFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\n */\nPerspectiveFrustum.prototype.clone = function (result) {\n  if (!defined(result)) {\n    result = new PerspectiveFrustum();\n  }\n\n  result.aspectRatio = this.aspectRatio;\n  result.fov = this.fov;\n  result.near = this.near;\n  result.far = this.far;\n\n  // force update of clone to compute matrices\n  result._aspectRatio = undefined;\n  result._fov = undefined;\n  result._near = undefined;\n  result._far = undefined;\n\n  this._offCenterFrustum.clone(result._offCenterFrustum);\n\n  return result;\n};\n\n/**\n * Compares the provided PerspectiveFrustum componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {PerspectiveFrustum} [other] The right hand side PerspectiveFrustum.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nPerspectiveFrustum.prototype.equals = function (other) {\n  if (!defined(other) || !(other instanceof PerspectiveFrustum)) {\n    return false;\n  }\n\n  update(this);\n  update(other);\n\n  return (\n    this.fov === other.fov &&\n    this.aspectRatio === other.aspectRatio &&\n    this._offCenterFrustum.equals(other._offCenterFrustum)\n  );\n};\n\n/**\n * Compares the provided PerspectiveFrustum componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {PerspectiveFrustum} other The right hand side PerspectiveFrustum.\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\n */\nPerspectiveFrustum.prototype.equalsEpsilon = function (\n  other,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  if (!defined(other) || !(other instanceof PerspectiveFrustum)) {\n    return false;\n  }\n\n  update(this);\n  update(other);\n\n  return (\n    CesiumMath.equalsEpsilon(\n      this.fov,\n      other.fov,\n      relativeEpsilon,\n      absoluteEpsilon\n    ) &&\n    CesiumMath.equalsEpsilon(\n      this.aspectRatio,\n      other.aspectRatio,\n      relativeEpsilon,\n      absoluteEpsilon\n    ) &&\n    this._offCenterFrustum.equalsEpsilon(\n      other._offCenterFrustum,\n      relativeEpsilon,\n      absoluteEpsilon\n    )\n  );\n};\nexport default PerspectiveFrustum;\n","import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport OrthographicFrustum from \"./OrthographicFrustum.js\";\nimport PerspectiveFrustum from \"./PerspectiveFrustum.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nvar PERSPECTIVE = 0;\nvar ORTHOGRAPHIC = 1;\n\n/**\n * Describes a frustum at the given the origin and orientation.\n *\n * @alias FrustumGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {PerspectiveFrustum|OrthographicFrustum} options.frustum The frustum.\n * @param {Cartesian3} options.origin The origin of the frustum.\n * @param {Quaternion} options.orientation The orientation of the frustum.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n */\nfunction FrustumGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.frustum\", options.frustum);\n  Check.typeOf.object(\"options.origin\", options.origin);\n  Check.typeOf.object(\"options.orientation\", options.orientation);\n  //>>includeEnd('debug');\n\n  var frustum = options.frustum;\n  var orientation = options.orientation;\n  var origin = options.origin;\n  var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n\n  // This is private because it is used by DebugCameraPrimitive to draw a multi-frustum by\n  // creating multiple FrustumGeometrys. This way the near plane of one frustum doesn't overlap\n  // the far plane of another.\n  var drawNearPlane = defaultValue(options._drawNearPlane, true);\n\n  var frustumType;\n  var frustumPackedLength;\n  if (frustum instanceof PerspectiveFrustum) {\n    frustumType = PERSPECTIVE;\n    frustumPackedLength = PerspectiveFrustum.packedLength;\n  } else if (frustum instanceof OrthographicFrustum) {\n    frustumType = ORTHOGRAPHIC;\n    frustumPackedLength = OrthographicFrustum.packedLength;\n  }\n\n  this._frustumType = frustumType;\n  this._frustum = frustum.clone();\n  this._origin = Cartesian3.clone(origin);\n  this._orientation = Quaternion.clone(orientation);\n  this._drawNearPlane = drawNearPlane;\n  this._vertexFormat = vertexFormat;\n  this._workerName = \"createFrustumGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  this.packedLength =\n    2 +\n    frustumPackedLength +\n    Cartesian3.packedLength +\n    Quaternion.packedLength +\n    VertexFormat.packedLength;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {FrustumGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nFrustumGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var frustumType = value._frustumType;\n  var frustum = value._frustum;\n\n  array[startingIndex++] = frustumType;\n\n  if (frustumType === PERSPECTIVE) {\n    PerspectiveFrustum.pack(frustum, array, startingIndex);\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    OrthographicFrustum.pack(frustum, array, startingIndex);\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n\n  Cartesian3.pack(value._origin, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n  Quaternion.pack(value._orientation, array, startingIndex);\n  startingIndex += Quaternion.packedLength;\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n  array[startingIndex] = value._drawNearPlane ? 1.0 : 0.0;\n\n  return array;\n};\n\nvar scratchPackPerspective = new PerspectiveFrustum();\nvar scratchPackOrthographic = new OrthographicFrustum();\nvar scratchPackQuaternion = new Quaternion();\nvar scratchPackorigin = new Cartesian3();\nvar scratchVertexFormat = new VertexFormat();\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {FrustumGeometry} [result] The object into which to store the result.\n */\nFrustumGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var frustumType = array[startingIndex++];\n\n  var frustum;\n  if (frustumType === PERSPECTIVE) {\n    frustum = PerspectiveFrustum.unpack(\n      array,\n      startingIndex,\n      scratchPackPerspective\n    );\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    frustum = OrthographicFrustum.unpack(\n      array,\n      startingIndex,\n      scratchPackOrthographic\n    );\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n\n  var origin = Cartesian3.unpack(array, startingIndex, scratchPackorigin);\n  startingIndex += Cartesian3.packedLength;\n  var orientation = Quaternion.unpack(\n    array,\n    startingIndex,\n    scratchPackQuaternion\n  );\n  startingIndex += Quaternion.packedLength;\n  var vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += VertexFormat.packedLength;\n  var drawNearPlane = array[startingIndex] === 1.0;\n\n  if (!defined(result)) {\n    return new FrustumGeometry({\n      frustum: frustum,\n      origin: origin,\n      orientation: orientation,\n      vertexFormat: vertexFormat,\n      _drawNearPlane: drawNearPlane,\n    });\n  }\n\n  var frustumResult =\n    frustumType === result._frustumType ? result._frustum : undefined;\n  result._frustum = frustum.clone(frustumResult);\n\n  result._frustumType = frustumType;\n  result._origin = Cartesian3.clone(origin, result._origin);\n  result._orientation = Quaternion.clone(orientation, result._orientation);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._drawNearPlane = drawNearPlane;\n\n  return result;\n};\n\nfunction getAttributes(\n  offset,\n  normals,\n  tangents,\n  bitangents,\n  st,\n  normal,\n  tangent,\n  bitangent\n) {\n  var stOffset = (offset / 3) * 2;\n\n  for (var i = 0; i < 4; ++i) {\n    if (defined(normals)) {\n      normals[offset] = normal.x;\n      normals[offset + 1] = normal.y;\n      normals[offset + 2] = normal.z;\n    }\n    if (defined(tangents)) {\n      tangents[offset] = tangent.x;\n      tangents[offset + 1] = tangent.y;\n      tangents[offset + 2] = tangent.z;\n    }\n    if (defined(bitangents)) {\n      bitangents[offset] = bitangent.x;\n      bitangents[offset + 1] = bitangent.y;\n      bitangents[offset + 2] = bitangent.z;\n    }\n    offset += 3;\n  }\n\n  st[stOffset] = 0.0;\n  st[stOffset + 1] = 0.0;\n  st[stOffset + 2] = 1.0;\n  st[stOffset + 3] = 0.0;\n  st[stOffset + 4] = 1.0;\n  st[stOffset + 5] = 1.0;\n  st[stOffset + 6] = 0.0;\n  st[stOffset + 7] = 1.0;\n}\n\nvar scratchRotationMatrix = new Matrix3();\nvar scratchViewMatrix = new Matrix4();\nvar scratchInverseMatrix = new Matrix4();\n\nvar scratchXDirection = new Cartesian3();\nvar scratchYDirection = new Cartesian3();\nvar scratchZDirection = new Cartesian3();\nvar scratchNegativeX = new Cartesian3();\nvar scratchNegativeY = new Cartesian3();\nvar scratchNegativeZ = new Cartesian3();\n\nvar frustumSplits = new Array(3);\n\nvar frustumCornersNDC = new Array(4);\nfrustumCornersNDC[0] = new Cartesian4(-1.0, -1.0, 1.0, 1.0);\nfrustumCornersNDC[1] = new Cartesian4(1.0, -1.0, 1.0, 1.0);\nfrustumCornersNDC[2] = new Cartesian4(1.0, 1.0, 1.0, 1.0);\nfrustumCornersNDC[3] = new Cartesian4(-1.0, 1.0, 1.0, 1.0);\n\nvar scratchFrustumCorners = new Array(4);\nfor (var i = 0; i < 4; ++i) {\n  scratchFrustumCorners[i] = new Cartesian4();\n}\n\nFrustumGeometry._computeNearFarPlanes = function (\n  origin,\n  orientation,\n  frustumType,\n  frustum,\n  positions,\n  xDirection,\n  yDirection,\n  zDirection\n) {\n  var rotationMatrix = Matrix3.fromQuaternion(\n    orientation,\n    scratchRotationMatrix\n  );\n  var x = defaultValue(xDirection, scratchXDirection);\n  var y = defaultValue(yDirection, scratchYDirection);\n  var z = defaultValue(zDirection, scratchZDirection);\n\n  x = Matrix3.getColumn(rotationMatrix, 0, x);\n  y = Matrix3.getColumn(rotationMatrix, 1, y);\n  z = Matrix3.getColumn(rotationMatrix, 2, z);\n\n  Cartesian3.normalize(x, x);\n  Cartesian3.normalize(y, y);\n  Cartesian3.normalize(z, z);\n\n  Cartesian3.negate(x, x);\n\n  var view = Matrix4.computeView(origin, z, y, x, scratchViewMatrix);\n\n  var inverseView;\n  var inverseViewProjection;\n  if (frustumType === PERSPECTIVE) {\n    var projection = frustum.projectionMatrix;\n    var viewProjection = Matrix4.multiply(\n      projection,\n      view,\n      scratchInverseMatrix\n    );\n    inverseViewProjection = Matrix4.inverse(\n      viewProjection,\n      scratchInverseMatrix\n    );\n  } else {\n    inverseView = Matrix4.inverseTransformation(view, scratchInverseMatrix);\n  }\n\n  if (defined(inverseViewProjection)) {\n    frustumSplits[0] = frustum.near;\n    frustumSplits[1] = frustum.far;\n  } else {\n    frustumSplits[0] = 0.0;\n    frustumSplits[1] = frustum.near;\n    frustumSplits[2] = frustum.far;\n  }\n\n  for (var i = 0; i < 2; ++i) {\n    for (var j = 0; j < 4; ++j) {\n      var corner = Cartesian4.clone(\n        frustumCornersNDC[j],\n        scratchFrustumCorners[j]\n      );\n\n      if (!defined(inverseViewProjection)) {\n        if (defined(frustum._offCenterFrustum)) {\n          frustum = frustum._offCenterFrustum;\n        }\n\n        var near = frustumSplits[i];\n        var far = frustumSplits[i + 1];\n\n        corner.x =\n          (corner.x * (frustum.right - frustum.left) +\n            frustum.left +\n            frustum.right) *\n          0.5;\n        corner.y =\n          (corner.y * (frustum.top - frustum.bottom) +\n            frustum.bottom +\n            frustum.top) *\n          0.5;\n        corner.z = (corner.z * (near - far) - near - far) * 0.5;\n        corner.w = 1.0;\n\n        Matrix4.multiplyByVector(inverseView, corner, corner);\n      } else {\n        corner = Matrix4.multiplyByVector(\n          inverseViewProjection,\n          corner,\n          corner\n        );\n\n        // Reverse perspective divide\n        var w = 1.0 / corner.w;\n        Cartesian3.multiplyByScalar(corner, w, corner);\n\n        Cartesian3.subtract(corner, origin, corner);\n        Cartesian3.normalize(corner, corner);\n\n        var fac = Cartesian3.dot(z, corner);\n        Cartesian3.multiplyByScalar(corner, frustumSplits[i] / fac, corner);\n        Cartesian3.add(corner, origin, corner);\n      }\n\n      positions[12 * i + j * 3] = corner.x;\n      positions[12 * i + j * 3 + 1] = corner.y;\n      positions[12 * i + j * 3 + 2] = corner.z;\n    }\n  }\n};\n\n/**\n * Computes the geometric representation of a frustum, including its vertices, indices, and a bounding sphere.\n *\n * @param {FrustumGeometry} frustumGeometry A description of the frustum.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nFrustumGeometry.createGeometry = function (frustumGeometry) {\n  var frustumType = frustumGeometry._frustumType;\n  var frustum = frustumGeometry._frustum;\n  var origin = frustumGeometry._origin;\n  var orientation = frustumGeometry._orientation;\n  var drawNearPlane = frustumGeometry._drawNearPlane;\n  var vertexFormat = frustumGeometry._vertexFormat;\n\n  var numberOfPlanes = drawNearPlane ? 6 : 5;\n  var positions = new Float64Array(3 * 4 * 6);\n  FrustumGeometry._computeNearFarPlanes(\n    origin,\n    orientation,\n    frustumType,\n    frustum,\n    positions\n  );\n\n  // -x plane\n  var offset = 3 * 4 * 2;\n  positions[offset] = positions[3 * 4];\n  positions[offset + 1] = positions[3 * 4 + 1];\n  positions[offset + 2] = positions[3 * 4 + 2];\n  positions[offset + 3] = positions[0];\n  positions[offset + 4] = positions[1];\n  positions[offset + 5] = positions[2];\n  positions[offset + 6] = positions[3 * 3];\n  positions[offset + 7] = positions[3 * 3 + 1];\n  positions[offset + 8] = positions[3 * 3 + 2];\n  positions[offset + 9] = positions[3 * 7];\n  positions[offset + 10] = positions[3 * 7 + 1];\n  positions[offset + 11] = positions[3 * 7 + 2];\n\n  // -y plane\n  offset += 3 * 4;\n  positions[offset] = positions[3 * 5];\n  positions[offset + 1] = positions[3 * 5 + 1];\n  positions[offset + 2] = positions[3 * 5 + 2];\n  positions[offset + 3] = positions[3];\n  positions[offset + 4] = positions[3 + 1];\n  positions[offset + 5] = positions[3 + 2];\n  positions[offset + 6] = positions[0];\n  positions[offset + 7] = positions[1];\n  positions[offset + 8] = positions[2];\n  positions[offset + 9] = positions[3 * 4];\n  positions[offset + 10] = positions[3 * 4 + 1];\n  positions[offset + 11] = positions[3 * 4 + 2];\n\n  // +x plane\n  offset += 3 * 4;\n  positions[offset] = positions[3];\n  positions[offset + 1] = positions[3 + 1];\n  positions[offset + 2] = positions[3 + 2];\n  positions[offset + 3] = positions[3 * 5];\n  positions[offset + 4] = positions[3 * 5 + 1];\n  positions[offset + 5] = positions[3 * 5 + 2];\n  positions[offset + 6] = positions[3 * 6];\n  positions[offset + 7] = positions[3 * 6 + 1];\n  positions[offset + 8] = positions[3 * 6 + 2];\n  positions[offset + 9] = positions[3 * 2];\n  positions[offset + 10] = positions[3 * 2 + 1];\n  positions[offset + 11] = positions[3 * 2 + 2];\n\n  // +y plane\n  offset += 3 * 4;\n  positions[offset] = positions[3 * 2];\n  positions[offset + 1] = positions[3 * 2 + 1];\n  positions[offset + 2] = positions[3 * 2 + 2];\n  positions[offset + 3] = positions[3 * 6];\n  positions[offset + 4] = positions[3 * 6 + 1];\n  positions[offset + 5] = positions[3 * 6 + 2];\n  positions[offset + 6] = positions[3 * 7];\n  positions[offset + 7] = positions[3 * 7 + 1];\n  positions[offset + 8] = positions[3 * 7 + 2];\n  positions[offset + 9] = positions[3 * 3];\n  positions[offset + 10] = positions[3 * 3 + 1];\n  positions[offset + 11] = positions[3 * 3 + 2];\n\n  if (!drawNearPlane) {\n    positions = positions.subarray(3 * 4);\n  }\n\n  var attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    }),\n  });\n\n  if (\n    defined(vertexFormat.normal) ||\n    defined(vertexFormat.tangent) ||\n    defined(vertexFormat.bitangent) ||\n    defined(vertexFormat.st)\n  ) {\n    var normals = defined(vertexFormat.normal)\n      ? new Float32Array(3 * 4 * numberOfPlanes)\n      : undefined;\n    var tangents = defined(vertexFormat.tangent)\n      ? new Float32Array(3 * 4 * numberOfPlanes)\n      : undefined;\n    var bitangents = defined(vertexFormat.bitangent)\n      ? new Float32Array(3 * 4 * numberOfPlanes)\n      : undefined;\n    var st = defined(vertexFormat.st)\n      ? new Float32Array(2 * 4 * numberOfPlanes)\n      : undefined;\n\n    var x = scratchXDirection;\n    var y = scratchYDirection;\n    var z = scratchZDirection;\n\n    var negativeX = Cartesian3.negate(x, scratchNegativeX);\n    var negativeY = Cartesian3.negate(y, scratchNegativeY);\n    var negativeZ = Cartesian3.negate(z, scratchNegativeZ);\n\n    offset = 0;\n    if (drawNearPlane) {\n      getAttributes(offset, normals, tangents, bitangents, st, negativeZ, x, y); // near\n      offset += 3 * 4;\n    }\n    getAttributes(offset, normals, tangents, bitangents, st, z, negativeX, y); // far\n    offset += 3 * 4;\n    getAttributes(\n      offset,\n      normals,\n      tangents,\n      bitangents,\n      st,\n      negativeX,\n      negativeZ,\n      y\n    ); // -x\n    offset += 3 * 4;\n    getAttributes(\n      offset,\n      normals,\n      tangents,\n      bitangents,\n      st,\n      negativeY,\n      negativeZ,\n      negativeX\n    ); // -y\n    offset += 3 * 4;\n    getAttributes(offset, normals, tangents, bitangents, st, x, z, y); // +x\n    offset += 3 * 4;\n    getAttributes(offset, normals, tangents, bitangents, st, y, z, negativeX); // +y\n\n    if (defined(normals)) {\n      attributes.normal = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: normals,\n      });\n    }\n    if (defined(tangents)) {\n      attributes.tangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: tangents,\n      });\n    }\n    if (defined(bitangents)) {\n      attributes.bitangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: bitangents,\n      });\n    }\n    if (defined(st)) {\n      attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: st,\n      });\n    }\n  }\n\n  var indices = new Uint16Array(6 * numberOfPlanes);\n  for (var i = 0; i < numberOfPlanes; ++i) {\n    var indexOffset = i * 6;\n    var index = i * 4;\n\n    indices[indexOffset] = index;\n    indices[indexOffset + 1] = index + 1;\n    indices[indexOffset + 2] = index + 2;\n    indices[indexOffset + 3] = index;\n    indices[indexOffset + 4] = index + 2;\n    indices[indexOffset + 5] = index + 3;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: BoundingSphere.fromVertices(positions),\n  });\n};\nexport default FrustumGeometry;\n"],"names":["CullingVolume","planes","this","defaultValue","faces","Cartesian3","clone","UNIT_X","UNIT_Y","UNIT_Z","scratchPlaneCenter","scratchPlaneNormal","scratchPlane","Plane","OrthographicOffCenterFrustum","options","EMPTY_OBJECT","left","_left","undefined","right","_right","top","_top","bottom","_bottom","near","_near","far","_far","_cullingVolume","_orthographicMatrix","Matrix4","update","frustum","defined","DeveloperError","computeOrthographicOffCenter","fromBoundingSphere","boundingSphere","result","length","center","radius","planeIndex","i","faceNormal","plane0","plane1","Cartesian4","multiplyByScalar","add","x","y","z","w","dot","negate","prototype","computeVisibility","boundingVolume","intersecting","k","len","intersectPlane","fromCartesian4","Intersect","OUTSIDE","INTERSECTING","INSIDE","computeVisibilityWithPlaneMask","parentPlaneMask","MASK_OUTSIDE","MASK_INSIDE","mask","flag","MASK_INDETERMINATE","Object","defineProperties","projectionMatrix","get","getPlanesRight","getPlanesNearCenter","getPlanesPoint","negateScratch","OrthographicFrustum","_offCenterFrustum","width","_width","aspectRatio","_aspectRatio","f","ratio","PerspectiveOffCenterFrustum","_perspectiveMatrix","_infinitePerspective","t","b","r","l","n","computePerspectiveOffCenter","computeInfinitePerspectiveOffCenter","computeCullingVolume","position","direction","up","cross","normalize","nearCenter","point","plane","getPixelDimensions","drawingBufferWidth","drawingBufferHeight","distance","pixelRatio","frustumWidth","pixelHeight","equals","other","equalsEpsilon","relativeEpsilon","absoluteEpsilon","CesiumMath","packedLength","pack","value","array","startingIndex","Check","typeOf","object","unpack","infiniteProjectionMatrix","getPlanesFarCenter","getPlanesNormal","PerspectiveFrustum","fov","_fov","_fovy","_sseDenominator","xOffset","_xOffset","yOffset","_yOffset","Math","PI","atan","tan","farCenter","normal","subtract","inverseNear","tanTheta","fovy","sseDenominator","FrustumGeometry","origin","orientation","frustumType","frustumPackedLength","vertexFormat","VertexFormat","DEFAULT","drawNearPlane","_drawNearPlane","_frustumType","_frustum","_origin","_orientation","Quaternion","_vertexFormat","_workerName","scratchPackPerspective","scratchPackOrthographic","scratchPackQuaternion","scratchPackorigin","scratchVertexFormat","getAttributes","offset","normals","tangents","bitangents","st","tangent","bitangent","stOffset","frustumResult","scratchRotationMatrix","Matrix3","scratchViewMatrix","scratchInverseMatrix","scratchXDirection","scratchYDirection","scratchZDirection","scratchNegativeX","scratchNegativeY","scratchNegativeZ","frustumSplits","Array","frustumCornersNDC","scratchFrustumCorners","_computeNearFarPlanes","positions","xDirection","yDirection","zDirection","rotationMatrix","fromQuaternion","getColumn","inverseView","inverseViewProjection","view","computeView","projection","viewProjection","multiply","inverse","inverseTransformation","j","corner","multiplyByVector","fac","createGeometry","frustumGeometry","numberOfPlanes","Float64Array","subarray","attributes","GeometryAttributes","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","Float32Array","negativeX","negativeY","negativeZ","FLOAT","indices","Uint16Array","indexOffset","index","Geometry","primitiveType","PrimitiveType","TRIANGLES","BoundingSphere","fromVertices"],"mappings":"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"}