{"version":3,"file":"createVerticesFromGoogleEarthEnterpriseBuffer.js","sources":["../../../../Source/WorkersES6/createVerticesFromGoogleEarthEnterpriseBuffer.js"],"sourcesContent":["import AxisAlignedBoundingBox from \"../Core/AxisAlignedBoundingBox.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EllipsoidalOccluder from \"../Core/EllipsoidalOccluder.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TerrainEncoding from \"../Core/TerrainEncoding.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nimport createTaskProcessorWorker from \"./createTaskProcessorWorker.js\";\n\nvar sizeOfUint16 = Uint16Array.BYTES_PER_ELEMENT;\nvar sizeOfInt32 = Int32Array.BYTES_PER_ELEMENT;\nvar sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\nvar sizeOfFloat = Float32Array.BYTES_PER_ELEMENT;\nvar sizeOfDouble = Float64Array.BYTES_PER_ELEMENT;\n\nfunction indexOfEpsilon(arr, elem, elemType) {\n  elemType = defaultValue(elemType, CesiumMath);\n  var count = arr.length;\n  for (var i = 0; i < count; ++i) {\n    if (elemType.equalsEpsilon(arr[i], elem, CesiumMath.EPSILON12)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction createVerticesFromGoogleEarthEnterpriseBuffer(\n  parameters,\n  transferableObjects\n) {\n  parameters.ellipsoid = Ellipsoid.clone(parameters.ellipsoid);\n  parameters.rectangle = Rectangle.clone(parameters.rectangle);\n\n  var statistics = processBuffer(\n    parameters.buffer,\n    parameters.relativeToCenter,\n    parameters.ellipsoid,\n    parameters.rectangle,\n    parameters.nativeRectangle,\n    parameters.exaggeration,\n    parameters.skirtHeight,\n    parameters.includeWebMercatorT,\n    parameters.negativeAltitudeExponentBias,\n    parameters.negativeElevationThreshold\n  );\n  var vertices = statistics.vertices;\n  transferableObjects.push(vertices.buffer);\n  var indices = statistics.indices;\n  transferableObjects.push(indices.buffer);\n\n  return {\n    vertices: vertices.buffer,\n    indices: indices.buffer,\n    numberOfAttributes: statistics.encoding.getStride(),\n    minimumHeight: statistics.minimumHeight,\n    maximumHeight: statistics.maximumHeight,\n    boundingSphere3D: statistics.boundingSphere3D,\n    orientedBoundingBox: statistics.orientedBoundingBox,\n    occludeePointInScaledSpace: statistics.occludeePointInScaledSpace,\n    encoding: statistics.encoding,\n    vertexCountWithoutSkirts: statistics.vertexCountWithoutSkirts,\n    indexCountWithoutSkirts: statistics.indexCountWithoutSkirts,\n    westIndicesSouthToNorth: statistics.westIndicesSouthToNorth,\n    southIndicesEastToWest: statistics.southIndicesEastToWest,\n    eastIndicesNorthToSouth: statistics.eastIndicesNorthToSouth,\n    northIndicesWestToEast: statistics.northIndicesWestToEast,\n  };\n}\n\nvar scratchCartographic = new Cartographic();\nvar scratchCartesian = new Cartesian3();\nvar minimumScratch = new Cartesian3();\nvar maximumScratch = new Cartesian3();\nvar matrix4Scratch = new Matrix4();\n\nfunction processBuffer(\n  buffer,\n  relativeToCenter,\n  ellipsoid,\n  rectangle,\n  nativeRectangle,\n  exaggeration,\n  skirtHeight,\n  includeWebMercatorT,\n  negativeAltitudeExponentBias,\n  negativeElevationThreshold\n) {\n  var geographicWest;\n  var geographicSouth;\n  var geographicEast;\n  var geographicNorth;\n  var rectangleWidth, rectangleHeight;\n\n  if (!defined(rectangle)) {\n    geographicWest = CesiumMath.toRadians(nativeRectangle.west);\n    geographicSouth = CesiumMath.toRadians(nativeRectangle.south);\n    geographicEast = CesiumMath.toRadians(nativeRectangle.east);\n    geographicNorth = CesiumMath.toRadians(nativeRectangle.north);\n    rectangleWidth = CesiumMath.toRadians(rectangle.width);\n    rectangleHeight = CesiumMath.toRadians(rectangle.height);\n  } else {\n    geographicWest = rectangle.west;\n    geographicSouth = rectangle.south;\n    geographicEast = rectangle.east;\n    geographicNorth = rectangle.north;\n    rectangleWidth = rectangle.width;\n    rectangleHeight = rectangle.height;\n  }\n\n  // Keep track of quad borders so we can remove duplicates around the borders\n  var quadBorderLatitudes = [geographicSouth, geographicNorth];\n  var quadBorderLongitudes = [geographicWest, geographicEast];\n\n  var fromENU = Transforms.eastNorthUpToFixedFrame(relativeToCenter, ellipsoid);\n  var toENU = Matrix4.inverseTransformation(fromENU, matrix4Scratch);\n\n  var southMercatorY;\n  var oneOverMercatorHeight;\n  if (includeWebMercatorT) {\n    southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(\n      geographicSouth\n    );\n    oneOverMercatorHeight =\n      1.0 /\n      (WebMercatorProjection.geodeticLatitudeToMercatorAngle(geographicNorth) -\n        southMercatorY);\n  }\n\n  var dv = new DataView(buffer);\n\n  var minHeight = Number.POSITIVE_INFINITY;\n  var maxHeight = Number.NEGATIVE_INFINITY;\n\n  var minimum = minimumScratch;\n  minimum.x = Number.POSITIVE_INFINITY;\n  minimum.y = Number.POSITIVE_INFINITY;\n  minimum.z = Number.POSITIVE_INFINITY;\n\n  var maximum = maximumScratch;\n  maximum.x = Number.NEGATIVE_INFINITY;\n  maximum.y = Number.NEGATIVE_INFINITY;\n  maximum.z = Number.NEGATIVE_INFINITY;\n\n  // Compute sizes\n  var offset = 0;\n  var size = 0;\n  var indicesSize = 0;\n  var quadSize;\n  var quad;\n  for (quad = 0; quad < 4; ++quad) {\n    var o = offset;\n    quadSize = dv.getUint32(o, true);\n    o += sizeOfUint32;\n\n    var x = CesiumMath.toRadians(dv.getFloat64(o, true) * 180.0);\n    o += sizeOfDouble;\n    if (indexOfEpsilon(quadBorderLongitudes, x) === -1) {\n      quadBorderLongitudes.push(x);\n    }\n\n    var y = CesiumMath.toRadians(dv.getFloat64(o, true) * 180.0);\n    o += sizeOfDouble;\n    if (indexOfEpsilon(quadBorderLatitudes, y) === -1) {\n      quadBorderLatitudes.push(y);\n    }\n\n    o += 2 * sizeOfDouble; // stepX + stepY\n\n    var c = dv.getInt32(o, true); // Read point count\n    o += sizeOfInt32;\n    size += c;\n\n    c = dv.getInt32(o, true); // Read index count\n    indicesSize += c * 3;\n\n    offset += quadSize + sizeOfUint32; // Jump to next quad\n  }\n\n  // Quad Border points to remove duplicates\n  var quadBorderPoints = [];\n  var quadBorderIndices = [];\n\n  // Create arrays\n  var positions = new Array(size);\n  var uvs = new Array(size);\n  var heights = new Array(size);\n  var webMercatorTs = includeWebMercatorT ? new Array(size) : [];\n  var indices = new Array(indicesSize);\n\n  // Points are laid out in rows starting at SW, so storing border points as we\n  //  come across them all points will be adjacent.\n  var westBorder = [];\n  var southBorder = [];\n  var eastBorder = [];\n  var northBorder = [];\n\n  // Each tile is split into 4 parts\n  var pointOffset = 0;\n  var indicesOffset = 0;\n  offset = 0;\n  for (quad = 0; quad < 4; ++quad) {\n    quadSize = dv.getUint32(offset, true);\n    offset += sizeOfUint32;\n    var startQuad = offset;\n\n    var originX = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\n    offset += sizeOfDouble;\n\n    var originY = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\n    offset += sizeOfDouble;\n\n    var stepX = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\n    var halfStepX = stepX * 0.5;\n    offset += sizeOfDouble;\n\n    var stepY = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\n    var halfStepY = stepY * 0.5;\n    offset += sizeOfDouble;\n\n    var numPoints = dv.getInt32(offset, true);\n    offset += sizeOfInt32;\n\n    var numFaces = dv.getInt32(offset, true);\n    offset += sizeOfInt32;\n\n    //var level = dv.getInt32(offset, true);\n    offset += sizeOfInt32;\n\n    // Keep track of quad indices to overall tile indices\n    var indicesMapping = new Array(numPoints);\n    for (var i = 0; i < numPoints; ++i) {\n      var longitude = originX + dv.getUint8(offset++) * stepX;\n      scratchCartographic.longitude = longitude;\n      var latitude = originY + dv.getUint8(offset++) * stepY;\n      scratchCartographic.latitude = latitude;\n\n      var height = dv.getFloat32(offset, true);\n      offset += sizeOfFloat;\n\n      // In order to support old clients, negative altitude values are stored as\n      // height/-2^32. Old clients see the value as really close to 0 but new clients multiply\n      // by -2^32 to get the real negative altitude value.\n      if (height !== 0 && height < negativeElevationThreshold) {\n        height *= -Math.pow(2, negativeAltitudeExponentBias);\n      }\n\n      // Height is stored in units of (1/EarthRadius) or (1/6371010.0)\n      height *= 6371010.0 * exaggeration;\n\n      scratchCartographic.height = height;\n\n      // Is it along a quad border - if so check if already exists and use that index\n      if (\n        indexOfEpsilon(quadBorderLongitudes, longitude) !== -1 ||\n        indexOfEpsilon(quadBorderLatitudes, latitude) !== -1\n      ) {\n        var index = indexOfEpsilon(\n          quadBorderPoints,\n          scratchCartographic,\n          Cartographic\n        );\n        if (index === -1) {\n          quadBorderPoints.push(Cartographic.clone(scratchCartographic));\n          quadBorderIndices.push(pointOffset);\n        } else {\n          indicesMapping[i] = quadBorderIndices[index];\n          continue;\n        }\n      }\n      indicesMapping[i] = pointOffset;\n\n      if (Math.abs(longitude - geographicWest) < halfStepX) {\n        westBorder.push({\n          index: pointOffset,\n          cartographic: Cartographic.clone(scratchCartographic),\n        });\n      } else if (Math.abs(longitude - geographicEast) < halfStepX) {\n        eastBorder.push({\n          index: pointOffset,\n          cartographic: Cartographic.clone(scratchCartographic),\n        });\n      } else if (Math.abs(latitude - geographicSouth) < halfStepY) {\n        southBorder.push({\n          index: pointOffset,\n          cartographic: Cartographic.clone(scratchCartographic),\n        });\n      } else if (Math.abs(latitude - geographicNorth) < halfStepY) {\n        northBorder.push({\n          index: pointOffset,\n          cartographic: Cartographic.clone(scratchCartographic),\n        });\n      }\n\n      minHeight = Math.min(height, minHeight);\n      maxHeight = Math.max(height, maxHeight);\n      heights[pointOffset] = height;\n\n      var pos = ellipsoid.cartographicToCartesian(scratchCartographic);\n      positions[pointOffset] = pos;\n\n      if (includeWebMercatorT) {\n        webMercatorTs[pointOffset] =\n          (WebMercatorProjection.geodeticLatitudeToMercatorAngle(latitude) -\n            southMercatorY) *\n          oneOverMercatorHeight;\n      }\n\n      Matrix4.multiplyByPoint(toENU, pos, scratchCartesian);\n\n      Cartesian3.minimumByComponent(scratchCartesian, minimum, minimum);\n      Cartesian3.maximumByComponent(scratchCartesian, maximum, maximum);\n\n      var u = (longitude - geographicWest) / (geographicEast - geographicWest);\n      u = CesiumMath.clamp(u, 0.0, 1.0);\n      var v =\n        (latitude - geographicSouth) / (geographicNorth - geographicSouth);\n      v = CesiumMath.clamp(v, 0.0, 1.0);\n\n      uvs[pointOffset] = new Cartesian2(u, v);\n      ++pointOffset;\n    }\n\n    var facesElementCount = numFaces * 3;\n    for (var j = 0; j < facesElementCount; ++j, ++indicesOffset) {\n      indices[indicesOffset] = indicesMapping[dv.getUint16(offset, true)];\n      offset += sizeOfUint16;\n    }\n\n    if (quadSize !== offset - startQuad) {\n      throw new RuntimeError(\"Invalid terrain tile.\");\n    }\n  }\n\n  positions.length = pointOffset;\n  uvs.length = pointOffset;\n  heights.length = pointOffset;\n  if (includeWebMercatorT) {\n    webMercatorTs.length = pointOffset;\n  }\n\n  var vertexCountWithoutSkirts = pointOffset;\n  var indexCountWithoutSkirts = indicesOffset;\n\n  // Add skirt points\n  var skirtOptions = {\n    hMin: minHeight,\n    lastBorderPoint: undefined,\n    skirtHeight: skirtHeight,\n    toENU: toENU,\n    ellipsoid: ellipsoid,\n    minimum: minimum,\n    maximum: maximum,\n  };\n\n  // Sort counter clockwise from NW corner\n  // Corner points are in the east/west arrays\n  westBorder.sort(function (a, b) {\n    return b.cartographic.latitude - a.cartographic.latitude;\n  });\n  southBorder.sort(function (a, b) {\n    return a.cartographic.longitude - b.cartographic.longitude;\n  });\n  eastBorder.sort(function (a, b) {\n    return a.cartographic.latitude - b.cartographic.latitude;\n  });\n  northBorder.sort(function (a, b) {\n    return b.cartographic.longitude - a.cartographic.longitude;\n  });\n\n  var percentage = 0.00001;\n  addSkirt(\n    positions,\n    heights,\n    uvs,\n    webMercatorTs,\n    indices,\n    skirtOptions,\n    westBorder,\n    -percentage * rectangleWidth,\n    true,\n    -percentage * rectangleHeight\n  );\n  addSkirt(\n    positions,\n    heights,\n    uvs,\n    webMercatorTs,\n    indices,\n    skirtOptions,\n    southBorder,\n    -percentage * rectangleHeight,\n    false\n  );\n  addSkirt(\n    positions,\n    heights,\n    uvs,\n    webMercatorTs,\n    indices,\n    skirtOptions,\n    eastBorder,\n    percentage * rectangleWidth,\n    true,\n    percentage * rectangleHeight\n  );\n  addSkirt(\n    positions,\n    heights,\n    uvs,\n    webMercatorTs,\n    indices,\n    skirtOptions,\n    northBorder,\n    percentage * rectangleHeight,\n    false\n  );\n\n  // Since the corner between the north and west sides is in the west array, generate the last\n  //  two triangles between the last north vertex and the first west vertex\n  if (westBorder.length > 0 && northBorder.length > 0) {\n    var firstBorderIndex = westBorder[0].index;\n    var firstSkirtIndex = vertexCountWithoutSkirts;\n    var lastBorderIndex = northBorder[northBorder.length - 1].index;\n    var lastSkirtIndex = positions.length - 1;\n\n    indices.push(\n      lastBorderIndex,\n      lastSkirtIndex,\n      firstSkirtIndex,\n      firstSkirtIndex,\n      firstBorderIndex,\n      lastBorderIndex\n    );\n  }\n\n  size = positions.length; // Get new size with skirt vertices\n\n  var boundingSphere3D = BoundingSphere.fromPoints(positions);\n  var orientedBoundingBox;\n  if (defined(rectangle)) {\n    orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n      rectangle,\n      minHeight,\n      maxHeight,\n      ellipsoid\n    );\n  }\n\n  var occluder = new EllipsoidalOccluder(ellipsoid);\n  var occludeePointInScaledSpace = occluder.computeHorizonCullingPointPossiblyUnderEllipsoid(\n    relativeToCenter,\n    positions,\n    minHeight\n  );\n\n  var aaBox = new AxisAlignedBoundingBox(minimum, maximum, relativeToCenter);\n  var encoding = new TerrainEncoding(\n    aaBox,\n    skirtOptions.hMin,\n    maxHeight,\n    fromENU,\n    false,\n    includeWebMercatorT\n  );\n  var vertices = new Float32Array(size * encoding.getStride());\n\n  var bufferIndex = 0;\n  for (var k = 0; k < size; ++k) {\n    bufferIndex = encoding.encode(\n      vertices,\n      bufferIndex,\n      positions[k],\n      uvs[k],\n      heights[k],\n      undefined,\n      webMercatorTs[k]\n    );\n  }\n\n  var westIndicesSouthToNorth = westBorder\n    .map(function (vertex) {\n      return vertex.index;\n    })\n    .reverse();\n  var southIndicesEastToWest = southBorder\n    .map(function (vertex) {\n      return vertex.index;\n    })\n    .reverse();\n  var eastIndicesNorthToSouth = eastBorder\n    .map(function (vertex) {\n      return vertex.index;\n    })\n    .reverse();\n  var northIndicesWestToEast = northBorder\n    .map(function (vertex) {\n      return vertex.index;\n    })\n    .reverse();\n\n  southIndicesEastToWest.unshift(\n    eastIndicesNorthToSouth[eastIndicesNorthToSouth.length - 1]\n  );\n  southIndicesEastToWest.push(westIndicesSouthToNorth[0]);\n\n  northIndicesWestToEast.unshift(\n    westIndicesSouthToNorth[westIndicesSouthToNorth.length - 1]\n  );\n  northIndicesWestToEast.push(eastIndicesNorthToSouth[0]);\n\n  return {\n    vertices: vertices,\n    indices: new Uint16Array(indices),\n    maximumHeight: maxHeight,\n    minimumHeight: minHeight,\n    encoding: encoding,\n    boundingSphere3D: boundingSphere3D,\n    orientedBoundingBox: orientedBoundingBox,\n    occludeePointInScaledSpace: occludeePointInScaledSpace,\n    vertexCountWithoutSkirts: vertexCountWithoutSkirts,\n    indexCountWithoutSkirts: indexCountWithoutSkirts,\n    westIndicesSouthToNorth: westIndicesSouthToNorth,\n    southIndicesEastToWest: southIndicesEastToWest,\n    eastIndicesNorthToSouth: eastIndicesNorthToSouth,\n    northIndicesWestToEast: northIndicesWestToEast,\n  };\n}\n\nfunction addSkirt(\n  positions,\n  heights,\n  uvs,\n  webMercatorTs,\n  indices,\n  skirtOptions,\n  borderPoints,\n  fudgeFactor,\n  eastOrWest,\n  cornerFudge\n) {\n  var count = borderPoints.length;\n  for (var j = 0; j < count; ++j) {\n    var borderPoint = borderPoints[j];\n    var borderCartographic = borderPoint.cartographic;\n    var borderIndex = borderPoint.index;\n    var currentIndex = positions.length;\n\n    var longitude = borderCartographic.longitude;\n    var latitude = borderCartographic.latitude;\n    latitude = CesiumMath.clamp(\n      latitude,\n      -CesiumMath.PI_OVER_TWO,\n      CesiumMath.PI_OVER_TWO\n    ); // Don't go over the poles\n    var height = borderCartographic.height - skirtOptions.skirtHeight;\n    skirtOptions.hMin = Math.min(skirtOptions.hMin, height);\n\n    Cartographic.fromRadians(longitude, latitude, height, scratchCartographic);\n\n    // Adjust sides to angle out\n    if (eastOrWest) {\n      scratchCartographic.longitude += fudgeFactor;\n    }\n\n    // Adjust top or bottom to angle out\n    // Since corners are in the east/west arrays angle the first and last points as well\n    if (!eastOrWest) {\n      scratchCartographic.latitude += fudgeFactor;\n    } else if (j === count - 1) {\n      scratchCartographic.latitude += cornerFudge;\n    } else if (j === 0) {\n      scratchCartographic.latitude -= cornerFudge;\n    }\n\n    var pos = skirtOptions.ellipsoid.cartographicToCartesian(\n      scratchCartographic\n    );\n    positions.push(pos);\n    heights.push(height);\n    uvs.push(Cartesian2.clone(uvs[borderIndex])); // Copy UVs from border point\n    if (webMercatorTs.length > 0) {\n      webMercatorTs.push(webMercatorTs[borderIndex]);\n    }\n\n    Matrix4.multiplyByPoint(skirtOptions.toENU, pos, scratchCartesian);\n\n    var minimum = skirtOptions.minimum;\n    var maximum = skirtOptions.maximum;\n    Cartesian3.minimumByComponent(scratchCartesian, minimum, minimum);\n    Cartesian3.maximumByComponent(scratchCartesian, maximum, maximum);\n\n    var lastBorderPoint = skirtOptions.lastBorderPoint;\n    if (defined(lastBorderPoint)) {\n      var lastBorderIndex = lastBorderPoint.index;\n      indices.push(\n        lastBorderIndex,\n        currentIndex - 1,\n        currentIndex,\n        currentIndex,\n        borderIndex,\n        lastBorderIndex\n      );\n    }\n\n    skirtOptions.lastBorderPoint = borderPoint;\n  }\n}\nexport default createTaskProcessorWorker(\n  createVerticesFromGoogleEarthEnterpriseBuffer\n);\n"],"names":["sizeOfUint16","Uint16Array","BYTES_PER_ELEMENT","sizeOfInt32","Int32Array","sizeOfUint32","Uint32Array","sizeOfFloat","Float32Array","sizeOfDouble","Float64Array","indexOfEpsilon","arr","elem","elemType","defaultValue","CesiumMath","count","length","i","equalsEpsilon","EPSILON12","scratchCartographic","Cartographic","scratchCartesian","Cartesian3","minimumScratch","maximumScratch","matrix4Scratch","Matrix4","addSkirt","positions","heights","uvs","webMercatorTs","indices","skirtOptions","borderPoints","fudgeFactor","eastOrWest","cornerFudge","j","borderPoint","borderCartographic","cartographic","borderIndex","index","currentIndex","longitude","latitude","clamp","PI_OVER_TWO","height","skirtHeight","hMin","Math","min","fromRadians","pos","ellipsoid","cartographicToCartesian","push","Cartesian2","clone","multiplyByPoint","toENU","minimum","maximum","minimumByComponent","maximumByComponent","lastBorderPoint","defined","lastBorderIndex","createTaskProcessorWorker","parameters","transferableObjects","Ellipsoid","rectangle","Rectangle","statistics","buffer","relativeToCenter","nativeRectangle","exaggeration","includeWebMercatorT","negativeAltitudeExponentBias","negativeElevationThreshold","geographicWest","geographicSouth","geographicEast","geographicNorth","rectangleWidth","rectangleHeight","west","south","east","north","width","toRadians","southMercatorY","oneOverMercatorHeight","quadBorderLatitudes","quadBorderLongitudes","fromENU","Transforms","eastNorthUpToFixedFrame","inverseTransformation","WebMercatorProjection","geodeticLatitudeToMercatorAngle","dv","DataView","minHeight","Number","POSITIVE_INFINITY","maxHeight","NEGATIVE_INFINITY","x","y","z","quadSize","quad","offset","size","indicesSize","o","getUint32","getFloat64","c","getInt32","quadBorderPoints","quadBorderIndices","Array","westBorder","southBorder","eastBorder","northBorder","pointOffset","indicesOffset","startQuad","originX","originY","stepX","halfStepX","stepY","halfStepY","numPoints","numFaces","indicesMapping","getUint8","getFloat32","pow","abs","max","u","v","facesElementCount","getUint16","RuntimeError","vertexCountWithoutSkirts","indexCountWithoutSkirts","undefined","sort","a","b","percentage","lastSkirtIndex","firstBorderIndex","orientedBoundingBox","boundingSphere3D","BoundingSphere","fromPoints","OrientedBoundingBox","fromRectangle","occludeePointInScaledSpace","EllipsoidalOccluder","computeHorizonCullingPointPossiblyUnderEllipsoid","aaBox","AxisAlignedBoundingBox","encoding","TerrainEncoding","vertices","getStride","bufferIndex","k","encode","westIndicesSouthToNorth","map","vertex","reverse","southIndicesEastToWest","eastIndicesNorthToSouth","northIndicesWestToEast","unshift","maximumHeight","minimumHeight","processBuffer","numberOfAttributes"],"mappings":"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"}