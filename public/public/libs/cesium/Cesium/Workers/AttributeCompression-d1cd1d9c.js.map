{"version":3,"file":"AttributeCompression-d1cd1d9c.js","sources":["../../../../Source/Core/AttributeCompression.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\nvar RIGHT_SHIFT = 1.0 / 256.0;\nvar LEFT_SHIFT = 256.0;\n\n/**\n * Attribute compression and decompression functions.\n *\n * @namespace AttributeCompression\n *\n * @private\n */\nvar AttributeCompression = {};\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-rangeMax] following the 'oct' encoding.\n *\n * Oct encoding is a compact representation of unit length vectors.\n * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\",\n * Cigolle et al 2014: {@link http://jcgt.org/published/0003/02/01/}\n *\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 component 'oct' encoding.\n * @param {Cartesian2} result The 2 component oct-encoded unit length vector.\n * @param {Number} rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\n * @returns {Cartesian2} The 2 component oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n *\n * @see AttributeCompression.octDecodeInRange\n */\nAttributeCompression.octEncodeInRange = function (vector, rangeMax, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"vector\", vector);\n  Check.defined(\"result\", result);\n  var magSquared = Cartesian3.magnitudeSquared(vector);\n  if (Math.abs(magSquared - 1.0) > CesiumMath.EPSILON6) {\n    throw new DeveloperError(\"vector must be normalized.\");\n  }\n  //>>includeEnd('debug');\n\n  result.x =\n    vector.x / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n  result.y =\n    vector.y / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n  if (vector.z < 0) {\n    var x = result.x;\n    var y = result.y;\n    result.x = (1.0 - Math.abs(y)) * CesiumMath.signNotZero(x);\n    result.y = (1.0 - Math.abs(x)) * CesiumMath.signNotZero(y);\n  }\n\n  result.x = CesiumMath.toSNorm(result.x, rangeMax);\n  result.y = CesiumMath.toSNorm(result.y, rangeMax);\n\n  return result;\n};\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding.\n *\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 byte 'oct' encoding.\n * @param {Cartesian2} result The 2 byte oct-encoded unit length vector.\n * @returns {Cartesian2} The 2 byte oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n *\n * @see AttributeCompression.octEncodeInRange\n * @see AttributeCompression.octDecode\n */\nAttributeCompression.octEncode = function (vector, result) {\n  return AttributeCompression.octEncodeInRange(vector, 255, result);\n};\n\nvar octEncodeScratch = new Cartesian2();\nvar uint8ForceArray = new Uint8Array(1);\nfunction forceUint8(value) {\n  uint8ForceArray[0] = value;\n  return uint8ForceArray[0];\n}\n/**\n * @param {Cartesian3} vector The normalized vector to be compressed into 4 byte 'oct' encoding.\n * @param {Cartesian4} result The 4 byte oct-encoded unit length vector.\n * @returns {Cartesian4} The 4 byte oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n *\n * @see AttributeCompression.octEncodeInRange\n * @see AttributeCompression.octDecodeFromCartesian4\n */\nAttributeCompression.octEncodeToCartesian4 = function (vector, result) {\n  AttributeCompression.octEncodeInRange(vector, 65535, octEncodeScratch);\n  result.x = forceUint8(octEncodeScratch.x * RIGHT_SHIFT);\n  result.y = forceUint8(octEncodeScratch.x);\n  result.z = forceUint8(octEncodeScratch.y * RIGHT_SHIFT);\n  result.w = forceUint8(octEncodeScratch.y);\n  return result;\n};\n\n/**\n * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component vector.\n *\n * @param {Number} x The x component of the oct-encoded unit length vector.\n * @param {Number} y The y component of the oct-encoded unit length vector.\n * @param {Number} rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\n * @param {Cartesian3} result The decoded and normalized vector\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n * @exception {DeveloperError} x and y must be unsigned normalized integers between 0 and rangeMax.\n *\n * @see AttributeCompression.octEncodeInRange\n */\nAttributeCompression.octDecodeInRange = function (x, y, rangeMax, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"result\", result);\n  if (x < 0 || x > rangeMax || y < 0 || y > rangeMax) {\n    throw new DeveloperError(\n      \"x and y must be unsigned normalized integers between 0 and \" + rangeMax\n    );\n  }\n  //>>includeEnd('debug');\n\n  result.x = CesiumMath.fromSNorm(x, rangeMax);\n  result.y = CesiumMath.fromSNorm(y, rangeMax);\n  result.z = 1.0 - (Math.abs(result.x) + Math.abs(result.y));\n\n  if (result.z < 0.0) {\n    var oldVX = result.x;\n    result.x = (1.0 - Math.abs(result.y)) * CesiumMath.signNotZero(oldVX);\n    result.y = (1.0 - Math.abs(oldVX)) * CesiumMath.signNotZero(result.y);\n  }\n\n  return Cartesian3.normalize(result, result);\n};\n\n/**\n * Decodes a unit-length vector in 2 byte 'oct' encoding to a normalized 3-component vector.\n *\n * @param {Number} x The x component of the oct-encoded unit length vector.\n * @param {Number} y The y component of the oct-encoded unit length vector.\n * @param {Cartesian3} result The decoded and normalized vector.\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n * @exception {DeveloperError} x and y must be an unsigned normalized integer between 0 and 255.\n *\n * @see AttributeCompression.octDecodeInRange\n */\nAttributeCompression.octDecode = function (x, y, result) {\n  return AttributeCompression.octDecodeInRange(x, y, 255, result);\n};\n\n/**\n * Decodes a unit-length vector in 4 byte 'oct' encoding to a normalized 3-component vector.\n *\n * @param {Cartesian4} encoded The oct-encoded unit length vector.\n * @param {Cartesian3} result The decoded and normalized vector.\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n * @exception {DeveloperError} x, y, z, and w must be unsigned normalized integers between 0 and 255.\n *\n * @see AttributeCompression.octDecodeInRange\n * @see AttributeCompression.octEncodeToCartesian4\n */\nAttributeCompression.octDecodeFromCartesian4 = function (encoded, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"encoded\", encoded);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n  var x = encoded.x;\n  var y = encoded.y;\n  var z = encoded.z;\n  var w = encoded.w;\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    x < 0 ||\n    x > 255 ||\n    y < 0 ||\n    y > 255 ||\n    z < 0 ||\n    z > 255 ||\n    w < 0 ||\n    w > 255\n  ) {\n    throw new DeveloperError(\n      \"x, y, z, and w must be unsigned normalized integers between 0 and 255\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var xOct16 = x * LEFT_SHIFT + y;\n  var yOct16 = z * LEFT_SHIFT + w;\n  return AttributeCompression.octDecodeInRange(xOct16, yOct16, 65535, result);\n};\n\n/**\n * Packs an oct encoded vector into a single floating-point number.\n *\n * @param {Cartesian2} encoded The oct encoded vector.\n * @returns {Number} The oct encoded vector packed into a single float.\n *\n */\nAttributeCompression.octPackFloat = function (encoded) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"encoded\", encoded);\n  //>>includeEnd('debug');\n  return 256.0 * encoded.x + encoded.y;\n};\n\nvar scratchEncodeCart2 = new Cartesian2();\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding and\n * stores those values in a single float-point number.\n *\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 byte 'oct' encoding.\n * @returns {Number} The 2 byte oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n */\nAttributeCompression.octEncodeFloat = function (vector) {\n  AttributeCompression.octEncode(vector, scratchEncodeCart2);\n  return AttributeCompression.octPackFloat(scratchEncodeCart2);\n};\n\n/**\n * Decodes a unit-length vector in 'oct' encoding packed in a floating-point number to a normalized 3-component vector.\n *\n * @param {Number} value The oct-encoded unit length vector stored as a single floating-point number.\n * @param {Cartesian3} result The decoded and normalized vector\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n */\nAttributeCompression.octDecodeFloat = function (value, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"value\", value);\n  //>>includeEnd('debug');\n\n  var temp = value / 256.0;\n  var x = Math.floor(temp);\n  var y = (temp - x) * 256.0;\n\n  return AttributeCompression.octDecode(x, y, result);\n};\n\n/**\n * Encodes three normalized vectors into 6 SNORM values in the range of [0-255] following the 'oct' encoding and\n * packs those into two floating-point numbers.\n *\n * @param {Cartesian3} v1 A normalized vector to be compressed.\n * @param {Cartesian3} v2 A normalized vector to be compressed.\n * @param {Cartesian3} v3 A normalized vector to be compressed.\n * @param {Cartesian2} result The 'oct' encoded vectors packed into two floating-point numbers.\n * @returns {Cartesian2} The 'oct' encoded vectors packed into two floating-point numbers.\n *\n */\nAttributeCompression.octPack = function (v1, v2, v3, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"v1\", v1);\n  Check.defined(\"v2\", v2);\n  Check.defined(\"v3\", v3);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  var encoded1 = AttributeCompression.octEncodeFloat(v1);\n  var encoded2 = AttributeCompression.octEncodeFloat(v2);\n\n  var encoded3 = AttributeCompression.octEncode(v3, scratchEncodeCart2);\n  result.x = 65536.0 * encoded3.x + encoded1;\n  result.y = 65536.0 * encoded3.y + encoded2;\n  return result;\n};\n\n/**\n * Decodes three unit-length vectors in 'oct' encoding packed into a floating-point number to a normalized 3-component vector.\n *\n * @param {Cartesian2} packed The three oct-encoded unit length vectors stored as two floating-point number.\n * @param {Cartesian3} v1 One decoded and normalized vector.\n * @param {Cartesian3} v2 One decoded and normalized vector.\n * @param {Cartesian3} v3 One decoded and normalized vector.\n */\nAttributeCompression.octUnpack = function (packed, v1, v2, v3) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"packed\", packed);\n  Check.defined(\"v1\", v1);\n  Check.defined(\"v2\", v2);\n  Check.defined(\"v3\", v3);\n  //>>includeEnd('debug');\n\n  var temp = packed.x / 65536.0;\n  var x = Math.floor(temp);\n  var encodedFloat1 = (temp - x) * 65536.0;\n\n  temp = packed.y / 65536.0;\n  var y = Math.floor(temp);\n  var encodedFloat2 = (temp - y) * 65536.0;\n\n  AttributeCompression.octDecodeFloat(encodedFloat1, v1);\n  AttributeCompression.octDecodeFloat(encodedFloat2, v2);\n  AttributeCompression.octDecode(x, y, v3);\n};\n\n/**\n * Pack texture coordinates into a single float. The texture coordinates will only preserve 12 bits of precision.\n *\n * @param {Cartesian2} textureCoordinates The texture coordinates to compress.  Both coordinates must be in the range 0.0-1.0.\n * @returns {Number} The packed texture coordinates.\n *\n */\nAttributeCompression.compressTextureCoordinates = function (\n  textureCoordinates\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"textureCoordinates\", textureCoordinates);\n  //>>includeEnd('debug');\n\n  // Move x and y to the range 0-4095;\n  var x = (textureCoordinates.x * 4095.0) | 0;\n  var y = (textureCoordinates.y * 4095.0) | 0;\n  return 4096.0 * x + y;\n};\n\n/**\n * Decompresses texture coordinates that were packed into a single float.\n *\n * @param {Number} compressed The compressed texture coordinates.\n * @param {Cartesian2} result The decompressed texture coordinates.\n * @returns {Cartesian2} The modified result parameter.\n *\n */\nAttributeCompression.decompressTextureCoordinates = function (\n  compressed,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"compressed\", compressed);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  var temp = compressed / 4096.0;\n  var xZeroTo4095 = Math.floor(temp);\n  result.x = xZeroTo4095 / 4095.0;\n  result.y = (compressed - xZeroTo4095 * 4096) / 4095;\n  return result;\n};\n\nfunction zigZagDecode(value) {\n  return (value >> 1) ^ -(value & 1);\n}\n\n/**\n * Decodes delta and ZigZag encoded vertices. This modifies the buffers in place.\n *\n * @param {Uint16Array} uBuffer The buffer view of u values.\n * @param {Uint16Array} vBuffer The buffer view of v values.\n * @param {Uint16Array} [heightBuffer] The buffer view of height values.\n *\n * @see {@link https://github.com/CesiumGS/quantized-mesh|quantized-mesh-1.0 terrain format}\n */\nAttributeCompression.zigZagDeltaDecode = function (\n  uBuffer,\n  vBuffer,\n  heightBuffer\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"uBuffer\", uBuffer);\n  Check.defined(\"vBuffer\", vBuffer);\n  Check.typeOf.number.equals(\n    \"uBuffer.length\",\n    \"vBuffer.length\",\n    uBuffer.length,\n    vBuffer.length\n  );\n  if (defined(heightBuffer)) {\n    Check.typeOf.number.equals(\n      \"uBuffer.length\",\n      \"heightBuffer.length\",\n      uBuffer.length,\n      heightBuffer.length\n    );\n  }\n  //>>includeEnd('debug');\n\n  var count = uBuffer.length;\n\n  var u = 0;\n  var v = 0;\n  var height = 0;\n\n  for (var i = 0; i < count; ++i) {\n    u += zigZagDecode(uBuffer[i]);\n    v += zigZagDecode(vBuffer[i]);\n\n    uBuffer[i] = u;\n    vBuffer[i] = v;\n\n    if (defined(heightBuffer)) {\n      height += zigZagDecode(heightBuffer[i]);\n      heightBuffer[i] = height;\n    }\n  }\n};\nexport default AttributeCompression;\n"],"names":["AttributeCompression","octEncodeInRange","vector","rangeMax","result","Check","defined","magSquared","Cartesian3","magnitudeSquared","Math","abs","CesiumMath","EPSILON6","DeveloperError","x","y","z","signNotZero","toSNorm","octEncode","octEncodeScratch","Cartesian2","uint8ForceArray","Uint8Array","forceUint8","value","octEncodeToCartesian4","w","octDecodeInRange","fromSNorm","oldVX","normalize","octDecode","octDecodeFromCartesian4","encoded","typeOf","object","octPackFloat","scratchEncodeCart2","zigZagDecode","octEncodeFloat","octDecodeFloat","temp","floor","octPack","v1","v2","v3","encoded1","encoded2","encoded3","octUnpack","packed","encodedFloat1","encodedFloat2","compressTextureCoordinates","textureCoordinates","decompressTextureCoordinates","compressed","xZeroTo4095","zigZagDeltaDecode","uBuffer","vBuffer","heightBuffer","number","equals","length","count","u","v","height","i"],"mappings":"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"}