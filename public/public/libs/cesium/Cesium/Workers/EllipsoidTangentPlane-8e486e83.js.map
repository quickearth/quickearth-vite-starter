{"version":3,"file":"EllipsoidTangentPlane-8e486e83.js","sources":["../../../../Source/Core/AxisAlignedBoundingBox.js","../../../../Source/Core/EllipsoidTangentPlane.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Intersect from \"./Intersect.js\";\n\n/**\n * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.\n * @alias AxisAlignedBoundingBox\n * @constructor\n *\n * @param {Cartesian3} [minimum=Cartesian3.ZERO] The minimum point along the x, y, and z axes.\n * @param {Cartesian3} [maximum=Cartesian3.ZERO] The maximum point along the x, y, and z axes.\n * @param {Cartesian3} [center] The center of the box; automatically computed if not supplied.\n *\n * @see BoundingSphere\n * @see BoundingRectangle\n */\nfunction AxisAlignedBoundingBox(minimum, maximum, center) {\n  /**\n   * The minimum point defining the bounding box.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.minimum = Cartesian3.clone(defaultValue(minimum, Cartesian3.ZERO));\n\n  /**\n   * The maximum point defining the bounding box.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.maximum = Cartesian3.clone(defaultValue(maximum, Cartesian3.ZERO));\n\n  //If center was not defined, compute it.\n  if (!defined(center)) {\n    center = Cartesian3.midpoint(this.minimum, this.maximum, new Cartesian3());\n  } else {\n    center = Cartesian3.clone(center);\n  }\n\n  /**\n   * The center point of the bounding box.\n   * @type {Cartesian3}\n   */\n  this.center = center;\n}\n\n/**\n * Computes an instance of an AxisAlignedBoundingBox. The box is determined by\n * finding the points spaced the farthest apart on the x, y, and z axes.\n *\n * @param {Cartesian3[]} positions List of points that the bounding box will enclose.  Each point must have a <code>x</code>, <code>y</code>, and <code>z</code> properties.\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\n *\n * @example\n * // Compute an axis aligned bounding box enclosing two points.\n * var box = Cesium.AxisAlignedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\n */\nAxisAlignedBoundingBox.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new AxisAlignedBoundingBox();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.minimum = Cartesian3.clone(Cartesian3.ZERO, result.minimum);\n    result.maximum = Cartesian3.clone(Cartesian3.ZERO, result.maximum);\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    return result;\n  }\n\n  var minimumX = positions[0].x;\n  var minimumY = positions[0].y;\n  var minimumZ = positions[0].z;\n\n  var maximumX = positions[0].x;\n  var maximumY = positions[0].y;\n  var maximumZ = positions[0].z;\n\n  var length = positions.length;\n  for (var i = 1; i < length; i++) {\n    var p = positions[i];\n    var x = p.x;\n    var y = p.y;\n    var z = p.z;\n\n    minimumX = Math.min(x, minimumX);\n    maximumX = Math.max(x, maximumX);\n    minimumY = Math.min(y, minimumY);\n    maximumY = Math.max(y, maximumY);\n    minimumZ = Math.min(z, minimumZ);\n    maximumZ = Math.max(z, maximumZ);\n  }\n\n  var minimum = result.minimum;\n  minimum.x = minimumX;\n  minimum.y = minimumY;\n  minimum.z = minimumZ;\n\n  var maximum = result.maximum;\n  maximum.x = maximumX;\n  maximum.y = maximumY;\n  maximum.z = maximumZ;\n\n  result.center = Cartesian3.midpoint(minimum, maximum, result.center);\n\n  return result;\n};\n\n/**\n * Duplicates a AxisAlignedBoundingBox instance.\n *\n * @param {AxisAlignedBoundingBox} box The bounding box to duplicate.\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\n */\nAxisAlignedBoundingBox.clone = function (box, result) {\n  if (!defined(box)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new AxisAlignedBoundingBox(box.minimum, box.maximum, box.center);\n  }\n\n  result.minimum = Cartesian3.clone(box.minimum, result.minimum);\n  result.maximum = Cartesian3.clone(box.maximum, result.maximum);\n  result.center = Cartesian3.clone(box.center, result.center);\n  return result;\n};\n\n/**\n * Compares the provided AxisAlignedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {AxisAlignedBoundingBox} [left] The first AxisAlignedBoundingBox.\n * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nAxisAlignedBoundingBox.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Cartesian3.equals(left.center, right.center) &&\n      Cartesian3.equals(left.minimum, right.minimum) &&\n      Cartesian3.equals(left.maximum, right.maximum))\n  );\n};\n\nvar intersectScratch = new Cartesian3();\n/**\n * Determines which side of a plane a box is located.\n *\n * @param {AxisAlignedBoundingBox} box The bounding box to test.\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nAxisAlignedBoundingBox.intersectPlane = function (box, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"box\", box);\n  Check.defined(\"plane\", plane);\n  //>>includeEnd('debug');\n\n  intersectScratch = Cartesian3.subtract(\n    box.maximum,\n    box.minimum,\n    intersectScratch\n  );\n  var h = Cartesian3.multiplyByScalar(intersectScratch, 0.5, intersectScratch); //The positive half diagonal\n  var normal = plane.normal;\n  var e =\n    h.x * Math.abs(normal.x) +\n    h.y * Math.abs(normal.y) +\n    h.z * Math.abs(normal.z);\n  var s = Cartesian3.dot(box.center, normal) + plane.distance; //signed distance from center\n\n  if (s - e > 0) {\n    return Intersect.INSIDE;\n  }\n\n  if (s + e < 0) {\n    //Not in front because normals point inward\n    return Intersect.OUTSIDE;\n  }\n\n  return Intersect.INTERSECTING;\n};\n\n/**\n * Duplicates this AxisAlignedBoundingBox instance.\n *\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\n */\nAxisAlignedBoundingBox.prototype.clone = function (result) {\n  return AxisAlignedBoundingBox.clone(this, result);\n};\n\n/**\n * Determines which side of a plane this box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nAxisAlignedBoundingBox.prototype.intersectPlane = function (plane) {\n  return AxisAlignedBoundingBox.intersectPlane(this, plane);\n};\n\n/**\n * Compares this AxisAlignedBoundingBox against the provided AxisAlignedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {AxisAlignedBoundingBox} [right] The right hand side AxisAlignedBoundingBox.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nAxisAlignedBoundingBox.prototype.equals = function (right) {\n  return AxisAlignedBoundingBox.equals(this, right);\n};\nexport default AxisAlignedBoundingBox;\n","import AxisAlignedBoundingBox from \"./AxisAlignedBoundingBox.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\nimport Ray from \"./Ray.js\";\nimport Transforms from \"./Transforms.js\";\n\nvar scratchCart4 = new Cartesian4();\n/**\n * A plane tangent to the provided ellipsoid at the provided origin.\n * If origin is not on the surface of the ellipsoid, it's surface projection will be used.\n * If origin is at the center of the ellipsoid, an exception will be thrown.\n * @alias EllipsoidTangentPlane\n * @constructor\n *\n * @param {Cartesian3} origin The point on the surface of the ellipsoid where the tangent plane touches.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.\n *\n * @exception {DeveloperError} origin must not be at the center of the ellipsoid.\n */\nfunction EllipsoidTangentPlane(origin, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"origin\", origin);\n  //>>includeEnd('debug');\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  origin = ellipsoid.scaleToGeodeticSurface(origin);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(origin)) {\n    throw new DeveloperError(\n      \"origin must not be at the center of the ellipsoid.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var eastNorthUp = Transforms.eastNorthUpToFixedFrame(origin, ellipsoid);\n  this._ellipsoid = ellipsoid;\n  this._origin = origin;\n  this._xAxis = Cartesian3.fromCartesian4(\n    Matrix4.getColumn(eastNorthUp, 0, scratchCart4)\n  );\n  this._yAxis = Cartesian3.fromCartesian4(\n    Matrix4.getColumn(eastNorthUp, 1, scratchCart4)\n  );\n\n  var normal = Cartesian3.fromCartesian4(\n    Matrix4.getColumn(eastNorthUp, 2, scratchCart4)\n  );\n  this._plane = Plane.fromPointNormal(origin, normal);\n}\n\nObject.defineProperties(EllipsoidTangentPlane.prototype, {\n  /**\n   * Gets the ellipsoid.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n\n  /**\n   * Gets the origin.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @type {Cartesian3}\n   */\n  origin: {\n    get: function () {\n      return this._origin;\n    },\n  },\n\n  /**\n   * Gets the plane which is tangent to the ellipsoid.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Plane}\n   */\n  plane: {\n    get: function () {\n      return this._plane;\n    },\n  },\n\n  /**\n   * Gets the local X-axis (east) of the tangent plane.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Cartesian3}\n   */\n  xAxis: {\n    get: function () {\n      return this._xAxis;\n    },\n  },\n\n  /**\n   * Gets the local Y-axis (north) of the tangent plane.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Cartesian3}\n   */\n  yAxis: {\n    get: function () {\n      return this._yAxis;\n    },\n  },\n\n  /**\n   * Gets the local Z-axis (up) of the tangent plane.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Cartesian3}\n   */\n  zAxis: {\n    get: function () {\n      return this._plane.normal;\n    },\n  },\n});\n\nvar tmp = new AxisAlignedBoundingBox();\n/**\n * Creates a new instance from the provided ellipsoid and the center\n * point of the provided Cartesians.\n *\n * @param {Cartesian3[]} cartesians The list of positions surrounding the center point.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.\n * @returns {EllipsoidTangentPlane} The new instance of EllipsoidTangentPlane.\n */\nEllipsoidTangentPlane.fromPoints = function (cartesians, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  var box = AxisAlignedBoundingBox.fromPoints(cartesians, tmp);\n  return new EllipsoidTangentPlane(box.center, ellipsoid);\n};\n\nvar scratchProjectPointOntoPlaneRay = new Ray();\nvar scratchProjectPointOntoPlaneCartesian3 = new Cartesian3();\n\n/**\n * Computes the projection of the provided 3D position onto the 2D plane, radially outward from the {@link EllipsoidTangentPlane.ellipsoid} coordinate system origin.\n *\n * @param {Cartesian3} cartesian The point to project.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided. Undefined if there is no intersection point\n */\nEllipsoidTangentPlane.prototype.projectPointOntoPlane = function (\n  cartesian,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  var ray = scratchProjectPointOntoPlaneRay;\n  ray.origin = cartesian;\n  Cartesian3.normalize(cartesian, ray.direction);\n\n  var intersectionPoint = IntersectionTests.rayPlane(\n    ray,\n    this._plane,\n    scratchProjectPointOntoPlaneCartesian3\n  );\n  if (!defined(intersectionPoint)) {\n    Cartesian3.negate(ray.direction, ray.direction);\n    intersectionPoint = IntersectionTests.rayPlane(\n      ray,\n      this._plane,\n      scratchProjectPointOntoPlaneCartesian3\n    );\n  }\n\n  if (defined(intersectionPoint)) {\n    var v = Cartesian3.subtract(\n      intersectionPoint,\n      this._origin,\n      intersectionPoint\n    );\n    var x = Cartesian3.dot(this._xAxis, v);\n    var y = Cartesian3.dot(this._yAxis, v);\n\n    if (!defined(result)) {\n      return new Cartesian2(x, y);\n    }\n    result.x = x;\n    result.y = y;\n    return result;\n  }\n  return undefined;\n};\n\n/**\n * Computes the projection of the provided 3D positions onto the 2D plane (where possible), radially outward from the global origin.\n * The resulting array may be shorter than the input array - if a single projection is impossible it will not be included.\n *\n * @see EllipsoidTangentPlane.projectPointOntoPlane\n *\n * @param {Cartesian3[]} cartesians The array of points to project.\n * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.\n * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointsOntoPlane = function (\n  cartesians,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = [];\n  }\n\n  var count = 0;\n  var length = cartesians.length;\n  for (var i = 0; i < length; i++) {\n    var p = this.projectPointOntoPlane(cartesians[i], result[count]);\n    if (defined(p)) {\n      result[count] = p;\n      count++;\n    }\n  }\n  result.length = count;\n  return result;\n};\n\n/**\n * Computes the projection of the provided 3D position onto the 2D plane, along the plane normal.\n *\n * @param {Cartesian3} cartesian The point to project.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointToNearestOnPlane = function (\n  cartesian,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n\n  var ray = scratchProjectPointOntoPlaneRay;\n  ray.origin = cartesian;\n  Cartesian3.clone(this._plane.normal, ray.direction);\n\n  var intersectionPoint = IntersectionTests.rayPlane(\n    ray,\n    this._plane,\n    scratchProjectPointOntoPlaneCartesian3\n  );\n  if (!defined(intersectionPoint)) {\n    Cartesian3.negate(ray.direction, ray.direction);\n    intersectionPoint = IntersectionTests.rayPlane(\n      ray,\n      this._plane,\n      scratchProjectPointOntoPlaneCartesian3\n    );\n  }\n\n  var v = Cartesian3.subtract(\n    intersectionPoint,\n    this._origin,\n    intersectionPoint\n  );\n  var x = Cartesian3.dot(this._xAxis, v);\n  var y = Cartesian3.dot(this._yAxis, v);\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes the projection of the provided 3D positions onto the 2D plane, along the plane normal.\n *\n * @see EllipsoidTangentPlane.projectPointToNearestOnPlane\n *\n * @param {Cartesian3[]} cartesians The array of points to project.\n * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.\n * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided. This will have the same length as <code>cartesians</code>.\n */\nEllipsoidTangentPlane.prototype.projectPointsToNearestOnPlane = function (\n  cartesians,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = [];\n  }\n\n  var length = cartesians.length;\n  result.length = length;\n  for (var i = 0; i < length; i++) {\n    result[i] = this.projectPointToNearestOnPlane(cartesians[i], result[i]);\n  }\n  return result;\n};\n\nvar projectPointsOntoEllipsoidScratch = new Cartesian3();\n/**\n * Computes the projection of the provided 2D position onto the 3D ellipsoid.\n *\n * @param {Cartesian2} cartesian The points to project.\n * @param {Cartesian3} [result] The Cartesian3 instance to store result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointOntoEllipsoid = function (\n  cartesian,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  var ellipsoid = this._ellipsoid;\n  var origin = this._origin;\n  var xAxis = this._xAxis;\n  var yAxis = this._yAxis;\n  var tmp = projectPointsOntoEllipsoidScratch;\n\n  Cartesian3.multiplyByScalar(xAxis, cartesian.x, tmp);\n  result = Cartesian3.add(origin, tmp, result);\n  Cartesian3.multiplyByScalar(yAxis, cartesian.y, tmp);\n  Cartesian3.add(result, tmp, result);\n  ellipsoid.scaleToGeocentricSurface(result, result);\n\n  return result;\n};\n\n/**\n * Computes the projection of the provided 2D positions onto the 3D ellipsoid.\n *\n * @param {Cartesian2[]} cartesians The array of points to project.\n * @param {Cartesian3[]} [result] The array of Cartesian3 instances onto which to store results.\n * @returns {Cartesian3[]} The modified result parameter or a new array of Cartesian3 instances if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointsOntoEllipsoid = function (\n  cartesians,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  var length = cartesians.length;\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    result[i] = this.projectPointOntoEllipsoid(cartesians[i], result[i]);\n  }\n\n  return result;\n};\nexport default EllipsoidTangentPlane;\n"],"names":["AxisAlignedBoundingBox","minimum","maximum","center","this","Cartesian3","clone","defaultValue","ZERO","defined","midpoint","fromPoints","positions","result","length","minimumX","x","minimumY","y","minimumZ","z","maximumX","maximumY","maximumZ","i","p","Math","min","max","box","equals","left","right","intersectScratch","intersectPlane","plane","Check","subtract","h","multiplyByScalar","normal","e","abs","s","dot","distance","Intersect","INSIDE","OUTSIDE","INTERSECTING","prototype","scratchCart4","Cartesian4","EllipsoidTangentPlane","origin","ellipsoid","Ellipsoid","WGS84","scaleToGeodeticSurface","DeveloperError","eastNorthUp","Transforms","eastNorthUpToFixedFrame","_ellipsoid","_origin","_xAxis","fromCartesian4","Matrix4","getColumn","_yAxis","_plane","Plane","fromPointNormal","Object","defineProperties","get","xAxis","yAxis","zAxis","tmp","cartesians","scratchProjectPointOntoPlaneRay","Ray","scratchProjectPointOntoPlaneCartesian3","projectPointOntoPlane","cartesian","ray","normalize","direction","intersectionPoint","IntersectionTests","rayPlane","negate","v","Cartesian2","projectPointsOntoPlane","count","projectPointToNearestOnPlane","projectPointsToNearestOnPlane","projectPointsOntoEllipsoidScratch","projectPointOntoEllipsoid","add","scaleToGeocentricSurface","projectPointsOntoEllipsoid","Array"],"mappings":"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"}