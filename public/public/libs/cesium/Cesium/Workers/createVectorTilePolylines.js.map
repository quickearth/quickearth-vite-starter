{"version":3,"file":"createVectorTilePolylines.js","sources":["../../../../Source/Core/decodeVectorPolylinePositions.js","../../../../Source/WorkersES6/createVectorTilePolylines.js"],"sourcesContent":["import AttributeCompression from \"./AttributeCompression.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport CesiumMath from \"./Math.js\";\n\nvar maxShort = 32767;\n\nvar scratchBVCartographic = new Cartographic();\nvar scratchEncodedPosition = new Cartesian3();\n\nfunction decodeVectorPolylinePositions(\n  positions,\n  rectangle,\n  minimumHeight,\n  maximumHeight,\n  ellipsoid\n) {\n  var positionsLength = positions.length / 3;\n  var uBuffer = positions.subarray(0, positionsLength);\n  var vBuffer = positions.subarray(positionsLength, 2 * positionsLength);\n  var heightBuffer = positions.subarray(\n    2 * positionsLength,\n    3 * positionsLength\n  );\n  AttributeCompression.zigZagDeltaDecode(uBuffer, vBuffer, heightBuffer);\n\n  var decoded = new Float64Array(positions.length);\n  for (var i = 0; i < positionsLength; ++i) {\n    var u = uBuffer[i];\n    var v = vBuffer[i];\n    var h = heightBuffer[i];\n\n    var lon = CesiumMath.lerp(rectangle.west, rectangle.east, u / maxShort);\n    var lat = CesiumMath.lerp(rectangle.south, rectangle.north, v / maxShort);\n    var alt = CesiumMath.lerp(minimumHeight, maximumHeight, h / maxShort);\n\n    var cartographic = Cartographic.fromRadians(\n      lon,\n      lat,\n      alt,\n      scratchBVCartographic\n    );\n    var decodedPosition = ellipsoid.cartographicToCartesian(\n      cartographic,\n      scratchEncodedPosition\n    );\n    Cartesian3.pack(decodedPosition, decoded, i * 3);\n  }\n  return decoded;\n}\nexport default decodeVectorPolylinePositions;\n","import Cartesian3 from \"../Core/Cartesian3.js\";\nimport decodeVectorPolylinePositions from \"../Core/decodeVectorPolylinePositions.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport createTaskProcessorWorker from \"./createTaskProcessorWorker.js\";\n\nvar scratchRectangle = new Rectangle();\nvar scratchEllipsoid = new Ellipsoid();\nvar scratchCenter = new Cartesian3();\nvar scratchMinMaxHeights = {\n  min: undefined,\n  max: undefined,\n};\n\nfunction unpackBuffer(packedBuffer) {\n  packedBuffer = new Float64Array(packedBuffer);\n\n  var offset = 0;\n  scratchMinMaxHeights.min = packedBuffer[offset++];\n  scratchMinMaxHeights.max = packedBuffer[offset++];\n\n  Rectangle.unpack(packedBuffer, offset, scratchRectangle);\n  offset += Rectangle.packedLength;\n\n  Ellipsoid.unpack(packedBuffer, offset, scratchEllipsoid);\n  offset += Ellipsoid.packedLength;\n\n  Cartesian3.unpack(packedBuffer, offset, scratchCenter);\n}\n\nvar scratchP0 = new Cartesian3();\nvar scratchP1 = new Cartesian3();\nvar scratchPrev = new Cartesian3();\nvar scratchCur = new Cartesian3();\nvar scratchNext = new Cartesian3();\n\nfunction createVectorTilePolylines(parameters, transferableObjects) {\n  var encodedPositions = new Uint16Array(parameters.positions);\n  var widths = new Uint16Array(parameters.widths);\n  var counts = new Uint32Array(parameters.counts);\n  var batchIds = new Uint16Array(parameters.batchIds);\n\n  unpackBuffer(parameters.packedBuffer);\n  var rectangle = scratchRectangle;\n  var ellipsoid = scratchEllipsoid;\n  var center = scratchCenter;\n  var minimumHeight = scratchMinMaxHeights.min;\n  var maximumHeight = scratchMinMaxHeights.max;\n\n  var positions = decodeVectorPolylinePositions(\n    encodedPositions,\n    rectangle,\n    minimumHeight,\n    maximumHeight,\n    ellipsoid\n  );\n\n  var positionsLength = positions.length / 3;\n  var size = positionsLength * 4 - 4;\n\n  var curPositions = new Float32Array(size * 3);\n  var prevPositions = new Float32Array(size * 3);\n  var nextPositions = new Float32Array(size * 3);\n  var expandAndWidth = new Float32Array(size * 2);\n  var vertexBatchIds = new Uint16Array(size);\n\n  var positionIndex = 0;\n  var expandAndWidthIndex = 0;\n  var batchIdIndex = 0;\n\n  var i;\n  var offset = 0;\n  var length = counts.length;\n\n  for (i = 0; i < length; ++i) {\n    var count = counts[i];\n    var width = widths[i];\n    var batchId = batchIds[i];\n\n    for (var j = 0; j < count; ++j) {\n      var previous;\n      if (j === 0) {\n        var p0 = Cartesian3.unpack(positions, offset * 3, scratchP0);\n        var p1 = Cartesian3.unpack(positions, (offset + 1) * 3, scratchP1);\n\n        previous = Cartesian3.subtract(p0, p1, scratchPrev);\n        Cartesian3.add(p0, previous, previous);\n      } else {\n        previous = Cartesian3.unpack(\n          positions,\n          (offset + j - 1) * 3,\n          scratchPrev\n        );\n      }\n\n      var current = Cartesian3.unpack(positions, (offset + j) * 3, scratchCur);\n\n      var next;\n      if (j === count - 1) {\n        var p2 = Cartesian3.unpack(\n          positions,\n          (offset + count - 1) * 3,\n          scratchP0\n        );\n        var p3 = Cartesian3.unpack(\n          positions,\n          (offset + count - 2) * 3,\n          scratchP1\n        );\n\n        next = Cartesian3.subtract(p2, p3, scratchNext);\n        Cartesian3.add(p2, next, next);\n      } else {\n        next = Cartesian3.unpack(positions, (offset + j + 1) * 3, scratchNext);\n      }\n\n      Cartesian3.subtract(previous, center, previous);\n      Cartesian3.subtract(current, center, current);\n      Cartesian3.subtract(next, center, next);\n\n      var startK = j === 0 ? 2 : 0;\n      var endK = j === count - 1 ? 2 : 4;\n\n      for (var k = startK; k < endK; ++k) {\n        Cartesian3.pack(current, curPositions, positionIndex);\n        Cartesian3.pack(previous, prevPositions, positionIndex);\n        Cartesian3.pack(next, nextPositions, positionIndex);\n        positionIndex += 3;\n\n        var direction = k - 2 < 0 ? -1.0 : 1.0;\n        expandAndWidth[expandAndWidthIndex++] = 2 * (k % 2) - 1;\n        expandAndWidth[expandAndWidthIndex++] = direction * width;\n\n        vertexBatchIds[batchIdIndex++] = batchId;\n      }\n    }\n\n    offset += count;\n  }\n\n  var indices = IndexDatatype.createTypedArray(size, positionsLength * 6 - 6);\n  var index = 0;\n  var indicesIndex = 0;\n  length = positionsLength - 1;\n  for (i = 0; i < length; ++i) {\n    indices[indicesIndex++] = index;\n    indices[indicesIndex++] = index + 2;\n    indices[indicesIndex++] = index + 1;\n\n    indices[indicesIndex++] = index + 1;\n    indices[indicesIndex++] = index + 2;\n    indices[indicesIndex++] = index + 3;\n\n    index += 4;\n  }\n\n  transferableObjects.push(\n    curPositions.buffer,\n    prevPositions.buffer,\n    nextPositions.buffer\n  );\n  transferableObjects.push(\n    expandAndWidth.buffer,\n    vertexBatchIds.buffer,\n    indices.buffer\n  );\n\n  return {\n    indexDatatype:\n      indices.BYTES_PER_ELEMENT === 2\n        ? IndexDatatype.UNSIGNED_SHORT\n        : IndexDatatype.UNSIGNED_INT,\n    currentPositions: curPositions.buffer,\n    previousPositions: prevPositions.buffer,\n    nextPositions: nextPositions.buffer,\n    expandAndWidth: expandAndWidth.buffer,\n    batchIds: vertexBatchIds.buffer,\n    indices: indices.buffer,\n  };\n}\nexport default createTaskProcessorWorker(createVectorTilePolylines);\n"],"names":["maxShort","scratchBVCartographic","Cartographic","scratchEncodedPosition","Cartesian3","scratchRectangle","Rectangle","scratchEllipsoid","Ellipsoid","scratchCenter","scratchMinMaxHeights","min","undefined","max","scratchP0","scratchP1","scratchPrev","scratchCur","scratchNext","createTaskProcessorWorker","parameters","transferableObjects","encodedPositions","Uint16Array","positions","widths","counts","Uint32Array","batchIds","packedBuffer","Float64Array","offset","unpack","packedLength","unpackBuffer","center","rectangle","minimumHeight","maximumHeight","ellipsoid","positionsLength","length","uBuffer","subarray","vBuffer","heightBuffer","AttributeCompression","zigZagDeltaDecode","decoded","i","u","v","h","lon","CesiumMath","lerp","west","east","lat","south","north","alt","cartographic","fromRadians","decodedPosition","cartographicToCartesian","pack","decodeVectorPolylinePositions","size","curPositions","Float32Array","prevPositions","nextPositions","expandAndWidth","vertexBatchIds","positionIndex","expandAndWidthIndex","batchIdIndex","previous","count","width","batchId","j","p0","p1","subtract","add","p2","p3","next","current","endK","k","direction","indices","IndexDatatype","createTypedArray","index","indicesIndex","push","buffer","indexDatatype","BYTES_PER_ELEMENT","UNSIGNED_SHORT","UNSIGNED_INT","currentPositions","previousPositions"],"mappings":"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"}