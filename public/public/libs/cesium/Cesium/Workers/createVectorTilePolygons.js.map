{"version":3,"file":"createVectorTilePolygons.js","sources":["../../../../Source/WorkersES6/createVectorTilePolygons.js"],"sourcesContent":["import AttributeCompression from \"../Core/AttributeCompression.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport createTaskProcessorWorker from \"./createTaskProcessorWorker.js\";\n\nvar scratchCenter = new Cartesian3();\nvar scratchEllipsoid = new Ellipsoid();\nvar scratchRectangle = new Rectangle();\nvar scratchScalars = {\n  min: undefined,\n  max: undefined,\n  indexBytesPerElement: undefined,\n};\n\nfunction unpackBuffer(buffer) {\n  var packedBuffer = new Float64Array(buffer);\n\n  var offset = 0;\n  scratchScalars.indexBytesPerElement = packedBuffer[offset++];\n\n  scratchScalars.min = packedBuffer[offset++];\n  scratchScalars.max = packedBuffer[offset++];\n\n  Cartesian3.unpack(packedBuffer, offset, scratchCenter);\n  offset += Cartesian3.packedLength;\n\n  Ellipsoid.unpack(packedBuffer, offset, scratchEllipsoid);\n  offset += Ellipsoid.packedLength;\n\n  Rectangle.unpack(packedBuffer, offset, scratchRectangle);\n}\n\nfunction packedBatchedIndicesLength(batchedIndices) {\n  var length = batchedIndices.length;\n  var count = 0;\n  for (var i = 0; i < length; ++i) {\n    count += Color.packedLength + 3 + batchedIndices[i].batchIds.length;\n  }\n  return count;\n}\n\nfunction packBuffer(indexDatatype, boundingVolumes, batchedIndices) {\n  var numBVs = boundingVolumes.length;\n  var length =\n    1 +\n    1 +\n    numBVs * OrientedBoundingBox.packedLength +\n    1 +\n    packedBatchedIndicesLength(batchedIndices);\n\n  var packedBuffer = new Float64Array(length);\n\n  var offset = 0;\n  packedBuffer[offset++] = indexDatatype;\n  packedBuffer[offset++] = numBVs;\n\n  for (var i = 0; i < numBVs; ++i) {\n    OrientedBoundingBox.pack(boundingVolumes[i], packedBuffer, offset);\n    offset += OrientedBoundingBox.packedLength;\n  }\n\n  var indicesLength = batchedIndices.length;\n  packedBuffer[offset++] = indicesLength;\n\n  for (var j = 0; j < indicesLength; ++j) {\n    var batchedIndex = batchedIndices[j];\n\n    Color.pack(batchedIndex.color, packedBuffer, offset);\n    offset += Color.packedLength;\n\n    packedBuffer[offset++] = batchedIndex.offset;\n    packedBuffer[offset++] = batchedIndex.count;\n\n    var batchIds = batchedIndex.batchIds;\n    var batchIdsLength = batchIds.length;\n    packedBuffer[offset++] = batchIdsLength;\n\n    for (var k = 0; k < batchIdsLength; ++k) {\n      packedBuffer[offset++] = batchIds[k];\n    }\n  }\n\n  return packedBuffer;\n}\n\nvar maxShort = 32767;\n\nvar scratchEncodedPosition = new Cartesian3();\nvar scratchNormal = new Cartesian3();\nvar scratchScaledNormal = new Cartesian3();\nvar scratchMinHeightPosition = new Cartesian3();\nvar scratchMaxHeightPosition = new Cartesian3();\nvar scratchBVCartographic = new Cartographic();\nvar scratchBVRectangle = new Rectangle();\n\nfunction createVectorTilePolygons(parameters, transferableObjects) {\n  unpackBuffer(parameters.packedBuffer);\n\n  var indices;\n  var indexBytesPerElement = scratchScalars.indexBytesPerElement;\n  if (indexBytesPerElement === 2) {\n    indices = new Uint16Array(parameters.indices);\n  } else {\n    indices = new Uint32Array(parameters.indices);\n  }\n\n  var positions = new Uint16Array(parameters.positions);\n  var counts = new Uint32Array(parameters.counts);\n  var indexCounts = new Uint32Array(parameters.indexCounts);\n  var batchIds = new Uint32Array(parameters.batchIds);\n  var batchTableColors = new Uint32Array(parameters.batchTableColors);\n\n  var boundingVolumes = new Array(counts.length);\n\n  var center = scratchCenter;\n  var ellipsoid = scratchEllipsoid;\n  var rectangle = scratchRectangle;\n  var minHeight = scratchScalars.min;\n  var maxHeight = scratchScalars.max;\n\n  var minimumHeights = parameters.minimumHeights;\n  var maximumHeights = parameters.maximumHeights;\n  if (defined(minimumHeights) && defined(maximumHeights)) {\n    minimumHeights = new Float32Array(minimumHeights);\n    maximumHeights = new Float32Array(maximumHeights);\n  }\n\n  var i;\n  var j;\n  var rgba;\n\n  var positionsLength = positions.length / 2;\n  var uBuffer = positions.subarray(0, positionsLength);\n  var vBuffer = positions.subarray(positionsLength, 2 * positionsLength);\n  AttributeCompression.zigZagDeltaDecode(uBuffer, vBuffer);\n\n  var decodedPositions = new Float64Array(positionsLength * 3);\n  for (i = 0; i < positionsLength; ++i) {\n    var u = uBuffer[i];\n    var v = vBuffer[i];\n\n    var x = CesiumMath.lerp(rectangle.west, rectangle.east, u / maxShort);\n    var y = CesiumMath.lerp(rectangle.south, rectangle.north, v / maxShort);\n\n    var cart = Cartographic.fromRadians(x, y, 0.0, scratchBVCartographic);\n    var decodedPosition = ellipsoid.cartographicToCartesian(\n      cart,\n      scratchEncodedPosition\n    );\n    Cartesian3.pack(decodedPosition, decodedPositions, i * 3);\n  }\n\n  var countsLength = counts.length;\n  var offsets = new Array(countsLength);\n  var indexOffsets = new Array(countsLength);\n  var currentOffset = 0;\n  var currentIndexOffset = 0;\n  for (i = 0; i < countsLength; ++i) {\n    offsets[i] = currentOffset;\n    indexOffsets[i] = currentIndexOffset;\n\n    currentOffset += counts[i];\n    currentIndexOffset += indexCounts[i];\n  }\n\n  var batchedPositions = new Float32Array(positionsLength * 3 * 2);\n  var batchedIds = new Uint16Array(positionsLength * 2);\n  var batchedIndexOffsets = new Uint32Array(indexOffsets.length);\n  var batchedIndexCounts = new Uint32Array(indexCounts.length);\n  var batchedIndices = [];\n\n  var colorToBuffers = {};\n  for (i = 0; i < countsLength; ++i) {\n    rgba = batchTableColors[i];\n    if (!defined(colorToBuffers[rgba])) {\n      colorToBuffers[rgba] = {\n        positionLength: counts[i],\n        indexLength: indexCounts[i],\n        offset: 0,\n        indexOffset: 0,\n        batchIds: [i],\n      };\n    } else {\n      colorToBuffers[rgba].positionLength += counts[i];\n      colorToBuffers[rgba].indexLength += indexCounts[i];\n      colorToBuffers[rgba].batchIds.push(i);\n    }\n  }\n\n  // get the offsets and counts for the positions and indices of each primitive\n  var buffer;\n  var byColorPositionOffset = 0;\n  var byColorIndexOffset = 0;\n  for (rgba in colorToBuffers) {\n    if (colorToBuffers.hasOwnProperty(rgba)) {\n      buffer = colorToBuffers[rgba];\n      buffer.offset = byColorPositionOffset;\n      buffer.indexOffset = byColorIndexOffset;\n\n      var positionLength = buffer.positionLength * 2;\n      var indexLength = buffer.indexLength * 2 + buffer.positionLength * 6;\n\n      byColorPositionOffset += positionLength;\n      byColorIndexOffset += indexLength;\n\n      buffer.indexLength = indexLength;\n    }\n  }\n\n  var batchedDrawCalls = [];\n\n  for (rgba in colorToBuffers) {\n    if (colorToBuffers.hasOwnProperty(rgba)) {\n      buffer = colorToBuffers[rgba];\n\n      batchedDrawCalls.push({\n        color: Color.fromRgba(parseInt(rgba)),\n        offset: buffer.indexOffset,\n        count: buffer.indexLength,\n        batchIds: buffer.batchIds,\n      });\n    }\n  }\n\n  for (i = 0; i < countsLength; ++i) {\n    rgba = batchTableColors[i];\n\n    buffer = colorToBuffers[rgba];\n    var positionOffset = buffer.offset;\n    var positionIndex = positionOffset * 3;\n    var batchIdIndex = positionOffset;\n\n    var polygonOffset = offsets[i];\n    var polygonCount = counts[i];\n    var batchId = batchIds[i];\n\n    var polygonMinimumHeight = minHeight;\n    var polygonMaximumHeight = maxHeight;\n    if (defined(minimumHeights) && defined(maximumHeights)) {\n      polygonMinimumHeight = minimumHeights[i];\n      polygonMaximumHeight = maximumHeights[i];\n    }\n\n    var minLat = Number.POSITIVE_INFINITY;\n    var maxLat = Number.NEGATIVE_INFINITY;\n    var minLon = Number.POSITIVE_INFINITY;\n    var maxLon = Number.NEGATIVE_INFINITY;\n\n    for (j = 0; j < polygonCount; ++j) {\n      var position = Cartesian3.unpack(\n        decodedPositions,\n        polygonOffset * 3 + j * 3,\n        scratchEncodedPosition\n      );\n      ellipsoid.scaleToGeodeticSurface(position, position);\n\n      var carto = ellipsoid.cartesianToCartographic(\n        position,\n        scratchBVCartographic\n      );\n      var lat = carto.latitude;\n      var lon = carto.longitude;\n\n      minLat = Math.min(lat, minLat);\n      maxLat = Math.max(lat, maxLat);\n      minLon = Math.min(lon, minLon);\n      maxLon = Math.max(lon, maxLon);\n\n      var normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\n      var scaledNormal = Cartesian3.multiplyByScalar(\n        normal,\n        polygonMinimumHeight,\n        scratchScaledNormal\n      );\n      var minHeightPosition = Cartesian3.add(\n        position,\n        scaledNormal,\n        scratchMinHeightPosition\n      );\n\n      scaledNormal = Cartesian3.multiplyByScalar(\n        normal,\n        polygonMaximumHeight,\n        scaledNormal\n      );\n      var maxHeightPosition = Cartesian3.add(\n        position,\n        scaledNormal,\n        scratchMaxHeightPosition\n      );\n\n      Cartesian3.subtract(maxHeightPosition, center, maxHeightPosition);\n      Cartesian3.subtract(minHeightPosition, center, minHeightPosition);\n\n      Cartesian3.pack(maxHeightPosition, batchedPositions, positionIndex);\n      Cartesian3.pack(minHeightPosition, batchedPositions, positionIndex + 3);\n\n      batchedIds[batchIdIndex] = batchId;\n      batchedIds[batchIdIndex + 1] = batchId;\n\n      positionIndex += 6;\n      batchIdIndex += 2;\n    }\n\n    rectangle = scratchBVRectangle;\n    rectangle.west = minLon;\n    rectangle.east = maxLon;\n    rectangle.south = minLat;\n    rectangle.north = maxLat;\n\n    boundingVolumes[i] = OrientedBoundingBox.fromRectangle(\n      rectangle,\n      minHeight,\n      maxHeight,\n      ellipsoid\n    );\n\n    var indicesIndex = buffer.indexOffset;\n\n    var indexOffset = indexOffsets[i];\n    var indexCount = indexCounts[i];\n\n    batchedIndexOffsets[i] = indicesIndex;\n\n    for (j = 0; j < indexCount; j += 3) {\n      var i0 = indices[indexOffset + j] - polygonOffset;\n      var i1 = indices[indexOffset + j + 1] - polygonOffset;\n      var i2 = indices[indexOffset + j + 2] - polygonOffset;\n\n      // triangle on the top of the extruded polygon\n      batchedIndices[indicesIndex++] = i0 * 2 + positionOffset;\n      batchedIndices[indicesIndex++] = i1 * 2 + positionOffset;\n      batchedIndices[indicesIndex++] = i2 * 2 + positionOffset;\n\n      // triangle on the bottom of the extruded polygon\n      batchedIndices[indicesIndex++] = i2 * 2 + 1 + positionOffset;\n      batchedIndices[indicesIndex++] = i1 * 2 + 1 + positionOffset;\n      batchedIndices[indicesIndex++] = i0 * 2 + 1 + positionOffset;\n    }\n\n    // indices for the walls of the extruded polygon\n    for (j = 0; j < polygonCount; ++j) {\n      var v0 = j;\n      var v1 = (j + 1) % polygonCount;\n\n      batchedIndices[indicesIndex++] = v0 * 2 + 1 + positionOffset;\n      batchedIndices[indicesIndex++] = v1 * 2 + positionOffset;\n      batchedIndices[indicesIndex++] = v0 * 2 + positionOffset;\n\n      batchedIndices[indicesIndex++] = v0 * 2 + 1 + positionOffset;\n      batchedIndices[indicesIndex++] = v1 * 2 + 1 + positionOffset;\n      batchedIndices[indicesIndex++] = v1 * 2 + positionOffset;\n    }\n\n    buffer.offset += polygonCount * 2;\n    buffer.indexOffset = indicesIndex;\n\n    batchedIndexCounts[i] = indicesIndex - batchedIndexOffsets[i];\n  }\n\n  batchedIndices = IndexDatatype.createTypedArray(\n    batchedPositions.length / 3,\n    batchedIndices\n  );\n\n  var batchedIndicesLength = batchedDrawCalls.length;\n  for (var m = 0; m < batchedIndicesLength; ++m) {\n    var tempIds = batchedDrawCalls[m].batchIds;\n    var count = 0;\n    var tempIdsLength = tempIds.length;\n    for (var n = 0; n < tempIdsLength; ++n) {\n      count += batchedIndexCounts[tempIds[n]];\n    }\n    batchedDrawCalls[m].count = count;\n  }\n\n  var indexDatatype =\n    batchedIndices.BYTES_PER_ELEMENT === 2\n      ? IndexDatatype.UNSIGNED_SHORT\n      : IndexDatatype.UNSIGNED_INT;\n  var packedBuffer = packBuffer(\n    indexDatatype,\n    boundingVolumes,\n    batchedDrawCalls\n  );\n\n  transferableObjects.push(\n    batchedPositions.buffer,\n    batchedIndices.buffer,\n    batchedIndexOffsets.buffer,\n    batchedIndexCounts.buffer,\n    batchedIds.buffer,\n    packedBuffer.buffer\n  );\n\n  return {\n    positions: batchedPositions.buffer,\n    indices: batchedIndices.buffer,\n    indexOffsets: batchedIndexOffsets.buffer,\n    indexCounts: batchedIndexCounts.buffer,\n    batchIds: batchedIds.buffer,\n    packedBuffer: packedBuffer.buffer,\n  };\n}\nexport default createTaskProcessorWorker(createVectorTilePolygons);\n"],"names":["scratchCenter","Cartesian3","scratchEllipsoid","Ellipsoid","scratchRectangle","Rectangle","scratchScalars","min","undefined","max","indexBytesPerElement","packBuffer","indexDatatype","boundingVolumes","batchedIndices","numBVs","length","OrientedBoundingBox","packedLength","count","i","Color","batchIds","packedBatchedIndicesLength","packedBuffer","Float64Array","offset","pack","indicesLength","j","batchedIndex","color","batchIdsLength","k","scratchEncodedPosition","scratchNormal","scratchScaledNormal","scratchMinHeightPosition","scratchMaxHeightPosition","scratchBVCartographic","Cartographic","scratchBVRectangle","createTaskProcessorWorker","parameters","transferableObjects","buffer","unpack","indices","Uint16Array","Uint32Array","positions","counts","indexCounts","batchTableColors","Array","center","ellipsoid","rectangle","minHeight","maxHeight","minimumHeights","maximumHeights","defined","Float32Array","positionsLength","uBuffer","subarray","vBuffer","AttributeCompression","zigZagDeltaDecode","decodedPositions","u","v","x","CesiumMath","lerp","west","east","y","south","north","cart","fromRadians","decodedPosition","cartographicToCartesian","countsLength","offsets","indexOffsets","currentOffset","currentIndexOffset","batchedPositions","batchedIds","batchedIndexOffsets","batchedIndexCounts","colorToBuffers","rgba","positionLength","indexLength","push","indexOffset","byColorPositionOffset","byColorIndexOffset","hasOwnProperty","batchedDrawCalls","fromRgba","parseInt","positionOffset","positionIndex","batchIdIndex","polygonOffset","polygonCount","batchId","polygonMinimumHeight","polygonMaximumHeight","minLat","Number","POSITIVE_INFINITY","maxLat","NEGATIVE_INFINITY","minLon","maxLon","position","scaleToGeodeticSurface","carto","cartesianToCartographic","lat","latitude","lon","longitude","Math","normal","geodeticSurfaceNormal","scaledNormal","multiplyByScalar","minHeightPosition","add","maxHeightPosition","subtract","fromRectangle","indicesIndex","indexCount","i0","i1","i2","v0","v1","IndexDatatype","createTypedArray","batchedIndicesLength","m","tempIds","tempIdsLength","n","BYTES_PER_ELEMENT","UNSIGNED_SHORT","UNSIGNED_INT"],"mappings":"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"}