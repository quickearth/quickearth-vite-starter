{"version":3,"file":"CorridorGeometryLibrary-824cd871.js","sources":["../../../../Source/Core/CorridorGeometryLibrary.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport CornerType from \"./CornerType.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport PolylineVolumeGeometryLibrary from \"./PolylineVolumeGeometryLibrary.js\";\nimport Quaternion from \"./Quaternion.js\";\n\n/**\n * @private\n */\nvar CorridorGeometryLibrary = {};\n\nvar scratch1 = new Cartesian3();\nvar scratch2 = new Cartesian3();\nvar scratch3 = new Cartesian3();\nvar scratch4 = new Cartesian3();\n\nvar scaleArray2 = [new Cartesian3(), new Cartesian3()];\n\nvar cartesian1 = new Cartesian3();\nvar cartesian2 = new Cartesian3();\nvar cartesian3 = new Cartesian3();\nvar cartesian4 = new Cartesian3();\nvar cartesian5 = new Cartesian3();\nvar cartesian6 = new Cartesian3();\nvar cartesian7 = new Cartesian3();\nvar cartesian8 = new Cartesian3();\nvar cartesian9 = new Cartesian3();\nvar cartesian10 = new Cartesian3();\n\nvar quaterion = new Quaternion();\nvar rotMatrix = new Matrix3();\nfunction computeRoundCorner(\n  cornerPoint,\n  startPoint,\n  endPoint,\n  cornerType,\n  leftIsOutside\n) {\n  var angle = Cartesian3.angleBetween(\n    Cartesian3.subtract(startPoint, cornerPoint, scratch1),\n    Cartesian3.subtract(endPoint, cornerPoint, scratch2)\n  );\n  var granularity =\n    cornerType === CornerType.BEVELED\n      ? 1\n      : Math.ceil(angle / CesiumMath.toRadians(5)) + 1;\n\n  var size = granularity * 3;\n  var array = new Array(size);\n\n  array[size - 3] = endPoint.x;\n  array[size - 2] = endPoint.y;\n  array[size - 1] = endPoint.z;\n\n  var m;\n  if (leftIsOutside) {\n    m = Matrix3.fromQuaternion(\n      Quaternion.fromAxisAngle(\n        Cartesian3.negate(cornerPoint, scratch1),\n        angle / granularity,\n        quaterion\n      ),\n      rotMatrix\n    );\n  } else {\n    m = Matrix3.fromQuaternion(\n      Quaternion.fromAxisAngle(cornerPoint, angle / granularity, quaterion),\n      rotMatrix\n    );\n  }\n\n  var index = 0;\n  startPoint = Cartesian3.clone(startPoint, scratch1);\n  for (var i = 0; i < granularity; i++) {\n    startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\n    array[index++] = startPoint.x;\n    array[index++] = startPoint.y;\n    array[index++] = startPoint.z;\n  }\n\n  return array;\n}\n\nfunction addEndCaps(calculatedPositions) {\n  var cornerPoint = cartesian1;\n  var startPoint = cartesian2;\n  var endPoint = cartesian3;\n\n  var leftEdge = calculatedPositions[1];\n  startPoint = Cartesian3.fromArray(\n    calculatedPositions[1],\n    leftEdge.length - 3,\n    startPoint\n  );\n  endPoint = Cartesian3.fromArray(calculatedPositions[0], 0, endPoint);\n  cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\n  var firstEndCap = computeRoundCorner(\n    cornerPoint,\n    startPoint,\n    endPoint,\n    CornerType.ROUNDED,\n    false\n  );\n\n  var length = calculatedPositions.length - 1;\n  var rightEdge = calculatedPositions[length - 1];\n  leftEdge = calculatedPositions[length];\n  startPoint = Cartesian3.fromArray(\n    rightEdge,\n    rightEdge.length - 3,\n    startPoint\n  );\n  endPoint = Cartesian3.fromArray(leftEdge, 0, endPoint);\n  cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\n  var lastEndCap = computeRoundCorner(\n    cornerPoint,\n    startPoint,\n    endPoint,\n    CornerType.ROUNDED,\n    false\n  );\n\n  return [firstEndCap, lastEndCap];\n}\n\nfunction computeMiteredCorner(\n  position,\n  leftCornerDirection,\n  lastPoint,\n  leftIsOutside\n) {\n  var cornerPoint = scratch1;\n  if (leftIsOutside) {\n    cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\n  } else {\n    leftCornerDirection = Cartesian3.negate(\n      leftCornerDirection,\n      leftCornerDirection\n    );\n    cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\n  }\n  return [\n    cornerPoint.x,\n    cornerPoint.y,\n    cornerPoint.z,\n    lastPoint.x,\n    lastPoint.y,\n    lastPoint.z,\n  ];\n}\n\nfunction addShiftedPositions(positions, left, scalar, calculatedPositions) {\n  var rightPositions = new Array(positions.length);\n  var leftPositions = new Array(positions.length);\n  var scaledLeft = Cartesian3.multiplyByScalar(left, scalar, scratch1);\n  var scaledRight = Cartesian3.negate(scaledLeft, scratch2);\n  var rightIndex = 0;\n  var leftIndex = positions.length - 1;\n\n  for (var i = 0; i < positions.length; i += 3) {\n    var pos = Cartesian3.fromArray(positions, i, scratch3);\n    var rightPos = Cartesian3.add(pos, scaledRight, scratch4);\n    rightPositions[rightIndex++] = rightPos.x;\n    rightPositions[rightIndex++] = rightPos.y;\n    rightPositions[rightIndex++] = rightPos.z;\n\n    var leftPos = Cartesian3.add(pos, scaledLeft, scratch4);\n    leftPositions[leftIndex--] = leftPos.z;\n    leftPositions[leftIndex--] = leftPos.y;\n    leftPositions[leftIndex--] = leftPos.x;\n  }\n  calculatedPositions.push(rightPositions, leftPositions);\n\n  return calculatedPositions;\n}\n\n/**\n * @private\n */\nCorridorGeometryLibrary.addAttribute = function (\n  attribute,\n  value,\n  front,\n  back\n) {\n  var x = value.x;\n  var y = value.y;\n  var z = value.z;\n  if (defined(front)) {\n    attribute[front] = x;\n    attribute[front + 1] = y;\n    attribute[front + 2] = z;\n  }\n  if (defined(back)) {\n    attribute[back] = z;\n    attribute[back - 1] = y;\n    attribute[back - 2] = x;\n  }\n};\n\nvar scratchForwardProjection = new Cartesian3();\nvar scratchBackwardProjection = new Cartesian3();\n\n/**\n * @private\n */\nCorridorGeometryLibrary.computePositions = function (params) {\n  var granularity = params.granularity;\n  var positions = params.positions;\n  var ellipsoid = params.ellipsoid;\n  var width = params.width / 2;\n  var cornerType = params.cornerType;\n  var saveAttributes = params.saveAttributes;\n  var normal = cartesian1;\n  var forward = cartesian2;\n  var backward = cartesian3;\n  var left = cartesian4;\n  var cornerDirection = cartesian5;\n  var startPoint = cartesian6;\n  var previousPos = cartesian7;\n  var rightPos = cartesian8;\n  var leftPos = cartesian9;\n  var center = cartesian10;\n  var calculatedPositions = [];\n  var calculatedLefts = saveAttributes ? [] : undefined;\n  var calculatedNormals = saveAttributes ? [] : undefined;\n  var position = positions[0]; //add first point\n  var nextPosition = positions[1];\n\n  forward = Cartesian3.normalize(\n    Cartesian3.subtract(nextPosition, position, forward),\n    forward\n  );\n  normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n  left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\n  if (saveAttributes) {\n    calculatedLefts.push(left.x, left.y, left.z);\n    calculatedNormals.push(normal.x, normal.y, normal.z);\n  }\n  previousPos = Cartesian3.clone(position, previousPos);\n  position = nextPosition;\n  backward = Cartesian3.negate(forward, backward);\n\n  var subdividedPositions;\n  var corners = [];\n  var i;\n  var length = positions.length;\n  for (i = 1; i < length - 1; i++) {\n    // add middle points and corners\n    normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n    nextPosition = positions[i + 1];\n    forward = Cartesian3.normalize(\n      Cartesian3.subtract(nextPosition, position, forward),\n      forward\n    );\n    cornerDirection = Cartesian3.normalize(\n      Cartesian3.add(forward, backward, cornerDirection),\n      cornerDirection\n    );\n\n    var forwardProjection = Cartesian3.multiplyByScalar(\n      normal,\n      Cartesian3.dot(forward, normal),\n      scratchForwardProjection\n    );\n    Cartesian3.subtract(forward, forwardProjection, forwardProjection);\n    Cartesian3.normalize(forwardProjection, forwardProjection);\n\n    var backwardProjection = Cartesian3.multiplyByScalar(\n      normal,\n      Cartesian3.dot(backward, normal),\n      scratchBackwardProjection\n    );\n    Cartesian3.subtract(backward, backwardProjection, backwardProjection);\n    Cartesian3.normalize(backwardProjection, backwardProjection);\n\n    var doCorner = !CesiumMath.equalsEpsilon(\n      Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)),\n      1.0,\n      CesiumMath.EPSILON7\n    );\n\n    if (doCorner) {\n      cornerDirection = Cartesian3.cross(\n        cornerDirection,\n        normal,\n        cornerDirection\n      );\n      cornerDirection = Cartesian3.cross(\n        normal,\n        cornerDirection,\n        cornerDirection\n      );\n      cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n      var scalar =\n        width /\n        Math.max(\n          0.25,\n          Cartesian3.magnitude(\n            Cartesian3.cross(cornerDirection, backward, scratch1)\n          )\n        );\n      var leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(\n        forward,\n        backward,\n        position,\n        ellipsoid\n      );\n      cornerDirection = Cartesian3.multiplyByScalar(\n        cornerDirection,\n        scalar,\n        cornerDirection\n      );\n      if (leftIsOutside) {\n        rightPos = Cartesian3.add(position, cornerDirection, rightPos);\n        center = Cartesian3.add(\n          rightPos,\n          Cartesian3.multiplyByScalar(left, width, center),\n          center\n        );\n        leftPos = Cartesian3.add(\n          rightPos,\n          Cartesian3.multiplyByScalar(left, width * 2, leftPos),\n          leftPos\n        );\n        scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n        scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scaleArray2,\n          granularity: granularity,\n          ellipsoid: ellipsoid,\n        });\n        calculatedPositions = addShiftedPositions(\n          subdividedPositions,\n          left,\n          width,\n          calculatedPositions\n        );\n        if (saveAttributes) {\n          calculatedLefts.push(left.x, left.y, left.z);\n          calculatedNormals.push(normal.x, normal.y, normal.z);\n        }\n        startPoint = Cartesian3.clone(leftPos, startPoint);\n        left = Cartesian3.normalize(\n          Cartesian3.cross(normal, forward, left),\n          left\n        );\n        leftPos = Cartesian3.add(\n          rightPos,\n          Cartesian3.multiplyByScalar(left, width * 2, leftPos),\n          leftPos\n        );\n        previousPos = Cartesian3.add(\n          rightPos,\n          Cartesian3.multiplyByScalar(left, width, previousPos),\n          previousPos\n        );\n        if (\n          cornerType === CornerType.ROUNDED ||\n          cornerType === CornerType.BEVELED\n        ) {\n          corners.push({\n            leftPositions: computeRoundCorner(\n              rightPos,\n              startPoint,\n              leftPos,\n              cornerType,\n              leftIsOutside\n            ),\n          });\n        } else {\n          corners.push({\n            leftPositions: computeMiteredCorner(\n              position,\n              Cartesian3.negate(cornerDirection, cornerDirection),\n              leftPos,\n              leftIsOutside\n            ),\n          });\n        }\n      } else {\n        leftPos = Cartesian3.add(position, cornerDirection, leftPos);\n        center = Cartesian3.add(\n          leftPos,\n          Cartesian3.negate(\n            Cartesian3.multiplyByScalar(left, width, center),\n            center\n          ),\n          center\n        );\n        rightPos = Cartesian3.add(\n          leftPos,\n          Cartesian3.negate(\n            Cartesian3.multiplyByScalar(left, width * 2, rightPos),\n            rightPos\n          ),\n          rightPos\n        );\n        scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n        scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scaleArray2,\n          granularity: granularity,\n          ellipsoid: ellipsoid,\n        });\n        calculatedPositions = addShiftedPositions(\n          subdividedPositions,\n          left,\n          width,\n          calculatedPositions\n        );\n        if (saveAttributes) {\n          calculatedLefts.push(left.x, left.y, left.z);\n          calculatedNormals.push(normal.x, normal.y, normal.z);\n        }\n        startPoint = Cartesian3.clone(rightPos, startPoint);\n        left = Cartesian3.normalize(\n          Cartesian3.cross(normal, forward, left),\n          left\n        );\n        rightPos = Cartesian3.add(\n          leftPos,\n          Cartesian3.negate(\n            Cartesian3.multiplyByScalar(left, width * 2, rightPos),\n            rightPos\n          ),\n          rightPos\n        );\n        previousPos = Cartesian3.add(\n          leftPos,\n          Cartesian3.negate(\n            Cartesian3.multiplyByScalar(left, width, previousPos),\n            previousPos\n          ),\n          previousPos\n        );\n        if (\n          cornerType === CornerType.ROUNDED ||\n          cornerType === CornerType.BEVELED\n        ) {\n          corners.push({\n            rightPositions: computeRoundCorner(\n              leftPos,\n              startPoint,\n              rightPos,\n              cornerType,\n              leftIsOutside\n            ),\n          });\n        } else {\n          corners.push({\n            rightPositions: computeMiteredCorner(\n              position,\n              cornerDirection,\n              rightPos,\n              leftIsOutside\n            ),\n          });\n        }\n      }\n      backward = Cartesian3.negate(forward, backward);\n    }\n    position = nextPosition;\n  }\n\n  normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n  scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n  scaleArray2[1] = Cartesian3.clone(position, scaleArray2[1]);\n  subdividedPositions = PolylinePipeline.generateArc({\n    positions: scaleArray2,\n    granularity: granularity,\n    ellipsoid: ellipsoid,\n  });\n  calculatedPositions = addShiftedPositions(\n    subdividedPositions,\n    left,\n    width,\n    calculatedPositions\n  );\n  if (saveAttributes) {\n    calculatedLefts.push(left.x, left.y, left.z);\n    calculatedNormals.push(normal.x, normal.y, normal.z);\n  }\n\n  var endPositions;\n  if (cornerType === CornerType.ROUNDED) {\n    endPositions = addEndCaps(calculatedPositions);\n  }\n\n  return {\n    positions: calculatedPositions,\n    corners: corners,\n    lefts: calculatedLefts,\n    normals: calculatedNormals,\n    endPositions: endPositions,\n  };\n};\nexport default CorridorGeometryLibrary;\n"],"names":["CorridorGeometryLibrary","scratch1","Cartesian3","scratch2","scratch3","scratch4","scaleArray2","cartesian1","cartesian2","cartesian3","cartesian4","cartesian5","cartesian6","cartesian7","cartesian8","cartesian9","cartesian10","quaterion","Quaternion","rotMatrix","Matrix3","computeRoundCorner","cornerPoint","startPoint","endPoint","cornerType","leftIsOutside","angle","angleBetween","subtract","granularity","CornerType","BEVELED","Math","ceil","CesiumMath","toRadians","size","array","Array","x","y","z","m","fromQuaternion","fromAxisAngle","negate","index","clone","i","multiplyByVector","computeMiteredCorner","position","leftCornerDirection","lastPoint","add","addShiftedPositions","positions","left","scalar","calculatedPositions","rightPositions","length","leftPositions","scaledLeft","multiplyByScalar","scaledRight","rightIndex","leftIndex","pos","fromArray","rightPos","leftPos","push","addAttribute","attribute","value","front","back","defined","scratchForwardProjection","scratchBackwardProjection","computePositions","params","ellipsoid","width","saveAttributes","normal","backward","cornerDirection","previousPos","center","calculatedLefts","undefined","calculatedNormals","nextPosition","forward","normalize","geodeticSurfaceNormal","cross","leftEdge","firstEndCap","corners","forwardProjection","dot","backwardProjection","equalsEpsilon","abs","EPSILON7","max","magnitude","PolylineVolumeGeometryLibrary","angleIsGreaterThanPi","PolylinePipeline","generateArc","ROUNDED","midpoint","rightEdge","endPositions","lefts","normals"],"mappings":"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"}