{"version":3,"file":"CylinderGeometry-72ac91c0.js","sources":["../../../../Source/Core/CylinderGeometry.js"],"sourcesContent":["import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CylinderGeometryLibrary from \"./CylinderGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nvar radiusScratch = new Cartesian2();\nvar normalScratch = new Cartesian3();\nvar bitangentScratch = new Cartesian3();\nvar tangentScratch = new Cartesian3();\nvar positionScratch = new Cartesian3();\n\n/**\n * A description of a cylinder.\n *\n * @alias CylinderGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number} options.length The length of the cylinder.\n * @param {Number} options.topRadius The radius of the top of the cylinder.\n * @param {Number} options.bottomRadius The radius of the bottom of the cylinder.\n * @param {Number} [options.slices=128] The number of edges around the perimeter of the cylinder.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @exception {DeveloperError} options.slices must be greater than or equal to 3.\n *\n * @see CylinderGeometry.createGeometry\n *\n * @example\n * // create cylinder geometry\n * var cylinder = new Cesium.CylinderGeometry({\n *     length: 200000,\n *     topRadius: 80000,\n *     bottomRadius: 200000,\n * });\n * var geometry = Cesium.CylinderGeometry.createGeometry(cylinder);\n */\nfunction CylinderGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var length = options.length;\n  var topRadius = options.topRadius;\n  var bottomRadius = options.bottomRadius;\n  var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n  var slices = defaultValue(options.slices, 128);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(length)) {\n    throw new DeveloperError(\"options.length must be defined.\");\n  }\n  if (!defined(topRadius)) {\n    throw new DeveloperError(\"options.topRadius must be defined.\");\n  }\n  if (!defined(bottomRadius)) {\n    throw new DeveloperError(\"options.bottomRadius must be defined.\");\n  }\n  if (slices < 3) {\n    throw new DeveloperError(\n      \"options.slices must be greater than or equal to 3.\"\n    );\n  }\n  if (\n    defined(options.offsetAttribute) &&\n    options.offsetAttribute === GeometryOffsetAttribute.TOP\n  ) {\n    throw new DeveloperError(\n      \"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._length = length;\n  this._topRadius = topRadius;\n  this._bottomRadius = bottomRadius;\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._slices = slices;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createCylinderGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nCylinderGeometry.packedLength = VertexFormat.packedLength + 5;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CylinderGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCylinderGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._length;\n  array[startingIndex++] = value._topRadius;\n  array[startingIndex++] = value._bottomRadius;\n  array[startingIndex++] = value._slices;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nvar scratchVertexFormat = new VertexFormat();\nvar scratchOptions = {\n  vertexFormat: scratchVertexFormat,\n  length: undefined,\n  topRadius: undefined,\n  bottomRadius: undefined,\n  slices: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CylinderGeometry} [result] The object into which to store the result.\n * @returns {CylinderGeometry} The modified result parameter or a new CylinderGeometry instance if one was not provided.\n */\nCylinderGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  var length = array[startingIndex++];\n  var topRadius = array[startingIndex++];\n  var bottomRadius = array[startingIndex++];\n  var slices = array[startingIndex++];\n  var offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.length = length;\n    scratchOptions.topRadius = topRadius;\n    scratchOptions.bottomRadius = bottomRadius;\n    scratchOptions.slices = slices;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new CylinderGeometry(scratchOptions);\n  }\n\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._length = length;\n  result._topRadius = topRadius;\n  result._bottomRadius = bottomRadius;\n  result._slices = slices;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of a cylinder, including its vertices, indices, and a bounding sphere.\n *\n * @param {CylinderGeometry} cylinderGeometry A description of the cylinder.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCylinderGeometry.createGeometry = function (cylinderGeometry) {\n  var length = cylinderGeometry._length;\n  var topRadius = cylinderGeometry._topRadius;\n  var bottomRadius = cylinderGeometry._bottomRadius;\n  var vertexFormat = cylinderGeometry._vertexFormat;\n  var slices = cylinderGeometry._slices;\n\n  if (\n    length <= 0 ||\n    topRadius < 0 ||\n    bottomRadius < 0 ||\n    (topRadius === 0 && bottomRadius === 0)\n  ) {\n    return;\n  }\n\n  var twoSlices = slices + slices;\n  var threeSlices = slices + twoSlices;\n  var numVertices = twoSlices + twoSlices;\n\n  var positions = CylinderGeometryLibrary.computePositions(\n    length,\n    topRadius,\n    bottomRadius,\n    slices,\n    true\n  );\n\n  var st = vertexFormat.st ? new Float32Array(numVertices * 2) : undefined;\n  var normals = vertexFormat.normal\n    ? new Float32Array(numVertices * 3)\n    : undefined;\n  var tangents = vertexFormat.tangent\n    ? new Float32Array(numVertices * 3)\n    : undefined;\n  var bitangents = vertexFormat.bitangent\n    ? new Float32Array(numVertices * 3)\n    : undefined;\n\n  var i;\n  var computeNormal =\n    vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent;\n\n  if (computeNormal) {\n    var computeTangent = vertexFormat.tangent || vertexFormat.bitangent;\n\n    var normalIndex = 0;\n    var tangentIndex = 0;\n    var bitangentIndex = 0;\n\n    var theta = Math.atan2(bottomRadius - topRadius, length);\n    var normal = normalScratch;\n    normal.z = Math.sin(theta);\n    var normalScale = Math.cos(theta);\n    var tangent = tangentScratch;\n    var bitangent = bitangentScratch;\n\n    for (i = 0; i < slices; i++) {\n      var angle = (i / slices) * CesiumMath.TWO_PI;\n      var x = normalScale * Math.cos(angle);\n      var y = normalScale * Math.sin(angle);\n      if (computeNormal) {\n        normal.x = x;\n        normal.y = y;\n\n        if (computeTangent) {\n          tangent = Cartesian3.normalize(\n            Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent),\n            tangent\n          );\n        }\n\n        if (vertexFormat.normal) {\n          normals[normalIndex++] = normal.x;\n          normals[normalIndex++] = normal.y;\n          normals[normalIndex++] = normal.z;\n          normals[normalIndex++] = normal.x;\n          normals[normalIndex++] = normal.y;\n          normals[normalIndex++] = normal.z;\n        }\n\n        if (vertexFormat.tangent) {\n          tangents[tangentIndex++] = tangent.x;\n          tangents[tangentIndex++] = tangent.y;\n          tangents[tangentIndex++] = tangent.z;\n          tangents[tangentIndex++] = tangent.x;\n          tangents[tangentIndex++] = tangent.y;\n          tangents[tangentIndex++] = tangent.z;\n        }\n\n        if (vertexFormat.bitangent) {\n          bitangent = Cartesian3.normalize(\n            Cartesian3.cross(normal, tangent, bitangent),\n            bitangent\n          );\n          bitangents[bitangentIndex++] = bitangent.x;\n          bitangents[bitangentIndex++] = bitangent.y;\n          bitangents[bitangentIndex++] = bitangent.z;\n          bitangents[bitangentIndex++] = bitangent.x;\n          bitangents[bitangentIndex++] = bitangent.y;\n          bitangents[bitangentIndex++] = bitangent.z;\n        }\n      }\n    }\n\n    for (i = 0; i < slices; i++) {\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = -1;\n      }\n      if (vertexFormat.tangent) {\n        tangents[tangentIndex++] = 1;\n        tangents[tangentIndex++] = 0;\n        tangents[tangentIndex++] = 0;\n      }\n      if (vertexFormat.bitangent) {\n        bitangents[bitangentIndex++] = 0;\n        bitangents[bitangentIndex++] = -1;\n        bitangents[bitangentIndex++] = 0;\n      }\n    }\n\n    for (i = 0; i < slices; i++) {\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = 1;\n      }\n      if (vertexFormat.tangent) {\n        tangents[tangentIndex++] = 1;\n        tangents[tangentIndex++] = 0;\n        tangents[tangentIndex++] = 0;\n      }\n      if (vertexFormat.bitangent) {\n        bitangents[bitangentIndex++] = 0;\n        bitangents[bitangentIndex++] = 1;\n        bitangents[bitangentIndex++] = 0;\n      }\n    }\n  }\n\n  var numIndices = 12 * slices - 12;\n  var indices = IndexDatatype.createTypedArray(numVertices, numIndices);\n  var index = 0;\n  var j = 0;\n  for (i = 0; i < slices - 1; i++) {\n    indices[index++] = j;\n    indices[index++] = j + 2;\n    indices[index++] = j + 3;\n\n    indices[index++] = j;\n    indices[index++] = j + 3;\n    indices[index++] = j + 1;\n\n    j += 2;\n  }\n\n  indices[index++] = twoSlices - 2;\n  indices[index++] = 0;\n  indices[index++] = 1;\n  indices[index++] = twoSlices - 2;\n  indices[index++] = 1;\n  indices[index++] = twoSlices - 1;\n\n  for (i = 1; i < slices - 1; i++) {\n    indices[index++] = twoSlices + i + 1;\n    indices[index++] = twoSlices + i;\n    indices[index++] = twoSlices;\n  }\n\n  for (i = 1; i < slices - 1; i++) {\n    indices[index++] = threeSlices;\n    indices[index++] = threeSlices + i;\n    indices[index++] = threeSlices + i + 1;\n  }\n\n  var textureCoordIndex = 0;\n  if (vertexFormat.st) {\n    var rad = Math.max(topRadius, bottomRadius);\n    for (i = 0; i < numVertices; i++) {\n      var position = Cartesian3.fromArray(positions, i * 3, positionScratch);\n      st[textureCoordIndex++] = (position.x + rad) / (2.0 * rad);\n      st[textureCoordIndex++] = (position.y + rad) / (2.0 * rad);\n    }\n  }\n\n  var attributes = new GeometryAttributes();\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents,\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents,\n    });\n  }\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: st,\n    });\n  }\n\n  radiusScratch.x = length * 0.5;\n  radiusScratch.y = Math.max(bottomRadius, topRadius);\n\n  var boundingSphere = new BoundingSphere(\n    Cartesian3.ZERO,\n    Cartesian2.magnitude(radiusScratch)\n  );\n\n  if (defined(cylinderGeometry._offsetAttribute)) {\n    length = positions.length;\n    var applyOffset = new Uint8Array(length / 3);\n    var offsetValue =\n      cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n        ? 0\n        : 1;\n    arrayFill(applyOffset, offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: cylinderGeometry._offsetAttribute,\n  });\n};\n\nvar unitCylinderGeometry;\n\n/**\n * Returns the geometric representation of a unit cylinder, including its vertices, indices, and a bounding sphere.\n * @returns {Geometry} The computed vertices and indices.\n *\n * @private\n */\nCylinderGeometry.getUnitCylinder = function () {\n  if (!defined(unitCylinderGeometry)) {\n    unitCylinderGeometry = CylinderGeometry.createGeometry(\n      new CylinderGeometry({\n        topRadius: 1.0,\n        bottomRadius: 1.0,\n        length: 1.0,\n        vertexFormat: VertexFormat.POSITION_ONLY,\n      })\n    );\n  }\n  return unitCylinderGeometry;\n};\nexport default CylinderGeometry;\n"],"names":["radiusScratch","Cartesian2","normalScratch","Cartesian3","bitangentScratch","tangentScratch","positionScratch","CylinderGeometry","options","length","defaultValue","EMPTY_OBJECT","topRadius","bottomRadius","vertexFormat","VertexFormat","DEFAULT","slices","defined","DeveloperError","offsetAttribute","GeometryOffsetAttribute","TOP","this","_length","_topRadius","_bottomRadius","_vertexFormat","clone","_slices","_offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","unitCylinderGeometry","scratchVertexFormat","scratchOptions","undefined","unpack","result","createGeometry","cylinderGeometry","twoSlices","threeSlices","numVertices","positions","CylinderGeometryLibrary","computePositions","st","Float32Array","normals","normal","tangents","tangent","bitangents","bitangent","computeNormal","computeTangent","normalIndex","tangentIndex","bitangentIndex","theta","Math","atan2","z","sin","normalScale","cos","i","angle","CesiumMath","TWO_PI","x","y","normalize","cross","UNIT_Z","indices","IndexDatatype","createTypedArray","index","j","textureCoordIndex","rad","max","position","fromArray","attributes","GeometryAttributes","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","FLOAT","boundingSphere","BoundingSphere","ZERO","magnitude","applyOffset","Uint8Array","offsetValue","NONE","arrayFill","UNSIGNED_BYTE","Geometry","primitiveType","PrimitiveType","TRIANGLES","getUnitCylinder","POSITION_ONLY"],"mappings":"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"}